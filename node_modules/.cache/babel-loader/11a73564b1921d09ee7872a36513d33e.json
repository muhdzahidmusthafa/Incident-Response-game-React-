{"ast":null,"code":"var ARROW_OFFSET = 12;\nexport var PRIORITY_MAPPING = {\n  top: ['top-center', 'bottom-center', 'right-top', 'right-bottom', 'left-top', 'left-bottom', 'top-right', 'top-left', 'bottom-right', 'bottom-left'],\n  bottom: ['bottom-center', 'top-center', 'right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-right', 'bottom-left', 'top-right', 'top-left'],\n  left: ['left-top', 'left-bottom', 'right-top', 'right-bottom', 'bottom-center', 'top-center', 'bottom-left', 'top-left', 'bottom-right', 'top-right'],\n  right: ['right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-center', 'top-center', 'bottom-right', 'top-right', 'bottom-left', 'top-left']\n};\nvar RECTANGLE_CALCULATIONS = {\n  'top-center': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-right': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-left': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-center': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-right': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-left': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-top': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-bottom': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-top': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-bottom': function (_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  }\n};\n/**\n * Returns whether one rectangle fits in another.\n */\n\nfunction canRectFit(inner, outer) {\n  return inner.left >= outer.left && inner.top >= outer.top && inner.left + inner.width <= outer.left + outer.width && inner.top + inner.height <= outer.top + outer.height;\n}\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\n\n\nexport function intersectRectangles(rectangles) {\n  var boundingOffset = null;\n\n  for (var _i = 0, rectangles_1 = rectangles; _i < rectangles_1.length; _i++) {\n    var currentRect = rectangles_1[_i];\n\n    if (!boundingOffset) {\n      boundingOffset = currentRect;\n      continue;\n    }\n\n    var left = Math.max(boundingOffset.left, currentRect.left);\n    var top_1 = Math.max(boundingOffset.top, currentRect.top);\n    var right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);\n    var bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);\n\n    if (right < left || bottom < top_1) {\n      return null;\n    }\n\n    boundingOffset = {\n      left: left,\n      top: top_1,\n      width: right - left,\n      height: bottom - top_1\n    };\n  }\n\n  return boundingOffset && boundingOffset.height * boundingOffset.width;\n}\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\n\nexport function calculatePosition(preferred, trigger, arrow, body, container, viewport, // the popover is only bound by the viewport if it is rendered in a portal\nrenderWithPortal) {\n  var bestPositionOutsideViewport = null;\n  var largestArea = 0; // Attempt to position the popover based on the priority list for this position,\n  // trying to fit it inside the container and inside the viewport.\n\n  for (var _i = 0, _a = PRIORITY_MAPPING[preferred]; _i < _a.length; _i++) {\n    var internalPosition = _a[_i];\n    var boundingOffset = RECTANGLE_CALCULATIONS[internalPosition]({\n      body: body,\n      trigger: trigger,\n      arrow: arrow\n    });\n    var fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);\n    var fitsInViewport = canRectFit(boundingOffset, viewport);\n\n    if (fitsInContainer && fitsInViewport) {\n      return {\n        internalPosition: internalPosition,\n        boundingOffset: boundingOffset\n      };\n    }\n\n    var boundingRectangles = [boundingOffset, viewport];\n\n    if (!renderWithPortal) {\n      boundingRectangles.push(container);\n    }\n\n    var availableArea = intersectRectangles(boundingRectangles);\n\n    if (availableArea && availableArea > largestArea) {\n      bestPositionOutsideViewport = {\n        internalPosition: internalPosition,\n        boundingOffset: boundingOffset\n      };\n      largestArea = availableArea;\n    }\n  } // Position it in the best position outside the viewport. The user will need to scroll to view\n  // the contents, but at least it's accessible once they do.\n\n\n  if (bestPositionOutsideViewport !== null) {\n    return bestPositionOutsideViewport;\n  } // Resort to right-top\n\n\n  return {\n    internalPosition: 'right-top',\n    boundingOffset: RECTANGLE_CALCULATIONS['right-top']({\n      body: body,\n      trigger: trigger,\n      arrow: arrow\n    })\n  };\n}","map":{"version":3,"mappings":"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","names":["ARROW_OFFSET","PRIORITY_MAPPING","top","bottom","left","right","RECTANGLE_CALCULATIONS","_a","body","trigger","arrow","height","width","canRectFit","inner","outer","intersectRectangles","rectangles","boundingOffset","_i","currentRect","Math","max","top_1","min","calculatePosition","preferred","container","viewport","renderWithPortal","bestPositionOutsideViewport","largestArea","internalPosition","fitsInContainer","fitsInViewport","boundingRectangles","push","availableArea"],"sourceRoot":"","sources":["../../../../src/popover/utils/positions.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PopoverProps, InternalPosition, BoundingOffset, BoundingBox } from '../interfaces';\n\n// A structure describing how the popover should be positioned\nexport interface CalculatePosition {\n  internalPosition: InternalPosition;\n  boundingOffset: BoundingOffset;\n}\n\ninterface ElementGroup {\n  body: BoundingBox;\n  trigger: BoundingOffset;\n  arrow: BoundingBox;\n}\n\nconst ARROW_OFFSET = 12;\n\nexport const PRIORITY_MAPPING: Record<PopoverProps.Position, InternalPosition[]> = {\n  top: [\n    'top-center',\n    'bottom-center',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'top-right',\n    'top-left',\n    'bottom-right',\n    'bottom-left',\n  ],\n  bottom: [\n    'bottom-center',\n    'top-center',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'bottom-right',\n    'bottom-left',\n    'top-right',\n    'top-left',\n  ],\n  left: [\n    'left-top',\n    'left-bottom',\n    'right-top',\n    'right-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-left',\n    'top-left',\n    'bottom-right',\n    'top-right',\n  ],\n  right: [\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-right',\n    'top-right',\n    'bottom-left',\n    'top-left',\n  ],\n};\n\nconst RECTANGLE_CALCULATIONS: Record<InternalPosition, (r: ElementGroup) => BoundingOffset> = {\n  'top-center': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'top-right': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'top-left': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-center': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-right': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-left': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'right-top': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'right-bottom': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'left-top': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'left-bottom': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n};\n\n/**\n * Returns whether one rectangle fits in another.\n */\nfunction canRectFit(inner: BoundingOffset, outer: BoundingOffset): boolean {\n  return (\n    inner.left >= outer.left &&\n    inner.top >= outer.top &&\n    inner.left + inner.width <= outer.left + outer.width &&\n    inner.top + inner.height <= outer.top + outer.height\n  );\n}\n\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles: BoundingOffset[]): number | null {\n  let boundingOffset: BoundingOffset | null = null;\n  for (const currentRect of rectangles) {\n    if (!boundingOffset) {\n      boundingOffset = currentRect;\n      continue;\n    }\n    const left = Math.max(boundingOffset.left, currentRect.left);\n    const top = Math.max(boundingOffset.top, currentRect.top);\n    const right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);\n    const bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);\n    if (right < left || bottom < top) {\n      return null;\n    }\n    boundingOffset = {\n      left,\n      top,\n      width: right - left,\n      height: bottom - top,\n    };\n  }\n  return boundingOffset && boundingOffset.height * boundingOffset.width;\n}\n\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition(\n  preferred: PopoverProps.Position,\n  trigger: BoundingOffset,\n  arrow: BoundingBox,\n  body: BoundingBox,\n  container: BoundingOffset,\n  viewport: BoundingOffset,\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal?: boolean\n): CalculatePosition {\n  let bestPositionOutsideViewport: CalculatePosition | null = null;\n  let largestArea = 0;\n\n  // Attempt to position the popover based on the priority list for this position,\n  // trying to fit it inside the container and inside the viewport.\n  for (const internalPosition of PRIORITY_MAPPING[preferred]) {\n    const boundingOffset = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n    const fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);\n    const fitsInViewport = canRectFit(boundingOffset, viewport);\n    if (fitsInContainer && fitsInViewport) {\n      return { internalPosition, boundingOffset };\n    }\n    const boundingRectangles = [boundingOffset, viewport];\n    if (!renderWithPortal) {\n      boundingRectangles.push(container);\n    }\n    const availableArea = intersectRectangles(boundingRectangles);\n    if (availableArea && availableArea > largestArea) {\n      bestPositionOutsideViewport = { internalPosition, boundingOffset };\n      largestArea = availableArea;\n    }\n  }\n\n  // Position it in the best position outside the viewport. The user will need to scroll to view\n  // the contents, but at least it's accessible once they do.\n  if (bestPositionOutsideViewport !== null) {\n    return bestPositionOutsideViewport;\n  }\n\n  // Resort to right-top\n  return {\n    internalPosition: 'right-top',\n    boundingOffset: RECTANGLE_CALCULATIONS['right-top']({ body, trigger, arrow }),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}