{"ast":null,"code":"import { __spreadArray } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect, useRef } from 'react';\n/**\n * Ponyfill for Array.prototype.findIndex.\n */\n\nexport function findIndex(array, condition) {\n  for (var i = 0; i < array.length; i++) {\n    if (condition(array[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction makeMemoizedArray(prev, next, isEqual) {\n  for (var i = 0; i < Math.max(prev.length, next.length); i++) {\n    // The next array is shorter, but all the items match.\n    if (i === next.length) {\n      return prev.slice(0, i);\n    } // The prev array is shorter, but all the items so far match.\n\n\n    if (i === prev.length) {\n      return __spreadArray(__spreadArray([], prev.slice(0, i), true), next.slice(i), true);\n    } // The item is not equal. Partition at this point.\n\n\n    if (!isEqual(prev[i], next[i])) {\n      return __spreadArray(__spreadArray(__spreadArray([], prev.slice(0, i), true), [next[i]], false), makeMemoizedArray(prev.slice(i + 1), next.slice(i + 1), isEqual), true);\n    }\n  } // All the references match. Return the old array.\n\n\n  return prev;\n}\n\nexport function useMemoizedArray(array, isEqual) {\n  var ref = useRef(array);\n  var updated = makeMemoizedArray(ref.current, array, isEqual);\n  useEffect(function () {\n    ref.current = updated;\n  }, [updated]);\n  return updated;\n}","map":{"version":3,"mappings":"uCAAA;AACA;;AACA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AAEA;;;;AAGA,OAAM,SAAUC,SAAV,CAAuBC,KAAvB,EAAgDC,SAAhD,EAA4E;EAChF,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACrC,IAAID,SAAS,CAACD,KAAK,CAACE,CAAD,CAAN,CAAb,EAAyB;MACvB,OAAOA,CAAP;IACD;EACF;;EACD,OAAO,CAAC,CAAR;AACD;;AAED,SAASE,iBAAT,CACEC,IADF,EAEEC,IAFF,EAGEC,OAHF,EAGwC;EAEtC,KAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,IAAI,CAACC,GAAL,CAASJ,IAAI,CAACF,MAAd,EAAsBG,IAAI,CAACH,MAA3B,CAApB,EAAwDD,CAAC,EAAzD,EAA6D;IAC3D;IACA,IAAIA,CAAC,KAAKI,IAAI,CAACH,MAAf,EAAuB;MACrB,OAAOE,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcR,CAAd,CAAP;IACD,CAJ0D,CAK3D;;;IACA,IAAIA,CAAC,KAAKG,IAAI,CAACF,MAAf,EAAuB;MACrB,uCAAWE,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcR,CAAd,CAAX,EAA2B,IAA3B,GAAgCI,IAAI,CAACI,KAAL,CAAWR,CAAX,CAAhC,EAA6C,IAA7C;IACD,CAR0D,CAS3D;;;IACA,IAAI,CAACK,OAAO,CAACF,IAAI,CAACH,CAAD,CAAL,EAAUI,IAAI,CAACJ,CAAD,CAAd,CAAZ,EAAgC;MAC9B,qDAAWG,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcR,CAAd,CAAX,EAA2B,IAA3B,GAA2B,CAAEI,IAAI,CAACJ,CAAD,CAAN,CAA3B,EAAoC,KAApC,GAAyCE,iBAAiB,CAACC,IAAI,CAACK,KAAL,CAAWR,CAAC,GAAG,CAAf,CAAD,EAAoBI,IAAI,CAACI,KAAL,CAAWR,CAAC,GAAG,CAAf,CAApB,EAAuCK,OAAvC,CAA1D,EAAyG,IAAzG;IACD;EACF,CAfqC,CAiBtC;;;EACA,OAAOF,IAAP;AACD;;AAED,OAAM,SAAUM,gBAAV,CAA8BX,KAA9B,EAAuDO,OAAvD,EAA6F;EACjG,IAAMK,GAAG,GAAGd,MAAM,CAAmBE,KAAnB,CAAlB;EACA,IAAMa,OAAO,GAAGT,iBAAiB,CAACQ,GAAG,CAACE,OAAL,EAAcd,KAAd,EAAqBO,OAArB,CAAjC;EACAV,SAAS,CAAC;IACRe,GAAG,CAACE,OAAJ,GAAcD,OAAd;EACD,CAFQ,EAEN,CAACA,OAAD,CAFM,CAAT;EAGA,OAAOA,OAAP;AACD","names":["useEffect","useRef","findIndex","array","condition","i","length","makeMemoizedArray","prev","next","isEqual","Math","max","slice","useMemoizedArray","ref","updated","current"],"sourceRoot":"","sources":["../../../src/tag-editor/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useRef } from 'react';\n\n/**\n * Ponyfill for Array.prototype.findIndex.\n */\nexport function findIndex<T>(array: ReadonlyArray<T>, condition: (t: T) => unknown): number {\n  for (let i = 0; i < array.length; i++) {\n    if (condition(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction makeMemoizedArray<T>(\n  prev: ReadonlyArray<T>,\n  next: ReadonlyArray<T>,\n  isEqual: (prev: T, next: T) => boolean\n): ReadonlyArray<T> {\n  for (let i = 0; i < Math.max(prev.length, next.length); i++) {\n    // The next array is shorter, but all the items match.\n    if (i === next.length) {\n      return prev.slice(0, i);\n    }\n    // The prev array is shorter, but all the items so far match.\n    if (i === prev.length) {\n      return [...prev.slice(0, i), ...next.slice(i)];\n    }\n    // The item is not equal. Partition at this point.\n    if (!isEqual(prev[i], next[i])) {\n      return [...prev.slice(0, i), next[i], ...makeMemoizedArray(prev.slice(i + 1), next.slice(i + 1), isEqual)];\n    }\n  }\n\n  // All the references match. Return the old array.\n  return prev;\n}\n\nexport function useMemoizedArray<T>(array: ReadonlyArray<T>, isEqual: (prev: T, next: T) => boolean): ReadonlyArray<T> {\n  const ref = useRef<ReadonlyArray<T>>(array);\n  const updated = makeMemoizedArray(ref.current, array, isEqual);\n  useEffect(() => {\n    ref.current = updated;\n  }, [updated]);\n  return updated;\n}\n"]},"metadata":{},"sourceType":"module"}