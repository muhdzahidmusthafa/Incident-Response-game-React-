{"ast":null,"code":"import { setText, setChoices } from \"../actions/textActions\";\nimport { addToLog, setCurrentNodeKey } from \"../actions/gameLogActions\";\nimport { setVariables } from \"../actions/variablesActions\";\nimport { checkIfGameOver, checkIfGameFail, checkIfGameEnded } from \"./helpers\"; // Import Redux store \n\nimport { store } from \"../index\";\nimport constants from \"../globals/constants\";\nexport default class GameManager {\n  // Check if the JSON data for a module has been loaded\n  static checkIfModuleLoaded(moduleName) {\n    let startingKey = \"\";\n\n    if (moduleName === constants.MODULE_INCIDENT) {\n      startingKey = constants.INCIDENT_STARTING_KEY;\n    }\n\n    return startingKey in store.getState().data.textData;\n  }\n\n  static loadGame() {\n    this.loadText();\n    this.loadChoices();\n  }\n\n  static loadText() {\n    const key = store.getState().game.currentNodeKey;\n    let text = \"\";\n\n    if (checkIfGameFail(key)) {\n      text = constants.FAIL_TEXT;\n    } else if (checkIfGameEnded(key)) {\n      text = constants.END_TEXT;\n    } else {\n      text = store.getState().data.textData[key];\n      text = text.split(constants.LINE_BREAK_SEPARATOR);\n    }\n\n    store.dispatch(setText(text));\n  }\n\n  static loadChoices() {\n    let stringTest;\n    let choices = [];\n    const currentNodeKey = store.getState().game.currentNodeKey;\n\n    if (checkIfGameFail(currentNodeKey)) {\n      choices.push({\n        key: constants.FAIL_KEY,\n        text: constants.END_CHOICE,\n        colorClass: \"color-choice\"\n      });\n    } else if (checkIfGameEnded(currentNodeKey)) {\n      choices.push({\n        key: constants.END_KEY,\n        text: constants.END_CHOICE,\n        colorClass: \"color-choice\"\n      });\n    } else {\n      const choicesData = store.getState().data.choicesData;\n\n      for (const i in choicesData) {\n        stringTest = choicesData[i].KEY;\n\n        if (stringTest.substring(0, 12) === currentNodeKey) {\n          if (this.checkChoice(i)) {\n            const choiceData = choicesData[i];\n            let choice = {\n              key: choiceData.KEY,\n              text: choiceData.text\n            };\n            choices.push(choice);\n          }\n        }\n      }\n    }\n\n    store.dispatch(setChoices(choices));\n  }\n\n  static checkChoice(choiceKey) {\n    const choice = store.getState().data.choicesData[choiceKey];\n\n    if (choice.additionalVariableCostA_Key) {\n      const condition1 = this.checkPlayerVariables(choice.additionalVariableCostA_Key, choice.additionalVariableCostA_Equivalence, choice.additionalVariableCostA_Value);\n\n      if (choice.additionalVariableCostB_Key) {\n        const condition2 = this.checkPlayerVariables(choice.additionalVariableCostB_Key, choice.additionalVariableCostB_Equivalence, choice.additionalVariableCostB_Value);\n\n        if (choice.additionalVariableCost_Operator === \"&&\") {\n          if (condition1 && condition2) {\n            return true;\n          } else {\n            return false;\n          }\n        } else if (choice.additionalVariableCost_Operator === \"||\") {\n          if (condition1 || condition2) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          // Then there's an error\n          return false;\n        }\n      } else {\n        // There's only one additional variable cost\n        if (condition1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      // There are no costs for this choice, so return true\n      return true;\n    }\n  } // This method checks for additional variables in the playerVariables object.\n  // It checks on the player's past decisions based on a reference (the variable cost key),\n  // the equivalence (logical operator), and value to be checked for. It then\n  // returns a boolean (true or false) result.\n\n\n  static checkPlayerVariables(reference, equivalence, value) {\n    const playerVariables = store.getState().variables.playerVariables;\n    const defaultValue = 0; // Search for reference and value pair in playerVariables object.\n    // If found, checks for whether it's >, <, etc. to the value provided.\n    // If it doesn't pass the test to the value, or if not found, it returns false.\n    // Empty string, null, undefined, and 0 are all falsy\n\n    if (!equivalence) {\n      // Just search for whether the additional variable is present - value doesn't matter\n      return reference in playerVariables;\n    } else if (equivalence === \"=\") {\n      // Check for presence of variable and value\n      return playerVariables[reference] === value;\n    } else if (equivalence === \"!=\" && !value) {\n      // Checks if the additional variable is present at all and returns false if present, true if not\n      // - opposite of first check in this series. e.g. if !(01JennethDead), then returns true.\n      return !(reference in playerVariables);\n    } else if (equivalence === \"!=\" && value) {\n      if (reference in playerVariables && playerVariables[reference] !== value) {\n        return true;\n      } else if (value !== defaultValue) {\n        // Variable not found, so assume default value (0)\n        return true;\n      } else {\n        return false;\n      }\n    } else if (equivalence === \"<\") {\n      if (reference in playerVariables && playerVariables[reference] < value) {\n        return true;\n      } else if (value < defaultValue) {\n        // Variable not found, so assume default value (0)\n        return true;\n      } else {\n        return false;\n      }\n    } else if (equivalence === \"<=\") {\n      if (reference in playerVariables && playerVariables[reference] <= value) {\n        return true;\n      } else if (value <= defaultValue) {\n        // Variable not found, so assume default value (0)\n        return true;\n      } else {\n        return false;\n      }\n    } else if (equivalence === \">\") {\n      if (reference in playerVariables && playerVariables[reference] > value) {\n        return true;\n      } else if (value > defaultValue) {\n        // Variable not found, so assume default value (0)\n        return true;\n      } else {\n        return false;\n      }\n    } else if (equivalence === \">=\") {\n      if (reference in playerVariables && playerVariables[reference] >= value) {\n        return true;\n      } else if (value >= defaultValue) {\n        // Variable not found, so assume default value (0)\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      // In case anything goes wrong, defaults to returning false\n      console.log(\"%c checkPlayerVariables() error \", \"color:white; background:red;\");\n      return false;\n    }\n  } // Write story node decision to gameLog.\n  // Dispatch action using Redux.\n\n\n  static writeToGameLog(textNodeKey, choiceNodeKey) {\n    store.dispatch(addToLog(textNodeKey, choiceNodeKey));\n  }\n\n  static makeDecision(choiceNodeKey) {\n    const currentNodeKey = store.getState().game.currentNodeKey;\n    this.writeToGameLog(currentNodeKey, choiceNodeKey);\n    const choice = store.getState().data.choicesData[choiceNodeKey]; // ------------------Randomize destinations------------------\n\n    let dieRollDestinationA;\n    let dieRollDestinationB;\n    let dieRollDestinationC;\n    let dieRollDestinationD; // Empty string, null, undefined, and 0 are all falsy.\n\n    if (!choice.destinationA_percentage) {\n      // There's only one destination, go to destinationA.\n      this.loadStoryNode(choice.destinationA);\n    } else if (!choice.destinationC_percentage) {\n      // There's no third destination, so it's between destinationA and destinationB.\n      // Can't just check second destination percentage, because there may or may not be a third.\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\n\n      if (dieRollDestinationA > dieRollDestinationB) {\n        // go to destinationA\n        this.loadStoryNode(choice.destinationA);\n      } else {\n        // go to destinationB\n        this.loadStoryNode(choice.destinationB);\n      }\n    } else if (!choice.destinationD_percentage) {\n      // There's no fourth destination, so it's between destinationA, destinationB, and destinationC\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\n\n      if (dieRollDestinationA > dieRollDestinationB && dieRollDestinationA > dieRollDestinationC) {\n        // go to destinationA\n        this.loadStoryNode(choice.destinationA);\n      } else if (dieRollDestinationB > dieRollDestinationC) {\n        // go to destinationB\n        this.loadStoryNode(choice.destinationB);\n      } else {\n        // go to destinationC\n        this.loadStoryNode(choice.destinationC);\n      }\n    } else {\n      // There are four destinations\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\n      dieRollDestinationD = this.rollDie() * choice.destinationD_percentage;\n\n      if (dieRollDestinationA > dieRollDestinationB && dieRollDestinationA > dieRollDestinationC && dieRollDestinationA > dieRollDestinationD) {\n        // go to destinationA\n        this.loadStoryNode(choice.destinationA);\n      } else if (dieRollDestinationB > dieRollDestinationC && dieRollDestinationB > dieRollDestinationD) {\n        // go to destinationB\n        this.loadStoryNode(choice.destinationB);\n      } else if (dieRollDestinationC > dieRollDestinationD) {\n        // go to destinationC\n        this.loadStoryNode(choice.destinationC);\n      } else {\n        // go to destinationD\n        this.loadStoryNode(choice.destinationD);\n      }\n    }\n  } // Helper method to generate random number between 1-100\n\n\n  static rollDie() {\n    return Math.floor(Math.random() * 100) + 1;\n  } // Write player variables to object in Redux store.\n  // These additional variables keep track of specific player decisions\n  // that can be evaluated later in the story.\n  // Expects to receive variables as an array of objects (can be only one object):\n  // [\n  //   {\n  //     key: additionalVariableBoostA_Key,\n  //     value: additionalVariableBoostA_Value\n  //   },\n  //   {\n  //     key: additionalVariableBoostB_Key,\n  //     value: additionalVariableBoostB_Value\n  //   }\n  // ]\n\n\n  static writeToPlayerVariables(variablesArray) {\n    // Get current playerVariables from the Redux store and copy it (since it is read only).\n    const playerVariables = Object.assign({}, store.getState().variables.playerVariables);\n    variablesArray.forEach(variable => {\n      if (variable.key in playerVariables) {\n        const original = playerVariables[variable.key];\n        playerVariables[variable.key] = original + variable.value;\n      } else {\n        playerVariables[variable.key] = variable.value;\n      }\n    });\n    store.dispatch(setVariables(playerVariables));\n  }\n\n  static loadStoryNode(destination) {\n    if (checkIfGameOver(destination)) {\n      this.updateCurrentNode(destination);\n    } else {\n      if (!this.checkKeyForLinkNode(destination)) {\n        this.updateCurrentNode(destination);\n      } else {\n        let newDestination = this.processLinkNode(destination);\n\n        while (this.checkKeyForLinkNode(newDestination)) {\n          newDestination = this.processLinkNode(newDestination);\n        }\n\n        this.updateCurrentNode(newDestination);\n      }\n    }\n\n    this.loadGame();\n  }\n\n  static checkKeyForLinkNode(nodeKey) {\n    return nodeKey.substring(0, 1) === constants.LINK_NODE_PREFIX;\n  }\n\n  static updateCurrentNode(destination) {\n    store.dispatch(setCurrentNodeKey(destination));\n  }\n\n  static processLinkNode(destination) {\n    let loadedLinkNodes = [];\n    let stringTest;\n    let test1 = false;\n    let test2 = false;\n    let test3 = false;\n    const linkNodesData = store.getState().data.linkNodesData;\n\n    for (const i in linkNodesData) {\n      stringTest = linkNodesData[i].KEY;\n\n      if (stringTest.substring(0, 13) === destination) {\n        loadedLinkNodes.push(linkNodesData[i]);\n      }\n    }\n\n    for (let i = 0; i < loadedLinkNodes.length; i++) {\n      const linkNode = loadedLinkNodes[i];\n\n      if (linkNode.variable1 !== \"ELSE\") {\n        if (!linkNode.variable2) {\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\n            test1 = true;\n          }\n        } else if (!linkNode.variable3) {\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\n            test1 = true;\n          }\n\n          if (this.checkPlayerVariables(linkNode.variable2, linkNode.equivalence2, linkNode.value2)) {\n            test2 = true;\n          }\n        } else {\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\n            test1 = true;\n          }\n\n          if (this.checkPlayerVariables(linkNode.variable2, linkNode.equivalence2, linkNode.value2)) {\n            test2 = true;\n          }\n\n          if (this.checkPlayerVariables(linkNode.variable3, linkNode.equivalence3, linkNode.value3)) {\n            test3 = true;\n          }\n        }\n\n        if (!linkNode.operator1) {\n          if (test1) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"&&\" && !linkNode.operator2) {\n          if (test1 && test2) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"||\" && !linkNode.operator2) {\n          if (test1 || test2) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"&&\" && linkNode.operator2 === \"&&\") {\n          if (test1 && test2 && test3) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"||\" && linkNode.operator2 === \"&&\") {\n          if ((test1 || test2) && test3) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"&&\" && linkNode.operator2 === \"||\") {\n          if (test1 && test2 || test3) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        } else if (linkNode.operator1 === \"||\" && linkNode.operator2 === \"||\") {\n          if (test1 || test2 || test3) {\n            return this.getRandomLinkNodeDestination(linkNode);\n          }\n        }\n      } else {\n        return this.getRandomLinkNodeDestination(linkNode);\n      }\n    }\n\n    console.log(\"%c processLinkNode() error\", \"color:white; background:red;\");\n    return null;\n  }\n\n  static getRandomLinkNodeDestination(linkNode) {\n    let dieRollA;\n    let dieRollB;\n    let dieRollC;\n    let dieRollD;\n\n    if (!linkNode.destinationA_percentage) {\n      return linkNode.destinationA;\n    } else if (!linkNode.destinationC_percentage) {\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\n\n      if (dieRollA > dieRollB) {\n        return linkNode.destinationA;\n      } else {\n        return linkNode.destinationB;\n      }\n    } else if (!linkNode.destinationD_percentage) {\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\n\n      if (dieRollA > dieRollB && dieRollA > dieRollC) {\n        return linkNode.destinationA;\n      } else if (dieRollB > dieRollC) {\n        return linkNode.destinationB;\n      } else {\n        return linkNode.destinationC;\n      }\n    } else {\n      // There are four destinations\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\n      dieRollD = this.rollDie() * linkNode.destinationD_percentage;\n\n      if (dieRollA > dieRollB && dieRollA > dieRollC && dieRollA > dieRollD) {\n        return linkNode.destinationA;\n      } else if (dieRollB > dieRollC && dieRollB > dieRollD) {\n        return linkNode.destinationB;\n      } else if (dieRollC > dieRollD) {\n        return linkNode.destinationC;\n      } else {\n        return linkNode.destinationD;\n      }\n    }\n  }\n\n}","map":{"version":3,"names":["setText","setChoices","addToLog","setCurrentNodeKey","setVariables","checkIfGameOver","checkIfGameFail","checkIfGameEnded","store","constants","GameManager","checkIfModuleLoaded","moduleName","startingKey","MODULE_INCIDENT","INCIDENT_STARTING_KEY","getState","data","textData","loadGame","loadText","loadChoices","key","game","currentNodeKey","text","FAIL_TEXT","END_TEXT","split","LINE_BREAK_SEPARATOR","dispatch","stringTest","choices","push","FAIL_KEY","END_CHOICE","colorClass","END_KEY","choicesData","i","KEY","substring","checkChoice","choiceData","choice","choiceKey","additionalVariableCostA_Key","condition1","checkPlayerVariables","additionalVariableCostA_Equivalence","additionalVariableCostA_Value","additionalVariableCostB_Key","condition2","additionalVariableCostB_Equivalence","additionalVariableCostB_Value","additionalVariableCost_Operator","reference","equivalence","value","playerVariables","variables","defaultValue","console","log","writeToGameLog","textNodeKey","choiceNodeKey","makeDecision","dieRollDestinationA","dieRollDestinationB","dieRollDestinationC","dieRollDestinationD","destinationA_percentage","loadStoryNode","destinationA","destinationC_percentage","rollDie","destinationB_percentage","destinationB","destinationD_percentage","destinationC","destinationD","Math","floor","random","writeToPlayerVariables","variablesArray","Object","assign","forEach","variable","original","destination","updateCurrentNode","checkKeyForLinkNode","newDestination","processLinkNode","nodeKey","LINK_NODE_PREFIX","loadedLinkNodes","test1","test2","test3","linkNodesData","length","linkNode","variable1","variable2","equivalence1","value1","variable3","equivalence2","value2","equivalence3","value3","operator1","getRandomLinkNodeDestination","operator2","dieRollA","dieRollB","dieRollC","dieRollD"],"sources":["C:/Users/moham/ReactProject/incident-response/src/mechanics/GameManager.js"],"sourcesContent":["import { setText, setChoices } from \"../actions/textActions\";\r\nimport { addToLog, setCurrentNodeKey } from \"../actions/gameLogActions\";\r\nimport { setVariables } from \"../actions/variablesActions\";\r\nimport { checkIfGameOver, checkIfGameFail, checkIfGameEnded } from \"./helpers\";\r\n\r\n// Import Redux store \r\nimport { store } from \"../index\";\r\n\r\nimport constants from \"../globals/constants\";\r\n\r\nexport default class GameManager {\r\n  // Check if the JSON data for a module has been loaded\r\n  static checkIfModuleLoaded(moduleName) {\r\n    let startingKey = \"\";\r\n\r\n    if (moduleName === constants.MODULE_INCIDENT) {\r\n      startingKey = constants.INCIDENT_STARTING_KEY;\r\n    }\r\n\r\n    return startingKey in store.getState().data.textData;\r\n  }\r\n\r\n  \r\n  static loadGame() {\r\n    this.loadText();\r\n    this.loadChoices();\r\n  }\r\n\r\n  \r\n  static loadText() {\r\n    const key = store.getState().game.currentNodeKey;\r\n    let text = \"\";\r\n\r\n    if (checkIfGameFail(key)) {\r\n      text = constants.FAIL_TEXT;\r\n    } else if (checkIfGameEnded(key)) {\r\n      text = constants.END_TEXT;\r\n    } else {\r\n      text = store.getState().data.textData[key];\r\n      text = text.split(constants.LINE_BREAK_SEPARATOR);\r\n    }\r\n\r\n    store.dispatch(setText(text));\r\n  }\r\n\r\n  \r\n  static loadChoices() {\r\n    let stringTest;\r\n    let choices = [];\r\n\r\n    const currentNodeKey = store.getState().game.currentNodeKey;\r\n\r\n    if (checkIfGameFail(currentNodeKey)) {\r\n      choices.push({\r\n        key: constants.FAIL_KEY,\r\n        text: constants.END_CHOICE,\r\n        colorClass: \"color-choice\",\r\n      });\r\n    } else if (checkIfGameEnded(currentNodeKey)) {\r\n      choices.push({\r\n        key: constants.END_KEY,\r\n        text: constants.END_CHOICE,\r\n        colorClass: \"color-choice\",\r\n      });\r\n    } else {\r\n      const choicesData = store.getState().data.choicesData;\r\n\r\n      \r\n      for (const i in choicesData) {\r\n        stringTest = choicesData[i].KEY;\r\n\r\n        if (stringTest.substring(0, 12) === currentNodeKey) {\r\n          if (this.checkChoice(i)) {\r\n            const choiceData = choicesData[i];\r\n\r\n            let choice = {\r\n              key: choiceData.KEY,\r\n              text: choiceData.text,\r\n            };\r\n\r\n            choices.push(choice);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    store.dispatch(setChoices(choices));\r\n  }\r\n\r\n  static checkChoice(choiceKey) {\r\n    const choice = store.getState().data.choicesData[choiceKey];\r\n    \r\n    if (choice.additionalVariableCostA_Key) {\r\n      const condition1 = this.checkPlayerVariables(\r\n        choice.additionalVariableCostA_Key,\r\n        choice.additionalVariableCostA_Equivalence,\r\n        choice.additionalVariableCostA_Value\r\n      );\r\n\r\n      if (choice.additionalVariableCostB_Key) {\r\n        \r\n\r\n        const condition2 = this.checkPlayerVariables(\r\n          choice.additionalVariableCostB_Key,\r\n          choice.additionalVariableCostB_Equivalence,\r\n          choice.additionalVariableCostB_Value\r\n        );\r\n\r\n        if (choice.additionalVariableCost_Operator === \"&&\") {\r\n          if (condition1 && condition2) {\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        } else if (choice.additionalVariableCost_Operator === \"||\") {\r\n          if (condition1 || condition2) {\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          // Then there's an error\r\n          return false;\r\n        }\r\n      } else {\r\n        // There's only one additional variable cost\r\n        if (condition1) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // There are no costs for this choice, so return true\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // This method checks for additional variables in the playerVariables object.\r\n  // It checks on the player's past decisions based on a reference (the variable cost key),\r\n  // the equivalence (logical operator), and value to be checked for. It then\r\n  // returns a boolean (true or false) result.\r\n  static checkPlayerVariables(reference, equivalence, value) {\r\n    const playerVariables = store.getState().variables.playerVariables;\r\n    const defaultValue = 0;\r\n\r\n    // Search for reference and value pair in playerVariables object.\r\n    // If found, checks for whether it's >, <, etc. to the value provided.\r\n    // If it doesn't pass the test to the value, or if not found, it returns false.\r\n\r\n    // Empty string, null, undefined, and 0 are all falsy\r\n    if (!equivalence) {\r\n      // Just search for whether the additional variable is present - value doesn't matter\r\n      return reference in playerVariables;\r\n    } else if (equivalence === \"=\") {\r\n      // Check for presence of variable and value\r\n      return playerVariables[reference] === value;\r\n    } else if (equivalence === \"!=\" && !value) {\r\n      // Checks if the additional variable is present at all and returns false if present, true if not\r\n      // - opposite of first check in this series. e.g. if !(01JennethDead), then returns true.\r\n      return !(reference in playerVariables);\r\n    } else if (equivalence === \"!=\" && value) {\r\n      if (\r\n        reference in playerVariables &&\r\n        playerVariables[reference] !== value\r\n      ) {\r\n        return true;\r\n      } else if (value !== defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === \"<\") {\r\n      if (reference in playerVariables && playerVariables[reference] < value) {\r\n        return true;\r\n      } else if (value < defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === \"<=\") {\r\n      if (reference in playerVariables && playerVariables[reference] <= value) {\r\n        return true;\r\n      } else if (value <= defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === \">\") {\r\n      if (reference in playerVariables && playerVariables[reference] > value) {\r\n        return true;\r\n      } else if (value > defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === \">=\") {\r\n      if (reference in playerVariables && playerVariables[reference] >= value) {\r\n        return true;\r\n      } else if (value >= defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      // In case anything goes wrong, defaults to returning false\r\n      console.log(\r\n        \"%c checkPlayerVariables() error \",\r\n        \"color:white; background:red;\"\r\n      );\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Write story node decision to gameLog.\r\n  // Dispatch action using Redux.\r\n  static writeToGameLog(textNodeKey, choiceNodeKey) {\r\n    store.dispatch(addToLog(textNodeKey, choiceNodeKey));\r\n  }\r\n\r\n  static makeDecision(choiceNodeKey) {\r\n    const currentNodeKey = store.getState().game.currentNodeKey;\r\n    this.writeToGameLog(currentNodeKey, choiceNodeKey);\r\n\r\n    const choice = store.getState().data.choicesData[choiceNodeKey];\r\n\r\n    // ------------------Randomize destinations------------------\r\n    let dieRollDestinationA;\r\n    let dieRollDestinationB;\r\n    let dieRollDestinationC;\r\n    let dieRollDestinationD;\r\n\r\n    // Empty string, null, undefined, and 0 are all falsy.\r\n    if (!choice.destinationA_percentage) {\r\n      // There's only one destination, go to destinationA.\r\n      this.loadStoryNode(choice.destinationA);\r\n    } else if (!choice.destinationC_percentage) {\r\n      // There's no third destination, so it's between destinationA and destinationB.\r\n      // Can't just check second destination percentage, because there may or may not be a third.\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n\r\n      if (dieRollDestinationA > dieRollDestinationB) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else {\r\n        // go to destinationB\r\n        this.loadStoryNode(choice.destinationB);\r\n      }\r\n    } else if (!choice.destinationD_percentage) {\r\n      // There's no fourth destination, so it's between destinationA, destinationB, and destinationC\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\r\n\r\n      if (\r\n        dieRollDestinationA > dieRollDestinationB &&\r\n        dieRollDestinationA > dieRollDestinationC\r\n      ) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else if (dieRollDestinationB > dieRollDestinationC) {\r\n        // go to destinationB\r\n\r\n        this.loadStoryNode(choice.destinationB);\r\n      } else {\r\n        // go to destinationC\r\n        this.loadStoryNode(choice.destinationC);\r\n      }\r\n    } else {\r\n      // There are four destinations\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\r\n      dieRollDestinationD = this.rollDie() * choice.destinationD_percentage;\r\n\r\n      if (\r\n        dieRollDestinationA > dieRollDestinationB &&\r\n        dieRollDestinationA > dieRollDestinationC &&\r\n        dieRollDestinationA > dieRollDestinationD\r\n      ) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else if (\r\n        dieRollDestinationB > dieRollDestinationC &&\r\n        dieRollDestinationB > dieRollDestinationD\r\n      ) {\r\n        // go to destinationB\r\n        this.loadStoryNode(choice.destinationB);\r\n      } else if (dieRollDestinationC > dieRollDestinationD) {\r\n        // go to destinationC\r\n        this.loadStoryNode(choice.destinationC);\r\n      } else {\r\n        // go to destinationD\r\n        this.loadStoryNode(choice.destinationD);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helper method to generate random number between 1-100\r\n  static rollDie() {\r\n    return Math.floor(Math.random() * 100) + 1;\r\n  }\r\n\r\n  // Write player variables to object in Redux store.\r\n  // These additional variables keep track of specific player decisions\r\n  // that can be evaluated later in the story.\r\n  // Expects to receive variables as an array of objects (can be only one object):\r\n  // [\r\n  //   {\r\n  //     key: additionalVariableBoostA_Key,\r\n  //     value: additionalVariableBoostA_Value\r\n  //   },\r\n  //   {\r\n  //     key: additionalVariableBoostB_Key,\r\n  //     value: additionalVariableBoostB_Value\r\n  //   }\r\n  // ]\r\n  static writeToPlayerVariables(variablesArray) {\r\n    // Get current playerVariables from the Redux store and copy it (since it is read only).\r\n    const playerVariables = Object.assign(\r\n      {},\r\n      store.getState().variables.playerVariables\r\n    );\r\n\r\n    variablesArray.forEach((variable) => {\r\n      \r\n      if (variable.key in playerVariables) {\r\n        const original = playerVariables[variable.key];\r\n        playerVariables[variable.key] = original + variable.value;\r\n      } else {\r\n        \r\n        playerVariables[variable.key] = variable.value;\r\n      }\r\n    });\r\n\r\n    \r\n    store.dispatch(setVariables(playerVariables));\r\n  }\r\n\r\n  \r\n  static loadStoryNode(destination) {\r\n    if (checkIfGameOver(destination)) {\r\n      this.updateCurrentNode(destination);\r\n    } else {\r\n      \r\n      if (!this.checkKeyForLinkNode(destination)) {\r\n        this.updateCurrentNode(destination);\r\n      } else {\r\n       \r\n        let newDestination = this.processLinkNode(destination);\r\n\r\n        while (this.checkKeyForLinkNode(newDestination)) {\r\n          newDestination = this.processLinkNode(newDestination);\r\n        }\r\n\r\n        this.updateCurrentNode(newDestination);\r\n      }\r\n    }\r\n\r\n    this.loadGame();\r\n  }\r\n\r\n  \r\n  static checkKeyForLinkNode(nodeKey) {\r\n    return nodeKey.substring(0, 1) === constants.LINK_NODE_PREFIX;\r\n  }\r\n\r\n  \r\n  static updateCurrentNode(destination) {\r\n    store.dispatch(setCurrentNodeKey(destination));\r\n  }\r\n  static processLinkNode(destination) {\r\n    let loadedLinkNodes = [];\r\n    let stringTest;\r\n    let test1 = false;\r\n    let test2 = false;\r\n    let test3 = false;\r\n    const linkNodesData = store.getState().data.linkNodesData;\r\n    for (const i in linkNodesData) {\r\n      stringTest = linkNodesData[i].KEY;\r\n      if (stringTest.substring(0, 13) === destination) {\r\n        loadedLinkNodes.push(linkNodesData[i]);\r\n      }\r\n    }\r\n\r\n    \r\n    for (let i = 0; i < loadedLinkNodes.length; i++) {\r\n      const linkNode = loadedLinkNodes[i];\r\n\r\n      if (linkNode.variable1 !== \"ELSE\") {\r\n        \r\n        if (!linkNode.variable2) {\r\n          \r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable1,\r\n              linkNode.equivalence1,\r\n              linkNode.value1\r\n            )\r\n          ) {\r\n            test1 = true;\r\n          }\r\n        } else if (!linkNode.variable3) {\r\n          \r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable1,\r\n              linkNode.equivalence1,\r\n              linkNode.value1\r\n            )\r\n          ) {\r\n            test1 = true;\r\n          }\r\n\r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable2,\r\n              linkNode.equivalence2,\r\n              linkNode.value2\r\n            )\r\n          ) {\r\n            test2 = true;\r\n          }\r\n        } else {\r\n          \r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable1,\r\n              linkNode.equivalence1,\r\n              linkNode.value1\r\n            )\r\n          ) {\r\n            test1 = true;\r\n          }\r\n\r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable2,\r\n              linkNode.equivalence2,\r\n              linkNode.value2\r\n            )\r\n          ) {\r\n            test2 = true;\r\n          }\r\n\r\n          if (\r\n            this.checkPlayerVariables(\r\n              linkNode.variable3,\r\n              linkNode.equivalence3,\r\n              linkNode.value3\r\n            )\r\n          ) {\r\n            test3 = true;\r\n          }\r\n        }\r\n        \r\n        if (!linkNode.operator1) {\r\n          \r\n          if (test1) {\r\n            \r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"&&\" && !linkNode.operator2) {\r\n          if (test1 && test2) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"||\" && !linkNode.operator2) {\r\n          if (test1 || test2) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"&&\" && linkNode.operator2 === \"&&\") {\r\n          if (test1 && test2 && test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"||\" && linkNode.operator2 === \"&&\") {\r\n          if ((test1 || test2) && test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"&&\" && linkNode.operator2 === \"||\") {\r\n          if ((test1 && test2) || test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === \"||\" && linkNode.operator2 === \"||\") {\r\n          if (test1 || test2 || test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        }\r\n      } else {\r\n        \r\n        return this.getRandomLinkNodeDestination(linkNode);\r\n      }\r\n    }\r\n    \r\n    console.log(\"%c processLinkNode() error\", \"color:white; background:red;\");\r\n    return null;\r\n  }\r\n\r\n  \r\n  static getRandomLinkNodeDestination(linkNode) {\r\n    let dieRollA;\r\n    let dieRollB;\r\n    let dieRollC;\r\n    let dieRollD;\r\n\r\n    \r\n    if (!linkNode.destinationA_percentage) {\r\n      \r\n      return linkNode.destinationA;\r\n    } else if (!linkNode.destinationC_percentage) {\r\n      \r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n\r\n      if (dieRollA > dieRollB) {\r\n        return linkNode.destinationA;\r\n      } else {\r\n        return linkNode.destinationB;\r\n      }\r\n    } else if (!linkNode.destinationD_percentage) {\r\n      \r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\r\n\r\n      if (dieRollA > dieRollB && dieRollA > dieRollC) {\r\n        return linkNode.destinationA;\r\n      } else if (dieRollB > dieRollC) {\r\n        return linkNode.destinationB;\r\n      } else {\r\n        return linkNode.destinationC;\r\n      }\r\n    } else {\r\n      // There are four destinations\r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\r\n      dieRollD = this.rollDie() * linkNode.destinationD_percentage;\r\n\r\n      if (dieRollA > dieRollB && dieRollA > dieRollC && dieRollA > dieRollD) {\r\n        return linkNode.destinationA;\r\n      } else if (dieRollB > dieRollC && dieRollB > dieRollD) {\r\n        return linkNode.destinationB;\r\n      } else if (dieRollC > dieRollD) {\r\n        return linkNode.destinationC;\r\n      } else {\r\n        return linkNode.destinationD;\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}