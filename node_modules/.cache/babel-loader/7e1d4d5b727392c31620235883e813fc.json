{"ast":null,"code":"// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nvar EPSILON = 0.0000000000001; // When x-domain is not set explicitly - guess it based on the available data.\n\nexport function computeDomainX(series) {\n  var xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [];\n  } // Assuming categorical domain.\n  // In that case, all values are to be included.\n\n\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  } // For non-categorical domain find min and max bounds.\n\n\n  return xValues.reduce(function (_a, x) {\n    var min = _a[0],\n        max = _a[1];\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n} // When y-domain is not set explicitly - guess it based on the available data and series.\n\nexport function computeDomainY(series, scaleType) {\n  var min = Number.POSITIVE_INFINITY;\n  var max = Number.NEGATIVE_INFINITY; // Find the min and max for threshold series.\n\n  series.forEach(function (s) {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  }); // Find the min and max for area series considering their stacking.\n\n  getXValues(series).forEach(function (_, xIndex) {\n    var _a; // Maintains the prev stack level.\n\n\n    var stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n      var s = series_1[_i];\n\n      if (s.type === 'area') {\n        stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  }); // If min/max is not overridden than either series or series data is empty.\n\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  } // Log scales can't start from 0, so, if possible, start from 1.\n\n\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n} // For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\n\nexport function computePlotPoints(series, xScale, yScale) {\n  var xValues = getXValues(series); // Lookup for xy[xIndex][yIndex]\n\n  var xy = []; // Lookup for xs[xIndex][seriesIndex]\n\n  var xs = []; // Lookup for sx[seriesIndex][xIndex]\n\n  var sx = []; // Filter out the data which is beyond the plot for whatever reason.\n\n  getVisibleData(xValues, xScale).forEach(function (_a, xIndex) {\n    var x = _a.x,\n        scaledX = _a.scaledX; // Maintains the prev stack level. Starting from epsilon to not break log scales.\n\n    var stackY = yScale.scaleType === 'linear' ? 0 : EPSILON; // A column of series points related to the same x.\n\n    var points = []; // Collect the points, leaving y-index as 0 for now.\n\n    series.forEach(function (s, sIndex) {\n      var _a;\n\n      if (s.type === 'threshold') {\n        var scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        var value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        var y0 = stackY;\n        var y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    }); // Sort points by y and insert the missing y-index.\n\n    points.sort(function (p1, p2) {\n      return p1.y1 - p2.y1;\n    }).forEach(function (point, index) {\n      point.index.y = index; // Insert the points to the respective two-dimensional lookup arrays.\n\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy: xy,\n    xs: xs,\n    sx: sx\n  };\n} // Finds the closest point in the sorted array.\n\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  var isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n\n  var compare = function (x) {\n    return isAscending ? getter(x) < target : getter(x) > target;\n  };\n\n  var delta = function (x) {\n    return Math.abs(getter(x) - target);\n  }; // Use binary search to find the closest value in a sorted array.\n\n\n  var lo = 0;\n  var hi = sortedArray.length - 1;\n\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n} // Returns given index if it is in range or the opposite range boundary otherwise.\n\nexport function circleIndex(index, _a) {\n  var from = _a[0],\n      to = _a[1];\n\n  if (index < from) {\n    return to;\n  }\n\n  if (index > to) {\n    return from;\n  }\n\n  return index;\n} // Delays function execution\n\nexport function throttle(func, delay) {\n  var pending = null;\n  var lastInvokeTime = null;\n  var timerId = null; // Runs on every animation frame until timer stopped.\n\n  function pendingFunc() {\n    if (pending && lastInvokeTime !== null) {\n      var time = Date.now();\n      var shouldInvoke = time - lastInvokeTime >= delay;\n\n      if (shouldInvoke) {\n        func.apply(pending[\"this\"], pending.args);\n        lastInvokeTime = time;\n        pending = null;\n      } else {\n        startTimer();\n      }\n    }\n  }\n\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n\n    timerId = requestAnimationFrame(pendingFunc);\n  } // Decorated client function with delay mechanism.\n\n\n  function throttled() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (lastInvokeTime === null) {\n      func.apply(this, args);\n      lastInvokeTime = Date.now();\n    } else {\n      pending = {\n        \"this\": this,\n        args: args\n      };\n      startTimer();\n    }\n  } // Prevents delayed function from execution when no longer needed.\n\n\n  throttled.cancel = function () {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n\n  return throttled;\n} // Compares all x-values between series to ensure they are consistent.\n\nexport function isSeriesValid(series) {\n  var _a;\n\n  var sampleXValues = getXValues(series);\n\n  for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {\n    var s = series_2[_i];\n\n    if (s.type === 'area') {\n      for (var i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n} // Takes first area series x-values as all data x-values are to match across series.\n\nfunction getXValues(series) {\n  for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {\n    var s = series_3[_i];\n\n    if (s.type === 'area') {\n      return s.data.map(function (_a) {\n        var x = _a.x;\n        return x;\n      });\n    }\n  }\n\n  return [];\n} // Returns data that is visible in the given scale.\n\n\nfunction getVisibleData(data, xScale) {\n  var scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var visibleData = [];\n\n  for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n    var x = data_1[_i];\n    var scaledX = xScale.d3Scale(x);\n\n    if (scaledX !== undefined) {\n      visibleData.push({\n        x: x,\n        scaledX: scaledX + scaledOffsetX\n      });\n    }\n  }\n\n  return visibleData;\n} // Inserts given value into a two-dimensional array.\n\n\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n\n  matrix[row][col] = value;\n} // Creates new array with only unique elements of the given array.\n\n\nfunction uniq(arr) {\n  var set = new Set();\n  var uniqArray = [];\n\n  for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {\n    var value = arr_1[_i];\n\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}","map":{"version":3,"mappings":"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","names":["EPSILON","computeDomainX","series","xValues","getXValues","length","uniq","reduce","_a","x","min","max","computeDomainY","scaleType","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","forEach","s","type","Math","y","_","xIndex","stackY","_i","data","computePlotPoints","xScale","yScale","xy","xs","sx","getVisibleData","scaledX","points","sIndex","scaledY","d3Scale","push","y0","y1","scaled","index","value","sort","p1","p2","point","insertIntoMatrix","findClosest","sortedArray","target","getter","Error","isAscending","compare","delta","abs","lo","hi","mid","floor","circleIndex","from","to","throttle","func","delay","pending","lastInvokeTime","timerId","pendingFunc","time","Date","now","shouldInvoke","apply","args","startTimer","cancelAnimationFrame","requestAnimationFrame","throttled","cancel","isSeriesValid","sampleXValues","i","map","scaledOffsetX","isCategorical","bandwidth","visibleData","undefined","matrix","row","col","arr","set","Set","uniqArray","has","add"],"sourceRoot":"","sources":["../../../../src/area-chart/model/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { AreaChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, XDomain, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartModel } from './index';\n\ninterface ThrottledFunction<F extends (...args: any) => any> {\n  (...args: Parameters<F>): void;\n  cancel(): void;\n}\n\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX<T extends ChartDataTypes>(series: readonly AreaChartProps.Series<T>[]): XDomain<T> {\n  const xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [] as unknown as XDomain<T>;\n  }\n\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues) as unknown as XDomain<T>;\n  }\n\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(\n    ([min, max], x) => [x < min ? x : min, max < x ? x : max],\n    [xValues[0], xValues[0]]\n  ) as unknown as XDomain<T>;\n}\n\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY<T>(series: readonly AreaChartProps.Series<T>[], scaleType: YScaleType): YDomain {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (s.data[xIndex]?.y || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n}\n\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints<T>(\n  series: readonly AreaChartProps.Series<T>[],\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): {\n  xy: ChartModel.PlotPoint<T>[][];\n  xs: ChartModel.PlotPoint<T>[][];\n  sx: ChartModel.PlotPoint<T>[][];\n} {\n  const xValues = getXValues(series);\n\n  // Lookup for xy[xIndex][yIndex]\n  const xy: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx: ChartModel.PlotPoint<T>[][] = [];\n\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(({ x, scaledX }, xIndex) => {\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n\n    // A column of series points related to the same x.\n    const points: ChartModel.PlotPoint<T>[] = [];\n\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: { x: scaledX, y0: scaledY, y1: scaledY },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: 0,\n        });\n      } else {\n        const value = s.data[xIndex]?.y || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: { x: scaledX, y0: yScale.d3Scale(y0) || 0, y1: yScale.d3Scale(y1) || 0 },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: value,\n        });\n\n        stackY = y1;\n      }\n    });\n\n    // Sort points by y and insert the missing y-index.\n    points\n      .sort((p1, p2) => p1.y1 - p2.y1)\n      .forEach((point, index) => {\n        point.index.y = index;\n\n        // Insert the points to the respective two-dimensional lookup arrays.\n        insertIntoMatrix(xy, point.index.x, point.index.y, point);\n        insertIntoMatrix(xs, point.index.x, point.index.s, point);\n        insertIntoMatrix(sx, point.index.s, point.index.x, point);\n      });\n  });\n\n  return { xy, xs, sx };\n}\n\n// Finds the closest point in the sorted array.\nexport function findClosest<T>(sortedArray: readonly T[], target: number, getter: (item: T) => number): T {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = (x: T) => (isAscending ? getter(x) < target : getter(x) > target);\n  const delta = (x: T) => Math.abs(getter(x) - target);\n\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n\n// Delays function execution\nexport function throttle<F extends (...args: any) => any>(func: F, delay: number): ThrottledFunction<F> {\n  let pending: null | { this: any; args: any } = null;\n  let lastInvokeTime: null | number = null;\n  let timerId: null | number = null;\n\n  // Runs on every animation frame until timer stopped.\n  function pendingFunc() {\n    if (pending && lastInvokeTime !== null) {\n      const time = Date.now();\n      const shouldInvoke = time - lastInvokeTime >= delay;\n\n      if (shouldInvoke) {\n        func.apply(pending.this, pending.args);\n        lastInvokeTime = time;\n        pending = null;\n      } else {\n        startTimer();\n      }\n    }\n  }\n\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    timerId = requestAnimationFrame(pendingFunc);\n  }\n\n  // Decorated client function with delay mechanism.\n  function throttled(this: any, ...args: any) {\n    if (lastInvokeTime === null) {\n      func.apply(this, args);\n      lastInvokeTime = Date.now();\n    } else {\n      pending = { this: this, args };\n      startTimer();\n    }\n  }\n\n  // Prevents delayed function from execution when no longer needed.\n  throttled.cancel = () => {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n\n  return throttled;\n}\n\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid<T>(series: readonly AreaChartProps.Series<T>[]) {\n  const sampleXValues = getXValues(series);\n\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (s.data[i]?.x !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues<T>(series: readonly AreaChartProps.Series<T>[]) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(({ x }) => x);\n    }\n  }\n\n  return [];\n}\n\n// Returns data that is visible in the given scale.\nfunction getVisibleData<T>(data: readonly T[], xScale: ChartScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x as any);\n\n    if (scaledX !== undefined) {\n      visibleData.push({ x, scaledX: scaledX + scaledOffsetX });\n    }\n  }\n  return visibleData;\n}\n\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix<T>(matrix: T[][], row: number, col: number, value: T) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n\n// Creates new array with only unique elements of the given array.\nfunction uniq<T>(arr: readonly T[]): readonly T[] {\n  const set = new Set();\n  const uniqArray: T[] = [];\n\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}\n"]},"metadata":{},"sourceType":"module"}