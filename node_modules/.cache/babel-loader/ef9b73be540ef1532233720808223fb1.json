{"ast":null,"code":"import { __assign } from \"tslib\";\nimport styles from './styles.css.js';\nexport var dimensionsBySize = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: 8,\n    padding: 8,\n    paddingLabels: 44\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  }\n};\nexport var refreshDimensionsBySize = {\n  small: __assign(__assign({}, dimensionsBySize.small), {\n    innerRadius: 38,\n    cornerRadius: 3\n  }),\n  medium: __assign(__assign({}, dimensionsBySize.medium), {\n    innerRadius: 75,\n    cornerRadius: 4\n  }),\n  large: __assign(__assign({}, dimensionsBySize.large), {\n    innerRadius: 105,\n    cornerRadius: 5\n  })\n};\nexport var defaultDetails = function (i18nStrings) {\n  return function (datum, dataSum) {\n    return [{\n      key: i18nStrings.detailsValue || '',\n      value: datum.value\n    }, {\n      key: i18nStrings.detailsPercentage || '',\n      value: \"\".concat((datum.value * 100 / dataSum).toFixed(0), \"%\")\n    }];\n  };\n};\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\n\nexport var balanceLabelNodes = function (nodes, markers, leftSide) {\n  var _a;\n\n  var MARGIN = 10;\n  var previousBBox = null; // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n\n  var i = leftSide ? nodes.length - 1 : 0;\n\n  while (leftSide && i >= 0 || !leftSide && i < nodes.length) {\n    var node = nodes[i]; // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n\n    var x = parseFloat(node.getAttribute('data-x') || '0');\n    var y = parseFloat(node.getAttribute('data-y') || '0');\n    var box = {\n      x: x,\n      y: y,\n      height: node.getBoundingClientRect().height\n    };\n    var marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if (!leftSide && box.x < 0 || leftSide && box.x >= 0) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', ''); // Calculate how much the current node is overlapping with the previous one.\n\n    var offset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (offset > 0) {\n      // Move the label down.\n      node.setAttribute('transform', \"translate(0 \".concat(offset, \")\")); // Adjust the attached line accordingly.\n\n      var lineNode = (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(styles['label-line']));\n\n      if (lineNode) {\n        var endY = marker.endY;\n        lineNode.setAttribute('y2', '' + (endY + offset));\n      } // Update the position accordingly to inform the next label\n\n\n      box.y += offset;\n    }\n\n    previousBBox = box;\n  }\n};","map":{"version":3,"mappings":";AAGA,OAAOA,MAAP,MAAmB,iBAAnB;AAWA,OAAO,IAAMC,gBAAgB,GAA0D;EACrFC,KAAK,EAAE;IACLC,WAAW,EAAE,EADR;IAELC,WAAW,EAAE,EAFR;IAGLC,iBAAiB,EAAE,CAHd;IAILC,OAAO,EAAE,CAJJ;IAKLC,aAAa,EAAE;EALV,CAD8E;EAQrFC,MAAM,EAAE;IACNL,WAAW,EAAE,EADP;IAENC,WAAW,EAAE,GAFP;IAGNC,iBAAiB,EAAE,EAHb;IAINC,OAAO,EAAE,EAJH;IAKNC,aAAa,EAAE;EALT,CAR6E;EAerFE,KAAK,EAAE;IACLN,WAAW,EAAE,EADR;IAELC,WAAW,EAAE,GAFR;IAGLC,iBAAiB,EAAE,EAHd;IAILC,OAAO,EAAE,EAJJ;IAKLC,aAAa,EAAE;EALV;AAf8E,CAAhF;AAwBP,OAAO,IAAMG,uBAAuB,GAA0D;EAC5FR,KAAK,wBACAD,gBAAgB,CAACC,KADjB,GACsB;IACzBC,WAAW,EAAE,EADY;IAEzBQ,YAAY,EAAE;EAFW,CADtB,CADuF;EAM5FH,MAAM,wBACDP,gBAAgB,CAACO,MADhB,GACsB;IAC1BL,WAAW,EAAE,EADa;IAE1BQ,YAAY,EAAE;EAFY,CADtB,CANsF;EAW5FF,KAAK,wBACAR,gBAAgB,CAACQ,KADjB,GACsB;IACzBN,WAAW,EAAE,GADY;IAEzBQ,YAAY,EAAE;EAFW,CADtB;AAXuF,CAAvF;AAkBP,OAAO,IAAMC,cAAc,GACzB,UAACC,WAAD,EAAuC;EAAK,iBAACC,KAAD,EAA6BC,OAA7B,EAA4C;IACtF,QACE;MAAEC,GAAG,EAAEH,WAAW,CAACI,YAAZ,IAA4B,EAAnC;MAAuCC,KAAK,EAAEJ,KAAK,CAACI;IAApD,CADF,EAEE;MACEF,GAAG,EAAEH,WAAW,CAACM,iBAAZ,IAAiC,EADxC;MAEED,KAAK,EAAE,UAAG,CAAEJ,KAAK,CAACI,KAAN,GAAc,GAAf,GAAsBH,OAAvB,EAAgCK,OAAhC,CAAwC,CAAxC,CAAH,EAA6C,GAA7C;IAFT,CAFF;EAMC,CAPyC;AAOzC,CARE;AAUP;;;;;;;AAMA,OAAO,IAAMC,iBAAiB,GAAG,UAC/BC,KAD+B,EAE/BC,OAF+B,EAG/BC,QAH+B,EAGd;;;EAEjB,IAAMC,MAAM,GAAG,EAAf;EAEA,IAAIC,YAAY,GAAoD,IAApE,CAJiB,CAMjB;EACA;;EACA,IAAIC,CAAC,GAAGH,QAAQ,GAAGF,KAAK,CAACM,MAAN,GAAe,CAAlB,GAAsB,CAAtC;;EAEA,OAAQJ,QAAQ,IAAIG,CAAC,IAAI,CAAlB,IAAyB,CAACH,QAAD,IAAaG,CAAC,GAAGL,KAAK,CAACM,MAAvD,EAAgE;IAC9D,IAAMC,IAAI,GAAGP,KAAK,CAACK,CAAD,CAAlB,CAD8D,CAG9D;IACA;IACA;IACA;;IACA,IAAMG,CAAC,GAAGC,UAAU,CAACF,IAAI,CAACG,YAAL,CAAkB,QAAlB,KAA+B,GAAhC,CAApB;IACA,IAAMC,CAAC,GAAGF,UAAU,CAACF,IAAI,CAACG,YAAL,CAAkB,QAAlB,KAA+B,GAAhC,CAApB;IACA,IAAME,GAAG,GAAG;MACVJ,CAAC,GADS;MAEVG,CAAC,GAFS;MAGVE,MAAM,EAAEN,IAAI,CAACO,qBAAL,GAA6BD;IAH3B,CAAZ;IAMA,IAAME,MAAM,GAAGd,OAAO,CAACI,CAAD,CAAtB;;IAEA,IAAIH,QAAJ,EAAc;MACZG,CAAC;IACF,CAFD,MAEO;MACLA,CAAC;IACF;;IAED,IAAI,CAACD,YAAL,EAAmB;MACjBA,YAAY,GAAGQ,GAAf;MACAL,IAAI,CAACS,YAAL,CAAkB,WAAlB,EAA+B,EAA/B;MACA;IACD;;IAED,IAAK,CAACd,QAAD,IAAaU,GAAG,CAACJ,CAAJ,GAAQ,CAAtB,IAA6BN,QAAQ,IAAIU,GAAG,CAACJ,CAAJ,IAAS,CAAtD,EAA0D;MACxD;MACA;IACD;;IAEDD,IAAI,CAACS,YAAL,CAAkB,WAAlB,EAA+B,EAA/B,EAlC8D,CAoC9D;;IACA,IAAMC,MAAM,GAAGb,YAAY,CAACO,CAAb,GAAiBP,YAAY,CAACS,MAA9B,GAAuCV,MAAvC,GAAgDS,GAAG,CAACD,CAAnE;;IAEA,IAAIM,MAAM,GAAG,CAAb,EAAgB;MACd;MACAV,IAAI,CAACS,YAAL,CAAkB,WAAlB,EAA+B,sBAAeC,MAAf,EAAqB,GAArB,CAA/B,EAFc,CAId;;MACA,IAAMC,QAAQ,GAAG,UAAI,CAACC,UAAL,MAAe,IAAf,IAAeC,aAAf,GAAe,MAAf,GAAeA,GAAEC,aAAF,CAAgB,WAAI3C,MAAM,CAAC,YAAD,CAAV,CAAhB,CAAhC;;MACA,IAAIwC,QAAJ,EAAc;QACJ,QAAI,GAAKH,MAAM,KAAf;QACRG,QAAQ,CAACF,YAAT,CAAsB,IAAtB,EAA4B,MAAMM,IAAI,GAAGL,MAAb,CAA5B;MACD,CATa,CAWd;;;MACAL,GAAG,CAACD,CAAJ,IAASM,MAAT;IACD;;IAEDb,YAAY,GAAGQ,GAAf;EACD;AACF,CArEM","names":["styles","dimensionsBySize","small","innerRadius","outerRadius","innerLabelPadding","padding","paddingLabels","medium","large","refreshDimensionsBySize","cornerRadius","defaultDetails","i18nStrings","datum","dataSum","key","detailsValue","value","detailsPercentage","toFixed","balanceLabelNodes","nodes","markers","leftSide","MARGIN","previousBBox","i","length","node","x","parseFloat","getAttribute","y","box","height","getBoundingClientRect","marker","setAttribute","offset","lineNode","parentNode","_a","querySelector","endY"],"sourceRoot":"","sources":["../../../src/pie-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PieChartProps } from './interfaces';\nimport styles from './styles.css.js';\n\ninterface Dimension {\n  innerRadius: number;\n  outerRadius: number;\n  padding: number;\n  paddingLabels: number;\n  innerLabelPadding: number;\n  cornerRadius?: number;\n}\n\nexport const dimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: 8,\n    padding: 8, // = space-xs\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: 12,\n    padding: 12, // = space-s\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: 12,\n    padding: 12, // = space-s\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n};\n\nexport const refreshDimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    ...dimensionsBySize.small,\n    innerRadius: 38,\n    cornerRadius: 3,\n  },\n  medium: {\n    ...dimensionsBySize.medium,\n    innerRadius: 75,\n    cornerRadius: 4,\n  },\n  large: {\n    ...dimensionsBySize.large,\n    innerRadius: 105,\n    cornerRadius: 5,\n  },\n};\n\nexport const defaultDetails =\n  (i18nStrings: PieChartProps.I18nStrings) => (datum: PieChartProps.Datum, dataSum: number) =>\n    [\n      { key: i18nStrings.detailsValue || '', value: datum.value },\n      {\n        key: i18nStrings.detailsPercentage || '',\n        value: `${((datum.value * 100) / dataSum).toFixed(0)}%`,\n      },\n    ];\n\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport const balanceLabelNodes = (\n  nodes: NodeListOf<SVGGElement>,\n  markers: Array<{ endY: number }>,\n  leftSide: boolean\n) => {\n  const MARGIN = 10;\n\n  let previousBBox: { x: number; y: number; height: number } | null = null;\n\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  let i = leftSide ? nodes.length - 1 : 0;\n\n  while ((leftSide && i >= 0) || (!leftSide && i < nodes.length)) {\n    const node = nodes[i];\n\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    const x = parseFloat(node.getAttribute('data-x') || '0');\n    const y = parseFloat(node.getAttribute('data-y') || '0');\n    const box = {\n      x,\n      y,\n      height: node.getBoundingClientRect().height,\n    };\n\n    const marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if ((!leftSide && box.x < 0) || (leftSide && box.x >= 0)) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', '');\n\n    // Calculate how much the current node is overlapping with the previous one.\n    const offset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (offset > 0) {\n      // Move the label down.\n      node.setAttribute('transform', `translate(0 ${offset})`);\n\n      // Adjust the attached line accordingly.\n      const lineNode = node.parentNode?.querySelector(`.${styles['label-line']}`);\n      if (lineNode) {\n        const { endY } = marker;\n        lineNode.setAttribute('y2', '' + (endY + offset));\n      }\n\n      // Update the position accordingly to inform the next label\n      box.y += offset;\n    }\n\n    previousBBox = box;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}