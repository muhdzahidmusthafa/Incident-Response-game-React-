{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { OpenAnnotation } from './annotation/open-annotation';\nimport { ClosedAnnotation } from './annotation/closed-annotation';\nimport { hotspotContext } from './context';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useTelemetry } from '../internal/hooks/use-telemetry';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nexport function getStepInfo(annotations, index) {\n  if (index >= 0) {\n    var taskIndex = 0;\n\n    for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {\n      var task = annotations_1[_i];\n\n      if (task.steps.length <= index) {\n        index -= task.steps.length;\n        taskIndex++;\n        continue;\n      }\n\n      return {\n        task: task,\n        step: task.steps[index],\n        localIndex: index,\n        taskIndex: taskIndex\n      };\n    }\n  }\n\n  return {\n    task: undefined,\n    step: undefined,\n    localIndex: 0,\n    taskIndex: 0\n  };\n} // constant empty array to keep hook dependency stable\n\nvar emptyTasks = [];\nexport default function AnnotationContext(_a) {\n  var _b, _c, _d, _e;\n\n  var currentTutorial = _a.currentTutorial,\n      children = _a.children,\n      onStepChange = _a.onStepChange,\n      onFinishHandler = _a.onFinish,\n      onStartTutorial = _a.onStartTutorial,\n      onExitTutorial = _a.onExitTutorial,\n      i18nStrings = _a.i18nStrings;\n  useTelemetry('AnnotationContext');\n\n  var _f = useState(true),\n      open = _f[0],\n      setOpen = _f[1];\n\n  var _g = useState(0),\n      currentStepIndex = _g[0],\n      setCurrentStepIndex = _g[1];\n\n  useEffect(function () {\n    // When a tutorial is started, we reset the progress to the first step.\n    setCurrentStepIndex(0);\n    setOpen(true);\n  }, [currentTutorial, setOpen]);\n\n  var _h = useState({}),\n      availableHotspots = _h[0],\n      setAvailableHotspots = _h[1]; // availableHotspots is mirrored in this ref to prevent endless loops\n  // in between registerHotspot and unregisterHotspot callbacks.\n\n\n  var availableHotspotsRef = useRef(availableHotspots);\n  var annotations = currentTutorial ? currentTutorial.tasks : emptyTasks;\n\n  var _j = getStepInfo(annotations, currentStepIndex),\n      task = _j.task,\n      step = _j.step,\n      localIndex = _j.localIndex,\n      taskIndex = _j.taskIndex;\n\n  var currentId = step === null || step === void 0 ? void 0 : step.hotspotId;\n  var totalStepCount = annotations.map(function (a) {\n    return a.steps.length;\n  }).reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  var id2index = useMemo(function () {\n    var mapping = {};\n    var counter = 0;\n\n    for (var _i = 0, annotations_2 = annotations; _i < annotations_2.length; _i++) {\n      var annotation = annotations_2[_i];\n\n      for (var _a = 0, _b = annotation.steps; _a < _b.length; _a++) {\n        var step_1 = _b[_a];\n\n        if (mapping[step_1.hotspotId] === undefined) {\n          mapping[step_1.hotspotId] = counter;\n        }\n\n        counter++;\n      }\n    }\n\n    return mapping;\n  }, [annotations]);\n  var openNextStep = useCallback(function () {\n    var newStepIndex = Math.min(currentStepIndex + 1, totalStepCount);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: newStepIndex,\n      reason: 'next'\n    });\n  }, [currentStepIndex, onStepChange, totalStepCount]);\n  var openPreviousStep = useCallback(function () {\n    var newStepIndex = Math.max(currentStepIndex - 1, 0);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: newStepIndex,\n      reason: 'previous'\n    });\n  }, [onStepChange, currentStepIndex]);\n  var onFinish = useCallback(function () {\n    return fireNonCancelableEvent(onFinishHandler);\n  }, [onFinishHandler]);\n  /**\n   * If the currently open hotspot disappears from the page (e.g. because of a react-router navigation),\n   * this Effect detects the nearest available hotspot and changes to it. This allows us to e.g. automatically\n   * advance to the first step on the new page (or the last step on the previous page, in case the user\n   * navigates back).\n   */\n\n  var isCurrentHotspotAvailable = currentId ? availableHotspots[currentId] : null;\n  useEffect(function () {\n    if (!currentId || availableHotspotsRef.current[currentId]) {\n      return;\n    }\n\n    var findNearestHotspot = function () {\n      var nearestHotspot = undefined;\n      var nearestDistance = Infinity;\n\n      for (var _i = 0, _a = Object.keys(availableHotspotsRef.current); _i < _a.length; _i++) {\n        var hotspotId = _a[_i];\n        var distanceFromCurrentHotspot = Math.abs(id2index[hotspotId] - currentStepIndex);\n\n        if (distanceFromCurrentHotspot < nearestDistance) {\n          nearestDistance = distanceFromCurrentHotspot;\n          nearestHotspot = hotspotId;\n        }\n      }\n\n      return nearestHotspot;\n    };\n\n    var nearestHotspot = findNearestHotspot();\n\n    if (nearestHotspot) {\n      var newStepIndex = id2index[nearestHotspot];\n      setCurrentStepIndex(newStepIndex);\n      setOpen(true);\n      fireNonCancelableEvent(onStepChange, {\n        step: newStepIndex,\n        reason: 'auto-fallback'\n      });\n    }\n  }, [annotations, isCurrentHotspotAvailable, currentId, currentStepIndex, id2index, onStepChange]);\n  var onDismiss = useCallback(function () {\n    setOpen(false);\n  }, [setOpen]);\n  var onOpen = useCallback(function (stepIndex) {\n    setCurrentStepIndex(stepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: stepIndex,\n      reason: 'open'\n    });\n    setOpen(true);\n  }, [onStepChange, setOpen]);\n  var idOfPreviousHotspot = (_b = getStepInfo(annotations, currentStepIndex - 1).step) === null || _b === void 0 ? void 0 : _b.hotspotId;\n  var idOfNextHotspot = (_c = getStepInfo(annotations, currentStepIndex + 1).step) === null || _c === void 0 ? void 0 : _c.hotspotId;\n  var previousHotspotIsAvailable = (_d = idOfPreviousHotspot !== undefined && availableHotspots[idOfPreviousHotspot]) !== null && _d !== void 0 ? _d : false;\n  var nextHotspotIsAvailable = (_e = idOfNextHotspot !== undefined && availableHotspots[idOfNextHotspot]) !== null && _e !== void 0 ? _e : false;\n  var getContentForId = useCallback(function (id, direction) {\n    if (currentTutorial === null || currentTutorial === void 0 ? void 0 : currentTutorial.completed) {\n      return null;\n    }\n\n    var globalStepIndex = id2index[id];\n\n    if (globalStepIndex === undefined) {\n      // This hotspot is not used in the current tutorial.\n      return null;\n    }\n\n    if (!task || !step || !open || id !== currentId) {\n      return React.createElement(ClosedAnnotation, {\n        globalStepIndex: globalStepIndex,\n        i18nStrings: i18nStrings,\n        onOpen: onOpen,\n        focusOnRender: id === currentId\n      });\n    }\n\n    return React.createElement(OpenAnnotation, {\n      i18nStrings: i18nStrings,\n      direction: direction,\n      title: i18nStrings.taskTitle(taskIndex, task.title),\n      content: step.content,\n      alert: step.warningAlert,\n      showPreviousButton: currentStepIndex !== 0,\n      showFinishButton: currentStepIndex + 1 === totalStepCount,\n      taskLocalStepIndex: localIndex,\n      totalLocalSteps: task.steps.length,\n      nextButtonEnabled: nextHotspotIsAvailable,\n      onNextButtonClick: openNextStep,\n      onFinish: onFinish,\n      previousButtonEnabled: previousHotspotIsAvailable,\n      onPreviousButtonClick: openPreviousStep,\n      onDismiss: onDismiss\n    });\n  }, [id2index, currentTutorial, task, step, open, currentId, currentStepIndex, i18nStrings, taskIndex, localIndex, totalStepCount, nextHotspotIsAvailable, openNextStep, onFinish, previousHotspotIsAvailable, openPreviousStep, onDismiss, onOpen]);\n  var registerHotspot = useCallback(function (id) {\n    var _a;\n\n    if (!id2index || id2index[id] === undefined) {\n      // This hotspot is not used in the current tutorial.\n      return;\n    }\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n\n\n    availableHotspotsRef.current = __assign(__assign({}, availableHotspotsRef.current), (_a = {}, _a[id] = true, _a));\n    setAvailableHotspots(function (availableHotspots) {\n      var _a;\n\n      if (availableHotspots[id]) {\n        return availableHotspots;\n      }\n\n      return __assign(__assign({}, availableHotspots), (_a = {}, _a[id] = true, _a));\n    });\n  }, // We need to react on id2index changes for registering new hotspots when the map changes.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [id2index]);\n  var unregisterHotspot = useCallback(function (id) {\n    if (!availableHotspotsRef.current[id]) {\n      // Prevents unnecessary re-renders.\n      return;\n    }\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n\n\n    availableHotspotsRef.current = removeKey(id, availableHotspotsRef.current);\n    setAvailableHotspots(function (availableHotspots) {\n      if (!availableHotspots[id]) {\n        return availableHotspots;\n      }\n\n      return removeKey(id, availableHotspots);\n    });\n  }, []);\n  var context = {\n    getContentForId: getContentForId,\n    registerHotspot: registerHotspot,\n    unregisterHotspot: unregisterHotspot,\n    onStartTutorial: onStartTutorial,\n    onExitTutorial: onExitTutorial,\n    currentStepIndex: currentStepIndex,\n    currentTutorial: currentTutorial\n  };\n  return React.createElement(hotspotContext.Provider, {\n    value: context\n  }, children);\n}\napplyDisplayName(AnnotationContext, 'AnnotationContext');\n\nfunction removeKey(key, object) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _a = object,\n      _b = key,\n      _ = _a[_b],\n      remainingObject = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  return remainingObject;\n}","map":{"version":3,"mappings":"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","names":["React","useCallback","useEffect","useMemo","useRef","useState","OpenAnnotation","ClosedAnnotation","hotspotContext","fireNonCancelableEvent","useTelemetry","applyDisplayName","getStepInfo","annotations","index","taskIndex","_i","task","steps","length","step","localIndex","undefined","emptyTasks","AnnotationContext","_a","currentTutorial","children","onStepChange","onFinishHandler","onStartTutorial","onExitTutorial","i18nStrings","open","setOpen","currentStepIndex","setCurrentStepIndex","availableHotspots","setAvailableHotspots","availableHotspotsRef","tasks","currentId","hotspotId","totalStepCount","map","reduce","a","b","id2index","mapping","counter","annotation","step_1","openNextStep","newStepIndex","Math","min","reason","openPreviousStep","max","onFinish","isCurrentHotspotAvailable","current","findNearestHotspot","nearestHotspot","nearestDistance","Infinity","keys","distanceFromCurrentHotspot","abs","onDismiss","onOpen","stepIndex","idOfPreviousHotspot","_b","idOfNextHotspot","_c","previousHotspotIsAvailable","_d","nextHotspotIsAvailable","_e","getContentForId","id","direction","completed","globalStepIndex","focusOnRender","title","taskTitle","content","alert","warningAlert","showPreviousButton","showFinishButton","taskLocalStepIndex","totalLocalSteps","nextButtonEnabled","onNextButtonClick","previousButtonEnabled","onPreviousButtonClick","registerHotspot","__assign","unregisterHotspot","removeKey","context","Provider","value","key","object","_","remainingObject"],"sourceRoot":"","sources":["../../../src/annotation-context/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { OpenAnnotation } from './annotation/open-annotation';\nimport { ClosedAnnotation } from './annotation/closed-annotation';\nimport { AnnotationContextProps } from './interfaces';\nimport { HotspotContext, hotspotContext } from './context';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { HotspotProps } from '../hotspot/interfaces';\nimport { useTelemetry } from '../internal/hooks/use-telemetry';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\n\nexport { AnnotationContextProps };\n\nexport function getStepInfo(annotations: readonly AnnotationContextProps.Task[], index: number) {\n  if (index >= 0) {\n    let taskIndex = 0;\n    for (const task of annotations) {\n      if (task.steps.length <= index) {\n        index -= task.steps.length;\n        taskIndex++;\n        continue;\n      }\n      return { task, step: task.steps[index], localIndex: index, taskIndex };\n    }\n  }\n  return { task: undefined, step: undefined, localIndex: 0, taskIndex: 0 };\n}\n\n// constant empty array to keep hook dependency stable\nconst emptyTasks: ReadonlyArray<AnnotationContextProps.Task> = [];\n\nexport default function AnnotationContext({\n  currentTutorial,\n  children,\n  onStepChange,\n  onFinish: onFinishHandler,\n  onStartTutorial,\n  onExitTutorial,\n  i18nStrings,\n}: AnnotationContextProps): JSX.Element {\n  useTelemetry('AnnotationContext');\n\n  const [open, setOpen] = useState(true);\n\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  useEffect(() => {\n    // When a tutorial is started, we reset the progress to the first step.\n    setCurrentStepIndex(0);\n    setOpen(true);\n  }, [currentTutorial, setOpen]);\n\n  const [availableHotspots, setAvailableHotspots] = useState<Record<string, true | undefined>>({});\n  // availableHotspots is mirrored in this ref to prevent endless loops\n  // in between registerHotspot and unregisterHotspot callbacks.\n  const availableHotspotsRef = useRef<Record<string, true | undefined>>(availableHotspots);\n\n  const annotations = currentTutorial ? currentTutorial.tasks : emptyTasks;\n  const { task, step, localIndex, taskIndex } = getStepInfo(annotations, currentStepIndex);\n  const currentId = step?.hotspotId;\n  const totalStepCount = annotations.map(a => a.steps.length).reduce((a, b) => a + b, 0);\n\n  const id2index = useMemo(() => {\n    const mapping: Record<string, number> = {};\n\n    let counter = 0;\n    for (const annotation of annotations) {\n      for (const step of annotation.steps) {\n        if (mapping[step.hotspotId] === undefined) {\n          mapping[step.hotspotId] = counter;\n        }\n        counter++;\n      }\n    }\n\n    return mapping;\n  }, [annotations]);\n\n  const openNextStep = useCallback(() => {\n    const newStepIndex = Math.min(currentStepIndex + 1, totalStepCount);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'next' });\n  }, [currentStepIndex, onStepChange, totalStepCount]);\n\n  const openPreviousStep = useCallback(() => {\n    const newStepIndex = Math.max(currentStepIndex - 1, 0);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'previous' });\n  }, [onStepChange, currentStepIndex]);\n\n  const onFinish = useCallback(() => fireNonCancelableEvent(onFinishHandler), [onFinishHandler]);\n\n  /**\n   * If the currently open hotspot disappears from the page (e.g. because of a react-router navigation),\n   * this Effect detects the nearest available hotspot and changes to it. This allows us to e.g. automatically\n   * advance to the first step on the new page (or the last step on the previous page, in case the user\n   * navigates back).\n   */\n  const isCurrentHotspotAvailable = currentId ? availableHotspots[currentId] : null;\n  useEffect(() => {\n    if (!currentId || availableHotspotsRef.current[currentId]) {\n      return;\n    }\n\n    const findNearestHotspot = () => {\n      let nearestHotspot: string | undefined = undefined;\n      let nearestDistance = Infinity;\n      for (const hotspotId of Object.keys(availableHotspotsRef.current)) {\n        const distanceFromCurrentHotspot = Math.abs(id2index[hotspotId] - currentStepIndex);\n        if (distanceFromCurrentHotspot < nearestDistance) {\n          nearestDistance = distanceFromCurrentHotspot;\n          nearestHotspot = hotspotId;\n        }\n      }\n      return nearestHotspot;\n    };\n\n    const nearestHotspot = findNearestHotspot();\n    if (nearestHotspot) {\n      const newStepIndex = id2index[nearestHotspot];\n      setCurrentStepIndex(newStepIndex);\n      setOpen(true);\n      fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'auto-fallback' });\n    }\n  }, [annotations, isCurrentHotspotAvailable, currentId, currentStepIndex, id2index, onStepChange]);\n\n  const onDismiss = useCallback(() => {\n    setOpen(false);\n  }, [setOpen]);\n\n  const onOpen = useCallback(\n    (stepIndex: number) => {\n      setCurrentStepIndex(stepIndex);\n      fireNonCancelableEvent(onStepChange, { step: stepIndex, reason: 'open' });\n      setOpen(true);\n    },\n    [onStepChange, setOpen]\n  );\n\n  const idOfPreviousHotspot = getStepInfo(annotations, currentStepIndex - 1).step?.hotspotId;\n  const idOfNextHotspot = getStepInfo(annotations, currentStepIndex + 1).step?.hotspotId;\n  const previousHotspotIsAvailable =\n    (idOfPreviousHotspot !== undefined && availableHotspots[idOfPreviousHotspot]) ?? false;\n  const nextHotspotIsAvailable = (idOfNextHotspot !== undefined && availableHotspots[idOfNextHotspot]) ?? false;\n\n  const getContentForId = useCallback(\n    (id: string, direction: HotspotProps['direction']) => {\n      if (currentTutorial?.completed) {\n        return null;\n      }\n\n      const globalStepIndex = id2index[id];\n      if (globalStepIndex === undefined) {\n        // This hotspot is not used in the current tutorial.\n        return null;\n      }\n\n      if (!task || !step || !open || id !== currentId) {\n        return (\n          <ClosedAnnotation\n            globalStepIndex={globalStepIndex}\n            i18nStrings={i18nStrings}\n            onOpen={onOpen}\n            focusOnRender={id === currentId}\n          />\n        );\n      }\n\n      return (\n        <OpenAnnotation\n          i18nStrings={i18nStrings}\n          direction={direction}\n          title={i18nStrings.taskTitle(taskIndex, task.title)}\n          content={step.content}\n          alert={step.warningAlert}\n          showPreviousButton={currentStepIndex !== 0}\n          showFinishButton={currentStepIndex + 1 === totalStepCount}\n          taskLocalStepIndex={localIndex}\n          totalLocalSteps={task.steps.length}\n          nextButtonEnabled={nextHotspotIsAvailable}\n          onNextButtonClick={openNextStep}\n          onFinish={onFinish}\n          previousButtonEnabled={previousHotspotIsAvailable}\n          onPreviousButtonClick={openPreviousStep}\n          onDismiss={onDismiss}\n        />\n      );\n    },\n    [\n      id2index,\n      currentTutorial,\n      task,\n      step,\n      open,\n      currentId,\n      currentStepIndex,\n      i18nStrings,\n      taskIndex,\n      localIndex,\n      totalStepCount,\n      nextHotspotIsAvailable,\n      openNextStep,\n      onFinish,\n      previousHotspotIsAvailable,\n      openPreviousStep,\n      onDismiss,\n      onOpen,\n    ]\n  );\n\n  const registerHotspot = useCallback(\n    (id: string) => {\n      if (!id2index || id2index[id] === undefined) {\n        // This hotspot is not used in the current tutorial.\n        return;\n      }\n\n      /*\n        To ensure that all hotspots are immediately known to all triggered useEffects, we\n        need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n        they will be batched and delayed until after the useEffects are run.\n      */\n      availableHotspotsRef.current = { ...availableHotspotsRef.current, [id]: true } as const;\n\n      setAvailableHotspots(availableHotspots => {\n        if (availableHotspots[id]) {\n          return availableHotspots;\n        }\n\n        return { ...availableHotspots, [id]: true } as const;\n      });\n    },\n    // We need to react on id2index changes for registering new hotspots when the map changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [id2index]\n  );\n\n  const unregisterHotspot = useCallback((id: string) => {\n    if (!availableHotspotsRef.current[id]) {\n      // Prevents unnecessary re-renders.\n      return;\n    }\n\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n    availableHotspotsRef.current = removeKey(id, availableHotspotsRef.current);\n\n    setAvailableHotspots(availableHotspots => {\n      if (!availableHotspots[id]) {\n        return availableHotspots;\n      }\n\n      return removeKey(id, availableHotspots);\n    });\n  }, []);\n\n  const context: HotspotContext = {\n    getContentForId,\n    registerHotspot,\n    unregisterHotspot,\n    onStartTutorial,\n    onExitTutorial,\n    currentStepIndex,\n    currentTutorial,\n  };\n\n  return <hotspotContext.Provider value={context}>{children}</hotspotContext.Provider>;\n}\n\napplyDisplayName(AnnotationContext, 'AnnotationContext');\n\nfunction removeKey<T extends Record<string, any>>(key: keyof T, object: T) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { [key]: _, ...remainingObject } = object;\n  return remainingObject;\n}\n"]},"metadata":{},"sourceType":"module"}