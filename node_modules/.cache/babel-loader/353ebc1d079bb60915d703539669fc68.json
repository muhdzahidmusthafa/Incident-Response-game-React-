{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { filterOptions, isInteractive, isGroupInteractive, isGroup } from '../../internal/components/option/utils/filter-options';\nimport { useDebounceCallback } from '../../internal/hooks/use-debounce-callback';\nexport var isChar = function (keyCode) {\n  return [0, KeyCode.enter, KeyCode.space, KeyCode.tab].indexOf(keyCode) === -1;\n};\nexport var isRepeatedChar = function (str) {\n  return str.split('').every(function (c) {\n    return c === str[0];\n  });\n};\n\nfunction findMatchingOption(options, searchText, currentHighlight, useInteractiveGroups) {\n  var interactivityCheck = useInteractiveGroups ? isGroupInteractive : isInteractive;\n\n  var filter = function (searchText) {\n    return filterOptions(options, searchText, true).filter(function (option) {\n      return interactivityCheck(option);\n    });\n  };\n\n  var matchingOptions = filter(searchText);\n\n  if (matchingOptions.length === 1) {\n    return matchingOptions[0];\n  } // Hit the same char over and over, we assume they want to cycle through\n\n\n  if (currentHighlight && searchText.length > 1 && isRepeatedChar(searchText)) {\n    var matchingOptions_1 = filter(searchText[0]);\n\n    if (matchingOptions_1.length > 0) {\n      //handling OptionGroups when useInteractiveGroups is set\n      var active = isGroup(currentHighlight) ? matchingOptions_1.map(function (_a) {\n        var option = _a.option;\n        return option;\n      }).indexOf(currentHighlight) : matchingOptions_1.map(function (_a) {\n        var option = _a.option;\n        return option.value;\n      }).indexOf(currentHighlight.value); // Pick the next thing (if something with this prefix wasn't selected\n      // we'll end up with the first option)\n\n      active += 1;\n      active = active % matchingOptions_1.length;\n      return matchingOptions_1[active];\n    }\n  } // We have multiple things that start with this prefix.  Based on the\n  // behavior of native select, this is considered after the repeated case\n\n\n  if (matchingOptions.length > 0) {\n    return matchingOptions[0];\n  }\n\n  return null;\n}\n\nexport function useNativeSearch(_a) {\n  var isEnabled = _a.isEnabled,\n      options = _a.options,\n      isKeyboard = _a.isKeyboard,\n      highlightOption = _a.highlightOption,\n      highlightedOption = _a.highlightedOption,\n      useInteractiveGroups = _a.useInteractiveGroups;\n  var value = useRef('');\n  var delayedResetValue = useDebounceCallback(function () {\n    return value.current = '';\n  }, 500);\n  return function (event) {\n    isKeyboard.current = true;\n\n    if (!isEnabled) {\n      return;\n    }\n\n    var charCode = event.charCode;\n\n    if (!isChar(charCode)) {\n      return;\n    }\n\n    delayedResetValue();\n    var newValue = value.current + String.fromCharCode(charCode);\n    value.current = newValue;\n    var nextHighlight = findMatchingOption(options, newValue, highlightedOption, useInteractiveGroups);\n\n    if (nextHighlight) {\n      highlightOption(nextHighlight);\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useRef","KeyCode","filterOptions","isInteractive","isGroupInteractive","isGroup","useDebounceCallback","isChar","keyCode","enter","space","tab","indexOf","isRepeatedChar","str","split","every","findMatchingOption","options","searchText","currentHighlight","useInteractiveGroups","interactivityCheck","filter","option","matchingOptions","length","matchingOptions_1","active","map","_a","value","useNativeSearch","isEnabled","isKeyboard","highlightOption","highlightedOption","delayedResetValue","current","event","charCode","newValue","String","fromCharCode","nextHighlight"],"sourceRoot":"","sources":["../../../../src/select/utils/use-native-search.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport {\n  filterOptions,\n  isInteractive,\n  isGroupInteractive,\n  isGroup,\n} from '../../internal/components/option/utils/filter-options';\nimport { DropdownOption, OptionDefinition, OptionGroup } from '../../internal/components/option/interfaces';\nimport { useDebounceCallback } from '../../internal/hooks/use-debounce-callback';\n\nexport const isChar = (keyCode: number): boolean => {\n  return [0, KeyCode.enter, KeyCode.space, KeyCode.tab].indexOf(keyCode) === -1;\n};\n\nexport const isRepeatedChar = (str: string) => str.split('').every(c => c === str[0]);\n\ninterface UseNativeSearchProps {\n  isEnabled: boolean;\n  isKeyboard: React.MutableRefObject<boolean>;\n  options: ReadonlyArray<DropdownOption>;\n  highlightOption: (option: DropdownOption) => void;\n  highlightedOption: OptionDefinition | undefined | null;\n  useInteractiveGroups?: boolean;\n}\n\nfunction findMatchingOption(\n  options: ReadonlyArray<DropdownOption>,\n  searchText: string,\n  currentHighlight: OptionDefinition | OptionGroup | undefined | null,\n  useInteractiveGroups?: boolean\n) {\n  const interactivityCheck = useInteractiveGroups ? isGroupInteractive : isInteractive;\n  const filter = (searchText: string) =>\n    filterOptions(options, searchText, true).filter(option => interactivityCheck(option));\n  const matchingOptions = filter(searchText);\n\n  if (matchingOptions.length === 1) {\n    return matchingOptions[0];\n  }\n\n  // Hit the same char over and over, we assume they want to cycle through\n  if (currentHighlight && searchText.length > 1 && isRepeatedChar(searchText)) {\n    const matchingOptions = filter(searchText[0]);\n\n    if (matchingOptions.length > 0) {\n      //handling OptionGroups when useInteractiveGroups is set\n      let active: number = isGroup(currentHighlight)\n        ? matchingOptions.map(({ option }) => option).indexOf(currentHighlight)\n        : matchingOptions\n            .map(({ option }) => (option as OptionDefinition).value)\n            .indexOf((currentHighlight as OptionDefinition).value);\n\n      // Pick the next thing (if something with this prefix wasn't selected\n      // we'll end up with the first option)\n      active += 1;\n      active = active % matchingOptions.length;\n      return matchingOptions[active];\n    }\n  }\n\n  // We have multiple things that start with this prefix.  Based on the\n  // behavior of native select, this is considered after the repeated case\n  if (matchingOptions.length > 0) {\n    return matchingOptions[0];\n  }\n  return null;\n}\n\nexport function useNativeSearch({\n  isEnabled,\n  options,\n  isKeyboard,\n  highlightOption,\n  highlightedOption,\n  useInteractiveGroups,\n}: UseNativeSearchProps) {\n  const value = useRef('');\n\n  const delayedResetValue = useDebounceCallback(() => (value.current = ''), 500);\n\n  return (event: React.KeyboardEvent) => {\n    isKeyboard.current = true;\n    if (!isEnabled) {\n      return;\n    }\n\n    const { charCode } = event;\n    if (!isChar(charCode)) {\n      return;\n    }\n    delayedResetValue();\n    const newValue = value.current + String.fromCharCode(charCode);\n    value.current = newValue;\n\n    const nextHighlight = findMatchingOption(options, newValue, highlightedOption, useInteractiveGroups);\n    if (nextHighlight) {\n      highlightOption(nextHighlight);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}