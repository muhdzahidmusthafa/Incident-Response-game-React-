{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport * as React from 'react';\nimport { isDevelopment } from '../../is-development';\nimport { warnOnce } from '../../logging';\n/**\n * This hook allows you to make a component that can be used both in controlled mode and uncontrolled mode.\n * Pass in your component's props, and then implement your component as if it was only controlled.\n * When calling onChange callbacks (or the equivalent for your property), you need to call both the callback returned by this function\n * as well as the callback provided in your component's props.\n *\n * A component determines its mode (either controlled or uncontrolled) on the first render and keeps it for its lifetime. The mode cannot\n * be switched later.\n *\n *\n * Example usage:\n * ```jsx\n * const [checked, setChecked] = useControllable(\n *     props,\n *     props.defaultEnabled ?? false,\n *     {\n *        componentName: 'MyCheckboxComponent',\n *        controlledProp: 'enabled',\n *        changeHandler: 'onCheckedStatusChange'\n *     }\n * )\n *\n * return\n *  <input\n *   type=\"checkbox\"\n *   checked={checked}\n *   onChange={event => {\n *    setChecked(event.target.checked);\n *    fireNonCancelableEvent(props.onCheckedStatusChange, { checked: event.target.checked })\n *   }} />\n * ```\n *\n * @param controlledValue value for the controlled mode\n * @param handler update handler for controlled mode\n * @param defaultValue initial value for uncontrolled mode\n * @param description property metadata\n */\n\nexport function useControllable(controlledValue, handler, defaultValue, _a) {\n  var componentName = _a.componentName,\n      changeHandler = _a.changeHandler,\n      controlledProp = _a.controlledProp; // The decision whether a component is controlled or uncontrolled is made on its first render and cannot be changed afterwards.\n\n  var isControlled = React.useState(controlledValue !== undefined)[0];\n\n  if (isDevelopment) {\n    // Print a warning if the component switches between controlled and uncontrolled mode.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(function () {\n      if (isControlled && handler === undefined) {\n        warnOnce(componentName, \"You provided a `\".concat(controlledProp, \"` prop without an `\").concat(changeHandler, \"` handler. This will render a non-interactive component.\"));\n      }\n    }, [handler, isControlled, componentName, changeHandler, controlledProp]); // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    React.useEffect(function () {\n      var isControlledNow = controlledValue !== undefined;\n\n      if (isControlled !== isControlledNow) {\n        var initialMode = isControlled ? 'controlled' : 'uncontrolled';\n        var modeNow = isControlledNow ? 'controlled' : 'uncontrolled';\n        warnOnce(componentName, \"A component tried to change \".concat(initialMode, \" '\").concat(controlledProp, \"' property to be \").concat(modeNow, \". \") + \"This is not supported. Properties should not switch from \".concat(initialMode, \" to \").concat(modeNow, \" (or vice versa). \") + \"Decide between using a controlled or uncontrolled mode for the lifetime of the component. \" + \"More info: https://fb.me/react-controlled-components\");\n      }\n    }, [isControlled, controlledProp, componentName, controlledValue]);\n  } // This is the value that is used if the component is uncontrolled.\n\n\n  var _b = React.useState(defaultValue),\n      valueState = _b[0],\n      setValue = _b[1];\n\n  var _c = React.useState(false),\n      valueHasBeenSet = _c[0],\n      setValueHasBeenSet = _c[1]; // We track changes to the defaultValue\n\n\n  var currentUncontrolledValue = valueHasBeenSet ? valueState : defaultValue;\n  var setUncontrolledValue = React.useCallback(function (newValue) {\n    setValue(newValue);\n    setValueHasBeenSet(true);\n  }, [setValue, setValueHasBeenSet]);\n\n  if (isControlled) {\n    return [controlledValue, defaultCallback];\n  } else {\n    return [currentUncontrolledValue, setUncontrolledValue];\n  }\n}\n\nfunction defaultCallback() {\n  return void 0;\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,aAAT,QAA8B,sBAA9B;AACA,SAASC,QAAT,QAAyB,eAAzB;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAM,SAAUC,eAAV,CACJC,eADI,EAEJC,OAFI,EAGJC,YAHI,EAIJC,EAJI,EAIiE;MAAnEC,aAAa;MAAEC,aAAa;MAAEC,cAAc,qBAAuB,CAErE;;EACA,IAAMC,YAAY,GAAGX,KAAK,CAACY,QAAN,CAAeR,eAAe,KAAKS,SAAnC,EAA8C,CAA9C,CAArB;;EAEA,IAAIZ,aAAJ,EAAmB;IACjB;IAEA;IACAD,KAAK,CAACc,SAAN,CAAgB;MACd,IAAIH,YAAY,IAAIN,OAAO,KAAKQ,SAAhC,EAA2C;QACzCX,QAAQ,CACNM,aADM,EAEN,0BAAoBE,cAApB,EAAkC,qBAAlC,EAAkCK,MAAlC,CAA0DN,aAA1D,EAAuE,0DAAvE,CAFM,CAAR;MAID;IACF,CAPD,EAOG,CAACJ,OAAD,EAAUM,YAAV,EAAwBH,aAAxB,EAAuCC,aAAvC,EAAsDC,cAAtD,CAPH,EAJiB,CAajB;;IACAV,KAAK,CAACc,SAAN,CAAgB;MACd,IAAME,eAAe,GAAGZ,eAAe,KAAKS,SAA5C;;MACA,IAAIF,YAAY,KAAKK,eAArB,EAAsC;QACpC,IAAMC,WAAW,GAAGN,YAAY,GAAG,YAAH,GAAkB,cAAlD;QACA,IAAMO,OAAO,GAAGF,eAAe,GAAG,YAAH,GAAkB,cAAjD;QACAd,QAAQ,CACNM,aADM,EAEN,sCAA+BS,WAA/B,EAA0C,IAA1C,EAA0CF,MAA1C,CAA+CL,cAA/C,EAA6D,mBAA7D,EAA6DK,MAA7D,CAAiFG,OAAjF,EAAwF,IAAxF,IACE,mEAA4DD,WAA5D,EAAuE,MAAvE,EAAuEF,MAAvE,CAA8EG,OAA9E,EAAqF,oBAArF,CADF,GAEE,4FAFF,GAGE,sDALI,CAAR;MAOD;IACF,CAbD,EAaG,CAACP,YAAD,EAAeD,cAAf,EAA+BF,aAA/B,EAA8CJ,eAA9C,CAbH;EAcD,CAjCoE,CAmCrE;;;EACM,SAAyBJ,KAAK,CAACY,QAAN,CAAeN,YAAf,CAAzB;EAAA,IAACa,UAAU,QAAX;EAAA,IAAaC,QAAQ,QAArB;;EACA,SAAwCpB,KAAK,CAACY,QAAN,CAAe,KAAf,CAAxC;EAAA,IAACS,eAAe,QAAhB;EAAA,IAAkBC,kBAAkB,QAApC,CArC+D,CAuCrE;;;EACA,IAAMC,wBAAwB,GAAGF,eAAe,GAAGF,UAAH,GAAgBb,YAAhE;EAEA,IAAMkB,oBAAoB,GAAGxB,KAAK,CAACyB,WAAN,CAC3B,UAACC,QAAD,EAA0C;IACxCN,QAAQ,CAACM,QAAD,CAAR;IACAJ,kBAAkB,CAAC,IAAD,CAAlB;EACD,CAJ0B,EAK3B,CAACF,QAAD,EAAWE,kBAAX,CAL2B,CAA7B;;EAQA,IAAIX,YAAJ,EAAkB;IAChB,OAAO,CAACP,eAAD,EAAkBuB,eAAlB,CAAP;EACD,CAFD,MAEO;IACL,OAAO,CAACJ,wBAAD,EAA2BC,oBAA3B,CAAP;EACD;AACF;;AAED,SAASG,eAAT,GAAwB;EACtB,OAAO,KAAK,CAAZ;AACD","names":["React","isDevelopment","warnOnce","useControllable","controlledValue","handler","defaultValue","_a","componentName","changeHandler","controlledProp","isControlled","useState","undefined","useEffect","concat","isControlledNow","initialMode","modeNow","valueState","setValue","valueHasBeenSet","setValueHasBeenSet","currentUncontrolledValue","setUncontrolledValue","useCallback","newValue","defaultCallback"],"sourceRoot":"","sources":["../../../../../src/internal/hooks/use-controllable/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport * as React from 'react';\nimport { isDevelopment } from '../../is-development';\nimport { warnOnce } from '../../logging';\n\ninterface PropertyDescription {\n  componentName: string;\n  controlledProp: string;\n  changeHandler: string;\n}\n\n/**\n * This hook allows you to make a component that can be used both in controlled mode and uncontrolled mode.\n * Pass in your component's props, and then implement your component as if it was only controlled.\n * When calling onChange callbacks (or the equivalent for your property), you need to call both the callback returned by this function\n * as well as the callback provided in your component's props.\n *\n * A component determines its mode (either controlled or uncontrolled) on the first render and keeps it for its lifetime. The mode cannot\n * be switched later.\n *\n *\n * Example usage:\n * ```jsx\n * const [checked, setChecked] = useControllable(\n *     props,\n *     props.defaultEnabled ?? false,\n *     {\n *        componentName: 'MyCheckboxComponent',\n *        controlledProp: 'enabled',\n *        changeHandler: 'onCheckedStatusChange'\n *     }\n * )\n *\n * return\n *  <input\n *   type=\"checkbox\"\n *   checked={checked}\n *   onChange={event => {\n *    setChecked(event.target.checked);\n *    fireNonCancelableEvent(props.onCheckedStatusChange, { checked: event.target.checked })\n *   }} />\n * ```\n *\n * @param controlledValue value for the controlled mode\n * @param handler update handler for controlled mode\n * @param defaultValue initial value for uncontrolled mode\n * @param description property metadata\n */\nexport function useControllable<ValueType>(\n  controlledValue: ValueType,\n  handler: ((...args: any[]) => unknown) | undefined,\n  defaultValue: ValueType,\n  { componentName, changeHandler, controlledProp }: PropertyDescription\n) {\n  // The decision whether a component is controlled or uncontrolled is made on its first render and cannot be changed afterwards.\n  const isControlled = React.useState(controlledValue !== undefined)[0];\n\n  if (isDevelopment) {\n    // Print a warning if the component switches between controlled and uncontrolled mode.\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      if (isControlled && handler === undefined) {\n        warnOnce(\n          componentName,\n          `You provided a \\`${controlledProp}\\` prop without an \\`${changeHandler}\\` handler. This will render a non-interactive component.`\n        );\n      }\n    }, [handler, isControlled, componentName, changeHandler, controlledProp]);\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      const isControlledNow = controlledValue !== undefined;\n      if (isControlled !== isControlledNow) {\n        const initialMode = isControlled ? 'controlled' : 'uncontrolled';\n        const modeNow = isControlledNow ? 'controlled' : 'uncontrolled';\n        warnOnce(\n          componentName,\n          `A component tried to change ${initialMode} '${controlledProp}' property to be ${modeNow}. ` +\n            `This is not supported. Properties should not switch from ${initialMode} to ${modeNow} (or vice versa). ` +\n            `Decide between using a controlled or uncontrolled mode for the lifetime of the component. ` +\n            `More info: https://fb.me/react-controlled-components`\n        );\n      }\n    }, [isControlled, controlledProp, componentName, controlledValue]);\n  }\n\n  // This is the value that is used if the component is uncontrolled.\n  const [valueState, setValue] = React.useState(defaultValue);\n  const [valueHasBeenSet, setValueHasBeenSet] = React.useState(false);\n\n  // We track changes to the defaultValue\n  const currentUncontrolledValue = valueHasBeenSet ? valueState : defaultValue;\n\n  const setUncontrolledValue = React.useCallback(\n    (newValue: React.SetStateAction<ValueType>) => {\n      setValue(newValue);\n      setValueHasBeenSet(true);\n    },\n    [setValue, setValueHasBeenSet]\n  );\n\n  if (isControlled) {\n    return [controlledValue, defaultCallback] as const;\n  } else {\n    return [currentUncontrolledValue, setUncontrolledValue] as const;\n  }\n}\n\nfunction defaultCallback() {\n  return void 0;\n}\n"]},"metadata":{},"sourceType":"module"}