{"ast":null,"code":"var BREAKPOINT_MAPPING = [['xl', 1840], ['l', 1320], ['m', 1120], ['s', 912], ['xs', 688], ['xxs', 465], ['default', -1]];\nexport var mobileBreakpoint = BREAKPOINT_MAPPING.filter(function (b) {\n  return b[0] === 'xs';\n})[0][1];\nvar BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(function (_a) {\n  var bp = _a[0];\n  return bp;\n});\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\n\nexport function matchBreakpointMapping(subset, actual) {\n  var qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n\n  for (var _i = 0, qualifyingBreakpoints_1 = qualifyingBreakpoints; _i < qualifyingBreakpoints_1.length; _i++) {\n    var breakpoint = qualifyingBreakpoints_1[_i][0];\n    var breakpointValue = subset[breakpoint];\n\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\n\nexport function getMatchingBreakpoint(width, breakpointFilter) {\n  for (var _i = 0, BREAKPOINT_MAPPING_1 = BREAKPOINT_MAPPING; _i < BREAKPOINT_MAPPING_1.length; _i++) {\n    var _a = BREAKPOINT_MAPPING_1[_i],\n        breakpoint = _a[0],\n        breakpointWidth = _a[1];\n\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n\n  return 'default';\n}","map":{"version":3,"mappings":"AAIA,IAAMA,kBAAkB,GAA2B,CACjD,CAAC,IAAD,EAAO,IAAP,CADiD,EAEjD,CAAC,GAAD,EAAM,IAAN,CAFiD,EAGjD,CAAC,GAAD,EAAM,IAAN,CAHiD,EAIjD,CAAC,GAAD,EAAM,GAAN,CAJiD,EAKjD,CAAC,IAAD,EAAO,GAAP,CALiD,EAMjD,CAAC,KAAD,EAAQ,GAAR,CANiD,EAOjD,CAAC,SAAD,EAAY,CAAC,CAAb,CAPiD,CAAnD;AAUA,OAAO,IAAMC,gBAAgB,GAAGD,kBAAkB,CAACE,MAAnB,CAA0B,aAAC;EAAI,QAAC,CAAC,CAAD,CAAD,KAAS,IAAT;AAAa,CAA5C,EAA8C,CAA9C,EAAiD,CAAjD,CAAzB;AAEP,IAAMC,sBAAsB,GAAGH,kBAAkB,CAACI,GAAnB,CAAuB,UAACC,EAAD,EAAK;MAAHC,EAAE;EAAM;AAAE,CAAnC,CAA/B;AAEA;;;;AAGA,OAAM,SAAUC,sBAAV,CAAoCC,MAApC,EAA4EC,MAA5E,EAA8F;EAClG,IAAMC,qBAAqB,GAAGV,kBAAkB,CAACW,KAAnB,CAAyBR,sBAAsB,CAACS,OAAvB,CAA+BH,MAA/B,CAAzB,CAA9B;;EACA,KAA2B,2DAA3B,EAA2BI,mCAA3B,EAA2BA,IAA3B,EAAkD;IAAtC,cAAU,iCAAV;IACV,IAAMC,eAAe,GAAGN,MAAM,CAACO,UAAD,CAA9B;;IACA,IAAID,eAAe,KAAKE,SAAxB,EAAmC;MACjC,OAAOF,eAAP;IACD;EACF;;EACD,OAAO,IAAP;AACD;AAED;;;;AAGA,OAAM,SAAUG,qBAAV,CAAgCC,KAAhC,EAA+CC,gBAA/C,EAAuF;EAC3F,KAA4C,qDAA5C,EAA4CN,gCAA5C,EAA4CA,IAA5C,EAAgE;IAArD;IAAA,IAACE,UAAU,QAAX;IAAA,IAAaK,eAAe,QAA5B;;IACT,IAAIF,KAAK,GAAGE,eAAR,KAA4B,CAACD,gBAAD,IAAqBA,gBAAgB,CAACP,OAAjB,CAAyBG,UAAzB,MAAyC,CAAC,CAA3F,CAAJ,EAAmG;MACjG,OAAOA,UAAP;IACD;EACF;;EACD,OAAO,SAAP;AACD","names":["BREAKPOINT_MAPPING","mobileBreakpoint","filter","BREAKPOINTS_DESCENDING","map","_a","bp","matchBreakpointMapping","subset","actual","qualifyingBreakpoints","slice","indexOf","_i","breakpointValue","breakpoint","undefined","getMatchingBreakpoint","width","breakpointFilter","breakpointWidth"],"sourceRoot":"","sources":["../../../src/internal/breakpoints.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width: number, breakpointFilter?: readonly Breakpoint[]): Breakpoint {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n"]},"metadata":{},"sourceType":"module"}