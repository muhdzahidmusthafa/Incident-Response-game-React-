{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport balanced from 'balanced-match';\nimport { calculateOnce } from './calculate-once';\nexport function findUpUntil(node, callback) {\n  var current = node;\n\n  while (current && !callback(current)) {\n    current = current.parentElement; // If a component is used within an svg (i.e. as foreignObject), then it will\n    // have some ancestor nodes that are SVGElement. We want to skip those,\n    // as they have very different properties to HTLMElements.\n\n    while (current && !(current instanceof HTMLElement)) {\n      current = current.parentElement;\n    }\n  }\n\n  return current;\n}\n/**\n * Returns whether the browser supports CSS position sticky.\n * In our list of supported browsers, only returns false for IE11.\n */\n\nexport function supportsStickyPosition() {\n  var _a, _b, _c;\n\n  if (typeof window === 'undefined') {\n    // render no-sticky UI on server-side\n    return false;\n  }\n\n  return (_c = (_b = (_a = window.CSS) === null || _a === void 0 ? void 0 : _a.supports) === null || _b === void 0 ? void 0 : _b.call(_a, 'position', 'sticky')) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns whether `position: fixed` can be relative to transformed parents or\n * whether it's always relative to the viewport. Returns `true` on all browsers\n * except IE.\n */\n\nvar supportsContainingBlockPositioning = calculateOnce(function () {\n  var parent = document.createElement('div');\n  parent.style.transform = 'translateY(5px)';\n  document.body.appendChild(parent);\n  var child = document.createElement('div');\n  child.style.position = 'fixed';\n  child.style.top = '0';\n  parent.appendChild(child);\n  var result = parent.getBoundingClientRect().top === child.getBoundingClientRect().top;\n  document.body.removeChild(parent);\n  return result;\n});\n/**\n * Returns an element that is used to position the given element.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\n */\n\nexport function getContainingBlock(startElement) {\n  if (!startElement.parentElement) {\n    return null;\n  }\n\n  return supportsContainingBlockPositioning() ? findUpUntil(startElement.parentElement, function (element) {\n    var computedStyle = getComputedStyle(element);\n    return !!computedStyle.transform && computedStyle.transform !== 'none' || !!computedStyle.perspective && computedStyle.perspective !== 'none';\n  }) : null;\n}\nvar cssVariableExpression = /--.+?\\s*,\\s*(.+)/;\n/**\n * Parses a CSS color value that might contain CSS Custom Properties\n * and returns a value that will be understood by the browser, no matter of support level.\n * If the browser support CSS Custom Properties, the value will be return as is. Otherwise,\n * the fallback value will be extracted and returned instead.\n */\n\nexport function parseCssVariable(value) {\n  var _a, _b, _c;\n\n  if ((_c = (_b = (_a = window.CSS) === null || _a === void 0 ? void 0 : _a.supports) === null || _b === void 0 ? void 0 : _b.call(_a, 'color', 'var(--dummy, #000)')) !== null && _c !== void 0 ? _c : false) {\n    return value;\n  }\n\n  var varIndex = value.lastIndexOf('var(');\n\n  if (varIndex === -1) {\n    return value;\n  }\n\n  var expr = balanced('(', ')', value.substr(varIndex));\n\n  if (!expr) {\n    return value;\n  }\n\n  var match = expr.body.match(cssVariableExpression);\n  return match ? match[1] : value;\n}\n/**\n * Checks whether the given node is a parent of the other descendant node.\n * This utility is helpful when the parent might be an SVG element,\n * which doesn't have a native `contains` implementation on some browsers like IE11.\n * @param parent Parent node\n * @param descendant Node that is checked to be a descendant of the parent node\n */\n\nexport function nodeContains(parent, descendant) {\n  if (!parent || !descendant) {\n    return false;\n  } // Use the native `contains` method when available\n\n\n  if (parent.contains && descendant.nodeType === Node.ELEMENT_NODE) {\n    return parent === descendant || parent.contains(descendant);\n  } // Fall back to a simple upwards tree traversal\n\n\n  var upperNode = descendant;\n\n  while (upperNode && parent !== upperNode) {\n    upperNode = upperNode.parentNode;\n  }\n\n  return upperNode === parent;\n}\n/**\n * Checks whether the given node is a descendant of a container.\n * @param container Container node\n * @param node Node that is checked to be a descendant of the container\n */\n\nexport function containsOrEqual(container, node) {\n  if (container === null) {\n    return false;\n  }\n\n  return container === node || container.contains(node);\n}","map":{"version":3,"mappings":"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","names":["balanced","calculateOnce","findUpUntil","node","callback","current","parentElement","HTMLElement","supportsStickyPosition","window","CSS","_a","supports","_b","_c","supportsContainingBlockPositioning","parent","document","createElement","style","transform","body","appendChild","child","position","top","result","getBoundingClientRect","removeChild","getContainingBlock","startElement","computedStyle","getComputedStyle","element","perspective","cssVariableExpression","parseCssVariable","value","varIndex","lastIndexOf","expr","substr","match","nodeContains","descendant","contains","nodeType","Node","ELEMENT_NODE","upperNode","parentNode","containsOrEqual","container"],"sourceRoot":"","sources":["../../../../src/internal/utils/dom.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport balanced from 'balanced-match';\nimport { calculateOnce } from './calculate-once';\n\nexport function findUpUntil(node: HTMLElement, callback: (element: HTMLElement) => boolean): HTMLElement | null {\n  let current: HTMLElement | null = node;\n  while (current && !callback(current)) {\n    current = current.parentElement;\n    // If a component is used within an svg (i.e. as foreignObject), then it will\n    // have some ancestor nodes that are SVGElement. We want to skip those,\n    // as they have very different properties to HTLMElements.\n    while (current && !(current instanceof HTMLElement)) {\n      current = (current as Element).parentElement;\n    }\n  }\n  return current;\n}\n\n/**\n * Returns whether the browser supports CSS position sticky.\n * In our list of supported browsers, only returns false for IE11.\n */\nexport function supportsStickyPosition() {\n  if (typeof window === 'undefined') {\n    // render no-sticky UI on server-side\n    return false;\n  }\n  return window.CSS?.supports?.('position', 'sticky') ?? false;\n}\n\n/**\n * Returns whether `position: fixed` can be relative to transformed parents or\n * whether it's always relative to the viewport. Returns `true` on all browsers\n * except IE.\n */\nconst supportsContainingBlockPositioning = calculateOnce(() => {\n  const parent = document.createElement('div');\n  parent.style.transform = 'translateY(5px)';\n  document.body.appendChild(parent);\n\n  const child = document.createElement('div');\n  child.style.position = 'fixed';\n  child.style.top = '0';\n  parent.appendChild(child);\n\n  const result = parent.getBoundingClientRect().top === child.getBoundingClientRect().top;\n  document.body.removeChild(parent);\n  return result;\n});\n\n/**\n * Returns an element that is used to position the given element.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\n */\nexport function getContainingBlock(startElement: HTMLElement): HTMLElement | null {\n  if (!startElement.parentElement) {\n    return null;\n  }\n\n  return supportsContainingBlockPositioning()\n    ? (findUpUntil(startElement.parentElement, element => {\n        const computedStyle = getComputedStyle(element);\n        return (\n          (!!computedStyle.transform && computedStyle.transform !== 'none') ||\n          (!!computedStyle.perspective && computedStyle.perspective !== 'none')\n        );\n      }) as HTMLElement)\n    : null;\n}\n\nconst cssVariableExpression = /--.+?\\s*,\\s*(.+)/;\n\n/**\n * Parses a CSS color value that might contain CSS Custom Properties\n * and returns a value that will be understood by the browser, no matter of support level.\n * If the browser support CSS Custom Properties, the value will be return as is. Otherwise,\n * the fallback value will be extracted and returned instead.\n */\nexport function parseCssVariable(value: string) {\n  if (window.CSS?.supports?.('color', 'var(--dummy, #000)') ?? false) {\n    return value;\n  }\n\n  const varIndex = value.lastIndexOf('var(');\n  if (varIndex === -1) {\n    return value;\n  }\n\n  const expr = balanced('(', ')', value.substr(varIndex));\n  if (!expr) {\n    return value;\n  }\n\n  const match = expr.body.match(cssVariableExpression);\n  return match ? match[1] : value;\n}\n\n/**\n * Checks whether the given node is a parent of the other descendant node.\n * This utility is helpful when the parent might be an SVG element,\n * which doesn't have a native `contains` implementation on some browsers like IE11.\n * @param parent Parent node\n * @param descendant Node that is checked to be a descendant of the parent node\n */\nexport function nodeContains(parent: Node | null, descendant: Node | null) {\n  if (!parent || !descendant) {\n    return false;\n  }\n\n  // Use the native `contains` method when available\n  if (parent.contains && descendant.nodeType === Node.ELEMENT_NODE) {\n    return parent === descendant || parent.contains(descendant);\n  }\n\n  // Fall back to a simple upwards tree traversal\n  let upperNode: Node | null = descendant;\n  while (upperNode && parent !== upperNode) {\n    upperNode = upperNode.parentNode;\n  }\n  return upperNode === parent;\n}\n\n/**\n * Checks whether the given node is a descendant of a container.\n * @param container Container node\n * @param node Node that is checked to be a descendant of the container\n */\nexport function containsOrEqual(container: Node | null, node: Node): boolean {\n  if (container === null) {\n    return false;\n  }\n  return container === node || container.contains(node);\n}\n"]},"metadata":{},"sourceType":"module"}