{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction useRect(nodeRef, initialRect) {\n  if (initialRect === void 0) {\n    initialRect = {\n      width: 0,\n      height: 0\n    };\n  }\n\n  var _React$useState = React.useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var _React$useReducer = React.useReducer(rectReducer, initialRect),\n      rect = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n\n      var _rect = element.getBoundingClientRect();\n\n      dispatch({\n        rect: _rect\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    if (!element) {\n      return;\n    }\n\n    var observer = observeRect(element, function (rect) {\n      dispatch({\n        rect: rect\n      });\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\n\nfunction rectReducer(state, action) {\n  var rect = action.rect;\n\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect;\n  }\n\n  return state;\n}\n\nvar defaultEstimateSize = function defaultEstimateSize() {\n  return 50;\n};\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\n\nvar defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n  var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n  return el[key];\n};\n\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.start - range.overscan, 0);\n  var end = Math.min(range.end + range.overscan, range.size - 1);\n  var arr = [];\n\n  for (var i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nfunction useVirtual(_ref) {\n  var _measurements;\n\n  var _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0 : _ref$size,\n      _ref$estimateSize = _ref.estimateSize,\n      estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n      _ref$overscan = _ref.overscan,\n      overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,\n      _ref$paddingStart = _ref.paddingStart,\n      paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n      _ref$paddingEnd = _ref.paddingEnd,\n      paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n      parentRef = _ref.parentRef,\n      horizontal = _ref.horizontal,\n      scrollToFn = _ref.scrollToFn,\n      useObserver = _ref.useObserver,\n      initialRect = _ref.initialRect,\n      onScrollElement = _ref.onScrollElement,\n      scrollOffsetFn = _ref.scrollOffsetFn,\n      _ref$keyExtractor = _ref.keyExtractor,\n      keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,\n      _ref$measureSize = _ref.measureSize,\n      measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,\n      _ref$rangeExtractor = _ref.rangeExtractor,\n      rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;\n  var sizeKey = horizontal ? 'width' : 'height';\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n  var latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: []\n  });\n\n  var _React$useState = React.useState(0),\n      scrollOffset = _React$useState[0],\n      setScrollOffset = _React$useState[1];\n\n  latestRef.current.scrollOffset = scrollOffset;\n  var useMeasureParent = useObserver || useRect;\n\n  var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n      outerSize = _useMeasureParent[sizeKey];\n\n  latestRef.current.outerSize = outerSize;\n  var defaultScrollToFn = React.useCallback(function (offset) {\n    if (parentRef.current) {\n      parentRef.current[scrollKey] = offset;\n    }\n  }, [parentRef, scrollKey]);\n  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n  scrollToFn = React.useCallback(function (offset) {\n    resolvedScrollToFn(offset, defaultScrollToFn);\n  }, [defaultScrollToFn, resolvedScrollToFn]);\n\n  var _React$useState2 = React.useState({}),\n      measuredCache = _React$useState2[0],\n      setMeasuredCache = _React$useState2[1];\n\n  var measure = React.useCallback(function () {\n    return setMeasuredCache({});\n  }, []);\n  var pendingMeasuredCacheIndexesRef = React.useRef([]);\n  var measurements = React.useMemo(function () {\n    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n    pendingMeasuredCacheIndexesRef.current = [];\n    var measurements = latestRef.current.measurements.slice(0, min);\n\n    for (var i = min; i < size; i++) {\n      var key = keyExtractor(i);\n      var measuredSize = measuredCache[key];\n\n      var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n\n      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n\n      var _end = _start + _size;\n\n      measurements[i] = {\n        index: i,\n        start: _start,\n        size: _size,\n        end: _end,\n        key: key\n      };\n    }\n\n    return measurements;\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;\n  latestRef.current.measurements = measurements;\n  latestRef.current.totalSize = totalSize;\n  var element = onScrollElement ? onScrollElement.current : parentRef.current;\n  var scrollOffsetFnRef = React.useRef(scrollOffsetFn);\n  scrollOffsetFnRef.current = scrollOffsetFn;\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      setScrollOffset(0);\n      return;\n    }\n\n    var onScroll = function onScroll(event) {\n      var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];\n      setScrollOffset(offset);\n    };\n\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey]);\n\n  var _calculateRange = calculateRange(latestRef.current),\n      start = _calculateRange.start,\n      end = _calculateRange.end;\n\n  var indexes = React.useMemo(function () {\n    return rangeExtractor({\n      start: start,\n      end: end,\n      overscan: overscan,\n      size: measurements.length\n    });\n  }, [start, end, overscan, measurements.length, rangeExtractor]);\n  var measureSizeRef = React.useRef(measureSize);\n  measureSizeRef.current = measureSize;\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n\n    var _loop = function _loop(k, len) {\n      var i = indexes[k];\n      var measurement = measurements[i];\n\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          if (el) {\n            var measuredSize = measureSizeRef.current(el, horizontal);\n\n            if (measuredSize !== item.size) {\n              var _scrollOffset = latestRef.current.scrollOffset;\n\n              if (item.start < _scrollOffset) {\n                defaultScrollToFn(_scrollOffset + (measuredSize - item.size));\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i);\n              setMeasuredCache(function (old) {\n                var _extends2;\n\n                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n              });\n            }\n          }\n        }\n      });\n\n      virtualItems.push(item);\n    };\n\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      _loop(k);\n    }\n\n    return virtualItems;\n  }, [indexes, defaultScrollToFn, horizontal, measurements]);\n  var mountedRef = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      setMeasuredCache({});\n    }\n\n    mountedRef.current = true;\n  }, [estimateSize]);\n  var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        _ref2$align = _ref2.align,\n        align = _ref2$align === void 0 ? 'start' : _ref2$align;\n\n    var _latestRef$current = latestRef.current,\n        scrollOffset = _latestRef$current.scrollOffset,\n        outerSize = _latestRef$current.outerSize;\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start';\n      } else if (toOffset >= scrollOffset + outerSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n\n    if (align === 'start') {\n      scrollToFn(toOffset);\n    } else if (align === 'end') {\n      scrollToFn(toOffset - outerSize);\n    } else if (align === 'center') {\n      scrollToFn(toOffset - outerSize / 2);\n    }\n  }, [scrollToFn]);\n  var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        _ref3$align = _ref3.align,\n        align = _ref3$align === void 0 ? 'auto' : _ref3$align,\n        rest = _objectWithoutPropertiesLoose(_ref3, [\"align\"]);\n\n    var _latestRef$current2 = latestRef.current,\n        measurements = _latestRef$current2.measurements,\n        scrollOffset = _latestRef$current2.scrollOffset,\n        outerSize = _latestRef$current2.outerSize;\n    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n\n    if (!measurement) {\n      return;\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffset + outerSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n\n    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(toOffset, _extends({\n      align: align\n    }, rest));\n  }, [scrollToOffset, size]);\n  var scrollToIndex = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    } // We do a double request here because of\n    // dynamic sizes which can cause offset shift\n    // and end up in the wrong spot. Unfortunately,\n    // we can't know about those dynamic sizes until\n    // we try and render them. So double down!\n\n\n    tryScrollToIndex.apply(void 0, args);\n    requestAnimationFrame(function () {\n      tryScrollToIndex.apply(void 0, args);\n    });\n  }, [tryScrollToIndex]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex,\n    measure: measure\n  };\n}\n\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref4) {\n  var measurements = _ref4.measurements,\n      outerSize = _ref4.outerSize,\n      scrollOffset = _ref4.scrollOffset;\n  var size = measurements.length - 1;\n\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n\n  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n  var end = start;\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexport { defaultRangeExtractor, useVirtual };","map":{"version":3,"mappings":"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","names":["props","rectChanged","a","b","some","prop","observedNodes","Map","run","changedStates","newRect","node","getBoundingClientRect","state","rect","rafId","window","observeRect","cb","observe","wasEmpty","undefined","hasRectChanged","callbacks","unobserve","index","length","size","cancelAnimationFrame","React","useLayoutEffect","useEffect","useRect","nodeRef","initialRect","width","height","useState","current","element","setElement","useReducer","rectReducer","dispatch","initialRectSet","useRef","useIsomorphicLayoutEffect","observer","action","defaultEstimateSize","defaultKeyExtractor","defaultMeasureSize","el","horizontal","key","defaultRangeExtractor","start","Math","max","range","overscan","end","min","arr","i","push","useVirtual","_ref","estimateSize","paddingStart","paddingEnd","parentRef","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","keyExtractor","measureSize","rangeExtractor","sizeKey","scrollKey","latestRef","scrollOffset","measurements","setScrollOffset","useMeasureParent","outerSize","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","measuredCache","setMeasuredCache","measure","pendingMeasuredCacheIndexesRef","useMemo","slice","measuredSize","totalSize","scrollOffsetFnRef","onScroll","event","addEventListener","capture","passive","removeEventListener","calculateRange","indexes","measureSizeRef","virtualItems","k","len","measurement","item","measureRef","old","_loop","mountedRef","scrollToOffset","toOffset","align","tryScrollToIndex","rest","scrollToIndex","args","arguments","requestAnimationFrame","findNearestBinarySearch","low","high","getCurrentValue","value","middle","currentValue","getOffset"],"sources":["../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useIsomorphicLayoutEffect.js","../src/useRect.js","../src/index.js"],"sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\nimport observeRect from '@reach/observe-rect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(\n  nodeRef,\n  initialRect = { width: 0, height: 0 }\n) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, initialRect)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect()\n      dispatch({ rect })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect })\n    })\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n","import React from 'react'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  initialRect,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n\n  const [scrollOffset, setScrollOffset] = React.useState(0)\n  latestRef.current.scrollOffset = scrollOffset\n\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef, initialRect)\n\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || paddingStart) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setScrollOffset(0)\n\n      return\n    }\n\n    const onScroll = event => {\n      const offset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      setScrollOffset(offset)\n    }\n\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey])\n\n  const { start, end } = calculateRange(latestRef.current)\n\n  const indexes = React.useMemo(\n    () =>\n      rangeExtractor({\n        start,\n        end,\n        overscan,\n        size: measurements.length,\n      }),\n    [start, end, overscan, measurements.length, rangeExtractor]\n  )\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [indexes, defaultScrollToFn, horizontal, measurements])\n\n  const mountedRef = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  return { start, end }\n}\n"]},"metadata":{},"sourceType":"module"}