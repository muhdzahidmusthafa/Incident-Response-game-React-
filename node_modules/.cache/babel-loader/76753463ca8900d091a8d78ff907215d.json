{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useLayoutEffect, useCallback } from 'react';\nimport { useResizeObserver } from '../internal/hooks/container-queries/use-resize-observer';\nimport stickyScrolling, { calculateScrollingOffset, scrollUpBy } from './sticky-scrolling';\nimport { useMobile } from '../internal/hooks/use-mobile';\n\nfunction syncSizes(from, to) {\n  var fromCells = Array.prototype.slice.apply(from.children);\n  var toCells = Array.prototype.slice.apply(to.children);\n\n  for (var i = 0; i < fromCells.length; i++) {\n    var width = fromCells[i].style.width; // use auto if it is set by resizable columns or real size otherwise\n\n    if (width !== 'auto') {\n      width = \"\".concat(fromCells[i].offsetWidth, \"px\");\n    }\n\n    toCells[i].style.width = width;\n  }\n}\n\nexport var useStickyHeader = function (tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) {\n  var isMobile = useMobile(); // Sync the sizes of the column header copies in the sticky header with the originals\n\n  var syncColumnHeaderWidths = useCallback(function () {\n    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {\n      syncSizes(theadRef.current, secondaryTheadRef.current); // Using the tableRef offsetWidth instead of the theadRef because in VR\n      // the tableRef adds extra padding to the table and by default the theadRef will have a width\n      // without the padding and will make the sticky header width incorrect.\n\n      secondaryTableRef.current.style.width = \"\".concat(tableRef.current.offsetWidth, \"px\");\n      tableWrapperRef.current.style.marginTop = \"-\".concat(theadRef.current.offsetHeight, \"px\");\n    }\n  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);\n  useLayoutEffect(function () {\n    syncColumnHeaderWidths(); // Content is not going to be layed out until the next frame in angular,\n    // so we need to sync the column headers again.\n\n    setTimeout(function () {\n      return syncColumnHeaderWidths();\n    }, 0);\n    var secondaryTable = secondaryTableRef.current;\n    var primaryTable = tableWrapperRef.current;\n    return function () {\n      if (secondaryTable) {\n        secondaryTable.style.width = '';\n      }\n\n      if (primaryTable) {\n        primaryTable.style.marginTop = '';\n      }\n    };\n  });\n  useResizeObserver(theadRef, syncColumnHeaderWidths);\n\n  var scrollToTop = function () {\n    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {\n      var scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);\n\n      if (scrollDist > 0) {\n        scrollUpBy(scrollDist, tableWrapperRef.current);\n      }\n    }\n  };\n\n  var scrollToItem = stickyScrolling(tableWrapperRef, secondaryTheadRef).scrollToItem;\n\n  var scrollToRow = function (itemNode) {\n    if (!isMobile) {\n      scrollToItem(itemNode);\n    }\n  };\n\n  return {\n    scrollToRow: scrollToRow,\n    scrollToTop: scrollToTop\n  };\n};","map":{"version":3,"mappings":"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","names":["useLayoutEffect","useCallback","useResizeObserver","stickyScrolling","calculateScrollingOffset","scrollUpBy","useMobile","syncSizes","from","to","fromCells","Array","prototype","slice","apply","children","toCells","i","length","width","style","offsetWidth","useStickyHeader","tableRef","theadRef","secondaryTheadRef","secondaryTableRef","tableWrapperRef","isMobile","syncColumnHeaderWidths","current","marginTop","offsetHeight","setTimeout","secondaryTable","primaryTable","scrollToTop","scrollDist","scrollToItem","scrollToRow","itemNode"],"sourceRoot":"","sources":["../../../src/table/use-sticky-header.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useLayoutEffect, RefObject, useCallback } from 'react';\nimport { useResizeObserver } from '../internal/hooks/container-queries/use-resize-observer';\nimport stickyScrolling, { calculateScrollingOffset, scrollUpBy } from './sticky-scrolling';\nimport { useMobile } from '../internal/hooks/use-mobile';\n\nfunction syncSizes(from: HTMLElement, to: HTMLElement) {\n  const fromCells = Array.prototype.slice.apply(from.children);\n  const toCells = Array.prototype.slice.apply(to.children);\n  for (let i = 0; i < fromCells.length; i++) {\n    let width = fromCells[i].style.width;\n    // use auto if it is set by resizable columns or real size otherwise\n    if (width !== 'auto') {\n      width = `${fromCells[i].offsetWidth}px`;\n    }\n    toCells[i].style.width = width;\n  }\n}\n\nexport const useStickyHeader = (\n  tableRef: RefObject<HTMLElement>,\n  theadRef: RefObject<HTMLElement>,\n  secondaryTheadRef: RefObject<HTMLElement>,\n  secondaryTableRef: RefObject<HTMLElement>,\n  tableWrapperRef: RefObject<HTMLElement>\n) => {\n  const isMobile = useMobile();\n  // Sync the sizes of the column header copies in the sticky header with the originals\n  const syncColumnHeaderWidths = useCallback(() => {\n    if (\n      tableRef.current &&\n      theadRef.current &&\n      secondaryTheadRef.current &&\n      secondaryTableRef.current &&\n      tableWrapperRef.current\n    ) {\n      syncSizes(theadRef.current, secondaryTheadRef.current);\n\n      // Using the tableRef offsetWidth instead of the theadRef because in VR\n      // the tableRef adds extra padding to the table and by default the theadRef will have a width\n      // without the padding and will make the sticky header width incorrect.\n      secondaryTableRef.current.style.width = `${tableRef.current.offsetWidth}px`;\n\n      tableWrapperRef.current.style.marginTop = `-${theadRef.current.offsetHeight}px`;\n    }\n  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);\n  useLayoutEffect(() => {\n    syncColumnHeaderWidths();\n    // Content is not going to be layed out until the next frame in angular,\n    // so we need to sync the column headers again.\n    setTimeout(() => syncColumnHeaderWidths(), 0);\n    const secondaryTable = secondaryTableRef.current;\n    const primaryTable = tableWrapperRef.current;\n    return () => {\n      if (secondaryTable) {\n        secondaryTable.style.width = '';\n      }\n      if (primaryTable) {\n        primaryTable.style.marginTop = '';\n      }\n    };\n  });\n  useResizeObserver(theadRef, syncColumnHeaderWidths);\n  const scrollToTop = () => {\n    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {\n      const scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);\n      if (scrollDist > 0) {\n        scrollUpBy(scrollDist, tableWrapperRef.current);\n      }\n    }\n  };\n  const { scrollToItem } = stickyScrolling(tableWrapperRef, secondaryTheadRef);\n  const scrollToRow = (itemNode: HTMLElement | null) => {\n    if (!isMobile) {\n      scrollToItem(itemNode);\n    }\n  };\n  return { scrollToRow, scrollToTop };\n};\n"]},"metadata":{},"sourceType":"module"}