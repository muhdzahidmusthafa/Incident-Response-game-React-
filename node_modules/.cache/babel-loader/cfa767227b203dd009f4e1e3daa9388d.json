{"ast":null,"code":"import { __assign } from \"tslib\";\nexport var chartLegendMap = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed'\n}; // Starting from the given index, find the first x value in the x domain that has bar data attached to it.\n\nexport var nextValidDomainIndex = function (nextGroupIndex, barGroups, direction) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  var index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n\n    index += direction; // Loop back to the beginning if necessary\n\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n\n  return 0;\n};\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\n\nexport function findNavigableSeries(series) {\n  var navigableSeries = [];\n  var navigableBarSeriesIndex = -1;\n  series.forEach(function (internalSeries) {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return {\n    navigableSeries: navigableSeries,\n    navigableBarSeriesIndex: navigableBarSeriesIndex\n  };\n}\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\n\nexport var matchesX = function (x1, x2) {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n\n  return x1 === x2;\n};\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\n\nexport function calculateOffsetMaps(data) {\n  return data.reduce(function (acc, curr, idx) {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({\n        positiveOffsets: {},\n        negativeOffsets: {}\n      });\n    }\n\n    var lastMap = acc[idx];\n    var map = lastMap ? {\n      positiveOffsets: __assign({}, lastMap.positiveOffsets),\n      negativeOffsets: __assign({}, lastMap.negativeOffsets)\n    } : {\n      positiveOffsets: {},\n      negativeOffsets: {}\n    };\n    curr.forEach(function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var key = getKeyValue(x);\n\n      if (y < 0) {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    }); // Ignore last value for map but still run it for logging\n\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, []);\n}\n/** Returns string or number value for ChartDataTypes key */\n\nexport var getKeyValue = function (key) {\n  return key instanceof Date ? key.getTime() : key;\n};\nexport function isYThreshold(series) {\n  return series.type === 'threshold' && 'y' in series;\n}\nexport function isXThreshold(series) {\n  return series.type === 'threshold' && 'x' in series;\n}\nexport function isDataSeries(series) {\n  return series.type === 'line' || series.type === 'bar';\n}","map":{"version":3,"mappings":"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","names":["chartLegendMap","line","bar","threshold","nextValidDomainIndex","nextGroupIndex","barGroups","direction","index","length","isValid","hasData","findNavigableSeries","series","navigableSeries","navigableBarSeriesIndex","forEach","internalSeries","type","push","matchesX","x1","x2","Date","getTime","calculateOffsetMaps","data","reduce","acc","curr","idx","positiveOffsets","negativeOffsets","lastMap","map","_a","x","y","key","getKeyValue","lastValue","isYThreshold","isXThreshold","isDataSeries"],"sourceRoot":"","sources":["../../../src/mixed-line-bar-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartSeriesMarkerType } from '../internal/components/chart-series-marker';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ScaledBarGroup } from './make-scaled-bar-groups';\n\nexport const chartLegendMap: Record<string, ChartSeriesMarkerType> = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed',\n};\n\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = <T>(nextGroupIndex: number, barGroups: ScaledBarGroup<T>[], direction = 1) => {\n  let index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries<T extends ChartDataTypes>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const navigableSeries: Array<MixedLineBarChartProps.ChartSeries<T>> = [];\n  let navigableBarSeriesIndex = -1;\n\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return { navigableSeries, navigableBarSeriesIndex };\n}\n\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = <T>(x1: T, x2: T) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n\nexport type OffsetMap = Record<string | number, number>;\n\nexport interface StackedOffsets {\n  positiveOffsets: OffsetMap;\n  negativeOffsets: OffsetMap;\n}\n\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\nexport function calculateOffsetMaps(\n  data: Array<readonly MixedLineBarChartProps.Datum<ChartDataTypes>[]>\n): StackedOffsets[] {\n  return data.reduce((acc, curr, idx) => {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({ positiveOffsets: {}, negativeOffsets: {} });\n    }\n    const lastMap = acc[idx];\n    const map: StackedOffsets = lastMap\n      ? { positiveOffsets: { ...lastMap.positiveOffsets }, negativeOffsets: { ...lastMap.negativeOffsets } }\n      : { positiveOffsets: {}, negativeOffsets: {} };\n\n    curr.forEach(({ x, y }) => {\n      const key = getKeyValue(x);\n      if (y < 0) {\n        const lastValue = lastMap?.negativeOffsets[key] || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        const lastValue = lastMap?.positiveOffsets[key] || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    });\n\n    // Ignore last value for map but still run it for logging\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, [] as StackedOffsets[]);\n}\n\n/** Returns string or number value for ChartDataTypes key */\nexport const getKeyValue = (key: ChartDataTypes) => (key instanceof Date ? key.getTime() : key);\n\nexport function isYThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.YThresholdSeries {\n  return series.type === 'threshold' && 'y' in series;\n}\n\nexport function isXThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.XThresholdSeries<T> {\n  return series.type === 'threshold' && 'x' in series;\n}\n\nexport function isDataSeries<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.DataSeries<T> {\n  return series.type === 'line' || series.type === 'bar';\n}\n"]},"metadata":{},"sourceType":"module"}