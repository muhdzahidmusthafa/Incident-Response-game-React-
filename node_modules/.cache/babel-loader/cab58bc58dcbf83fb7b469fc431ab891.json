{"ast":null,"code":"import _classCallCheck from\"/Users/firozahmed/PycharmProjects/incident-response/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/firozahmed/PycharmProjects/incident-response/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{setText,setChoices}from'../actions/textActions';import{addToLog,setCurrentNodeKey}from'../actions/gameLogActions';import{setVariables}from'../actions/variablesActions';import{checkIfGameOver,checkIfGameFail,checkIfGameEnded}from'./helpers';// Import Redux store from index.js where it is created.\n// Store can be accessed with .getState() and can .dispatch() actions.\nimport{store}from'../index';import constants from'../globals/constants';var GameManager=/*#__PURE__*/function(){function GameManager(){_classCallCheck(this,GameManager);}_createClass(GameManager,null,[{key:\"checkIfModuleLoaded\",value:// Check if the JSON data for a module has been loaded into the\n// Redux store - return true or false.\nfunction checkIfModuleLoaded(moduleName){var startingKey='';if(moduleName===constants.MODULE_INCIDENT){startingKey=constants.INCIDENT_STARTING_KEY;}return startingKey in store.getState().data.textData;}// Call this method to load text and choices into the Redux store based\n// on the current node key.\n},{key:\"loadGame\",value:function loadGame(){this.loadText();this.loadChoices();}// This method loads text from the JSON text data into the Redux store\n// based on the current node key.\n},{key:\"loadText\",value:function loadText(){var key=store.getState().game.currentNodeKey;var text='';if(checkIfGameFail(key)){text=constants.FAIL_TEXT;}else if(checkIfGameEnded(key)){text=constants.END_TEXT;}else{text=store.getState().data.textData[key];text=text.split(constants.LINE_BREAK_SEPARATOR);}store.dispatch(setText(text));}// This method loads choices from the JSON choices data into the Redux\n// store based on the current node key.\n},{key:\"loadChoices\",value:function loadChoices(){var stringTest;var choices=[];var currentNodeKey=store.getState().game.currentNodeKey;if(checkIfGameFail(currentNodeKey)){choices.push({key:constants.FAIL_KEY,text:constants.END_CHOICE,colorClass:'color-choice'});}else if(checkIfGameEnded(currentNodeKey)){choices.push({key:constants.END_KEY,text:constants.END_CHOICE,colorClass:'color-choice'});}else{var choicesData=store.getState().data.choicesData;// TODO: Redesign to not have to search through all data\nfor(var i in choicesData){stringTest=choicesData[i].KEY;if(stringTest.substring(0,12)===currentNodeKey){if(this.checkChoice(i)){var choiceData=choicesData[i];var choice={key:choiceData.KEY,text:choiceData.text};choices.push(choice);}}}}store.dispatch(setChoices(choices));}},{key:\"checkChoice\",value:function checkChoice(choiceKey){var choice=store.getState().data.choicesData[choiceKey];// Is this choice available to the player based on their past decisions?\nif(choice.additionalVariableCostA_Key){var condition1=this.checkPlayerVariables(choice.additionalVariableCostA_Key,choice.additionalVariableCostA_Equivalence,choice.additionalVariableCostA_Value);if(choice.additionalVariableCostB_Key){// There are two additional variable costs\nvar condition2=this.checkPlayerVariables(choice.additionalVariableCostB_Key,choice.additionalVariableCostB_Equivalence,choice.additionalVariableCostB_Value);if(choice.additionalVariableCost_Operator==='&&'){if(condition1&&condition2){return true;}else{return false;}}else if(choice.additionalVariableCost_Operator==='||'){if(condition1||condition2){return true;}else{return false;}}else{// Then there's an error\nreturn false;}}else{// There's only one additional variable cost\nif(condition1){return true;}else{return false;}}}else{// There are no costs for this choice, so return true\nreturn true;}}// This method checks for additional variables in the playerVariables object.\n// It checks on the player's past decisions based on a reference (the variable cost key),\n// the equivalence (logical operator), and value to be checked for. It then\n// returns a boolean (true or false) result.\n},{key:\"checkPlayerVariables\",value:function checkPlayerVariables(reference,equivalence,value){var playerVariables=store.getState().variables.playerVariables;var defaultValue=0;// Search for reference and value pair in playerVariables object.\n// If found, checks for whether it's >, <, etc. to the value provided.\n// If it doesn't pass the test to the value, or if not found, it returns false.\n// Empty string, null, undefined, and 0 are all falsy\nif(!equivalence){// Just search for whether the additional variable is present - value doesn't matter\nreturn reference in playerVariables;}else if(equivalence==='='){// Check for presence of variable and value\nreturn playerVariables[reference]===value;}else if(equivalence==='!='&&!value){// Checks if the additional variable is present at all and returns false if present, true if not\n// - opposite of first check in this series. e.g. if !(01JennethDead), then returns true.\nreturn!(reference in playerVariables);}else if(equivalence==='!='&&value){if(reference in playerVariables&&playerVariables[reference]!==value){return true;}else if(value!==defaultValue){// Variable not found, so assume default value (0)\nreturn true;}else{return false;}}else if(equivalence==='<'){if(reference in playerVariables&&playerVariables[reference]<value){return true;}else if(value<defaultValue){// Variable not found, so assume default value (0)\nreturn true;}else{return false;}}else if(equivalence==='<='){if(reference in playerVariables&&playerVariables[reference]<=value){return true;}else if(value<=defaultValue){// Variable not found, so assume default value (0)\nreturn true;}else{return false;}}else if(equivalence==='>'){if(reference in playerVariables&&playerVariables[reference]>value){return true;}else if(value>defaultValue){// Variable not found, so assume default value (0)\nreturn true;}else{return false;}}else if(equivalence==='>='){if(reference in playerVariables&&playerVariables[reference]>=value){return true;}else if(value>=defaultValue){// Variable not found, so assume default value (0)\nreturn true;}else{return false;}}else{// In case anything goes wrong, defaults to returning false\nconsole.log('%c checkPlayerVariables() error ','color:white; background:red;');return false;}}// Write story node decision to gameLog.\n// Dispatch action using Redux.\n},{key:\"writeToGameLog\",value:function writeToGameLog(textNodeKey,choiceNodeKey){store.dispatch(addToLog(textNodeKey,choiceNodeKey));}},{key:\"makeDecision\",value:function makeDecision(choiceNodeKey){var currentNodeKey=store.getState().game.currentNodeKey;this.writeToGameLog(currentNodeKey,choiceNodeKey);var choice=store.getState().data.choicesData[choiceNodeKey];// ------------------Randomize destinations------------------\nvar dieRollDestinationA;var dieRollDestinationB;var dieRollDestinationC;var dieRollDestinationD;// Empty string, null, undefined, and 0 are all falsy.\nif(!choice.destinationA_percentage){// There's only one destination, go to destinationA.\nthis.loadStoryNode(choice.destinationA);}else if(!choice.destinationC_percentage){// There's no third destination, so it's between destinationA and destinationB.\n// Can't just check second destination percentage, because there may or may not be a third.\ndieRollDestinationA=this.rollDie()*choice.destinationA_percentage;dieRollDestinationB=this.rollDie()*choice.destinationB_percentage;if(dieRollDestinationA>dieRollDestinationB){// go to destinationA\nthis.loadStoryNode(choice.destinationA);}else{// go to destinationB\nthis.loadStoryNode(choice.destinationB);}}else if(!choice.destinationD_percentage){// There's no fourth destination, so it's between destinationA, destinationB, and destinationC\ndieRollDestinationA=this.rollDie()*choice.destinationA_percentage;dieRollDestinationB=this.rollDie()*choice.destinationB_percentage;dieRollDestinationC=this.rollDie()*choice.destinationC_percentage;if(dieRollDestinationA>dieRollDestinationB&&dieRollDestinationA>dieRollDestinationC){// go to destinationA\nthis.loadStoryNode(choice.destinationA);}else if(dieRollDestinationB>dieRollDestinationC){// go to destinationB\nthis.loadStoryNode(choice.destinationB);}else{// go to destinationC\nthis.loadStoryNode(choice.destinationC);}}else{// There are four destinations\ndieRollDestinationA=this.rollDie()*choice.destinationA_percentage;dieRollDestinationB=this.rollDie()*choice.destinationB_percentage;dieRollDestinationC=this.rollDie()*choice.destinationC_percentage;dieRollDestinationD=this.rollDie()*choice.destinationD_percentage;if(dieRollDestinationA>dieRollDestinationB&&dieRollDestinationA>dieRollDestinationC&&dieRollDestinationA>dieRollDestinationD){// go to destinationA\nthis.loadStoryNode(choice.destinationA);}else if(dieRollDestinationB>dieRollDestinationC&&dieRollDestinationB>dieRollDestinationD){// go to destinationB\nthis.loadStoryNode(choice.destinationB);}else if(dieRollDestinationC>dieRollDestinationD){// go to destinationC\nthis.loadStoryNode(choice.destinationC);}else{// go to destinationD\nthis.loadStoryNode(choice.destinationD);}}}// Helper method to generate random number between 1-100\n},{key:\"rollDie\",value:function rollDie(){return Math.floor(Math.random()*100)+1;}// Write player variables to object in Redux store.\n// These additional variables keep track of specific player decisions\n// that can be evaluated later in the story.\n// Expects to receive variables as an array of objects (can be only one object):\n// [\n//   {\n//     key: additionalVariableBoostA_Key,\n//     value: additionalVariableBoostA_Value\n//   },\n//   {\n//     key: additionalVariableBoostB_Key,\n//     value: additionalVariableBoostB_Value\n//   }\n// ]\n},{key:\"writeToPlayerVariables\",value:function writeToPlayerVariables(variablesArray){// Get current playerVariables from the Redux store and copy it (since it is read only).\nvar playerVariables=Object.assign({},store.getState().variables.playerVariables);variablesArray.forEach(function(variable){// Check if the variable already exists in playerVariables.\n// If it does, update it.\nif(variable.key in playerVariables){var original=playerVariables[variable.key];playerVariables[variable.key]=original+variable.value;}else{// If variable doesn't exist, add it to playerVariables.\nplayerVariables[variable.key]=variable.value;}});// Dispatch updated playerVariables object to Redux store.\n// Object should retain same structure in which it was received.\nstore.dispatch(setVariables(playerVariables));}// Load the next story node based on the destination key sent as an argument.\n},{key:\"loadStoryNode\",value:function loadStoryNode(destination){// Check for either fail or game end conditions.\nif(checkIfGameOver(destination)){this.updateCurrentNode(destination);}else{// Link node keys are prefixed with an X, so check for it here.\n// If it's not a link node, it's a normal node, so just set it as the new current node.\nif(!this.checkKeyForLinkNode(destination)){this.updateCurrentNode(destination);}else{// Link node logic - loop through as many link nodes as necessary.\n// Link nodes are used to test for past decisions through the playerVariables object.\nvar newDestination=this.processLinkNode(destination);while(this.checkKeyForLinkNode(newDestination)){newDestination=this.processLinkNode(newDestination);}this.updateCurrentNode(newDestination);}}this.loadGame();}// Link node keys are prefixed with an X, so check for it here.\n},{key:\"checkKeyForLinkNode\",value:function checkKeyForLinkNode(nodeKey){return nodeKey.substring(0,1)===constants.LINK_NODE_PREFIX;}// Dispatch an action to update the currentNodeKey in the Redux store.\n},{key:\"updateCurrentNode\",value:function updateCurrentNode(destination){store.dispatch(setCurrentNodeKey(destination));}// This method is used to examine a link node and determine how to proceed based\n// on whether or not the player has met certain conditions based on past decisions.\n// The method loads all link nodes that match the given destination key, then checks\n// the requirements of each link node based on the playerVariables object in the\n// Redux store. The method returns a new destination (which may be another link node).\n},{key:\"processLinkNode\",value:function processLinkNode(destination){var loadedLinkNodes=[];var stringTest;var test1=false;var test2=false;var test3=false;// Load the link nodes matching the key pattern into an array.\n// There can be multiple link nodes for a particular key in order to create\n// complex condition chains, such as: IF 01MarryJeneth, go to destination 1,\n// ELSE, go to destination 2. Keys in the same pattern match: \n// XAA001AJ001BD01, XAA001AJ001BD02 - They are the same except for the last\n// two digits, so test for the same first twelve characters.\nvar linkNodesData=store.getState().data.linkNodesData;// TODO: Redesign to not have to search through all data\nfor(var i in linkNodesData){stringTest=linkNodesData[i].KEY;if(stringTest.substring(0,13)===destination){loadedLinkNodes.push(linkNodesData[i]);}}// TODO: Review logic\n// In this loop, we check for past decisions (playerVariables) based on\n// requirements in the link node. This can't be a forEach because we need\n// to be able to terminate early and return a destination.\nfor(var _i=0;_i<loadedLinkNodes.length;_i++){var linkNode=loadedLinkNodes[_i];if(linkNode.variable1!=='ELSE'){// Empty string, null, undefined, and 0 are all falsy.\nif(!linkNode.variable2){// If there's not second variable, then just check for variable1\nif(this.checkPlayerVariables(linkNode.variable1,linkNode.equivalence1,linkNode.value1)){test1=true;}}else if(!linkNode.variable3){// If there's no third variable, then check for variable1 and variable2\nif(this.checkPlayerVariables(linkNode.variable1,linkNode.equivalence1,linkNode.value1)){test1=true;}if(this.checkPlayerVariables(linkNode.variable2,linkNode.equivalence2,linkNode.value2)){test2=true;}}else{// Check for variable1, variable2, and variable3\nif(this.checkPlayerVariables(linkNode.variable1,linkNode.equivalence1,linkNode.value1)){test1=true;}if(this.checkPlayerVariables(linkNode.variable2,linkNode.equivalence2,linkNode.value2)){test2=true;}if(this.checkPlayerVariables(linkNode.variable3,linkNode.equivalence3,linkNode.value3)){test3=true;}}// -------------------------------------------------------------------------\n// Test the individual variables in combination\n// -------------------------------------------------------------------------\n// Empty string, null, undefined, and 0 are all falsy.\nif(!linkNode.operator1){// If there are no logical operators like && or ||, then this is a single test.\nif(test1){// Go to destination\nreturn this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='&&'&&!linkNode.operator2){if(test1&&test2){return this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='||'&&!linkNode.operator2){if(test1||test2){return this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='&&'&&linkNode.operator2==='&&'){if(test1&&test2&&test3){return this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='||'&&linkNode.operator2==='&&'){if((test1||test2)&&test3){return this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='&&'&&linkNode.operator2==='||'){if(test1&&test2||test3){return this.getRandomLinkNodeDestination(linkNode);}}else if(linkNode.operator1==='||'&&linkNode.operator2==='||'){if(test1||test2||test3){return this.getRandomLinkNodeDestination(linkNode);}}}else{// variable1 is ELSE and just go to destination.\nreturn this.getRandomLinkNodeDestination(linkNode);}};// If nothing is found, an error has occurred.\nconsole.log('%c processLinkNode() error','color:white; background:red;');return null;}// Return a destination based on the link node's percentages.\n},{key:\"getRandomLinkNodeDestination\",value:function getRandomLinkNodeDestination(linkNode){var dieRollA;var dieRollB;var dieRollC;var dieRollD;// Empty string '', null, undefined, and 0 are all falsy.\nif(!linkNode.destinationA_percentage){// There's only one destination, so go to destinationA.\nreturn linkNode.destinationA;}else if(!linkNode.destinationC_percentage){// There's no third destination, so it's between destinationA and destinationB\ndieRollA=this.rollDie()*linkNode.destinationA_percentage;dieRollB=this.rollDie()*linkNode.destinationB_percentage;if(dieRollA>dieRollB){return linkNode.destinationA;}else{return linkNode.destinationB;}}else if(!linkNode.destinationD_percentage){// There's no fourth destination, so it's between destinationA, destinationB, and destinationC\ndieRollA=this.rollDie()*linkNode.destinationA_percentage;dieRollB=this.rollDie()*linkNode.destinationB_percentage;dieRollC=this.rollDie()*linkNode.destinationC_percentage;if(dieRollA>dieRollB&&dieRollA>dieRollC){return linkNode.destinationA;}else if(dieRollB>dieRollC){return linkNode.destinationB;}else{return linkNode.destinationC;}}else{// There are four destinations\ndieRollA=this.rollDie()*linkNode.destinationA_percentage;dieRollB=this.rollDie()*linkNode.destinationB_percentage;dieRollC=this.rollDie()*linkNode.destinationC_percentage;dieRollD=this.rollDie()*linkNode.destinationD_percentage;if(dieRollA>dieRollB&&dieRollA>dieRollC&&dieRollA>dieRollD){return linkNode.destinationA;}else if(dieRollB>dieRollC&&dieRollB>dieRollD){return linkNode.destinationB;}else if(dieRollC>dieRollD){return linkNode.destinationC;}else{return linkNode.destinationD;}}}}]);return GameManager;}();export{GameManager as default};","map":{"version":3,"names":["setText","setChoices","addToLog","setCurrentNodeKey","setVariables","checkIfGameOver","checkIfGameFail","checkIfGameEnded","store","constants","GameManager","moduleName","startingKey","MODULE_INCIDENT","INCIDENT_STARTING_KEY","getState","data","textData","loadText","loadChoices","key","game","currentNodeKey","text","FAIL_TEXT","END_TEXT","split","LINE_BREAK_SEPARATOR","dispatch","stringTest","choices","push","FAIL_KEY","END_CHOICE","colorClass","END_KEY","choicesData","i","KEY","substring","checkChoice","choiceData","choice","choiceKey","additionalVariableCostA_Key","condition1","checkPlayerVariables","additionalVariableCostA_Equivalence","additionalVariableCostA_Value","additionalVariableCostB_Key","condition2","additionalVariableCostB_Equivalence","additionalVariableCostB_Value","additionalVariableCost_Operator","reference","equivalence","value","playerVariables","variables","defaultValue","console","log","textNodeKey","choiceNodeKey","writeToGameLog","dieRollDestinationA","dieRollDestinationB","dieRollDestinationC","dieRollDestinationD","destinationA_percentage","loadStoryNode","destinationA","destinationC_percentage","rollDie","destinationB_percentage","destinationB","destinationD_percentage","destinationC","destinationD","Math","floor","random","variablesArray","Object","assign","forEach","variable","original","destination","updateCurrentNode","checkKeyForLinkNode","newDestination","processLinkNode","loadGame","nodeKey","LINK_NODE_PREFIX","loadedLinkNodes","test1","test2","test3","linkNodesData","length","linkNode","variable1","variable2","equivalence1","value1","variable3","equivalence2","value2","equivalence3","value3","operator1","getRandomLinkNodeDestination","operator2","dieRollA","dieRollB","dieRollC","dieRollD"],"sources":["/Users/firozahmed/PycharmProjects/incident-response/src/mechanics/GameManager.js"],"sourcesContent":["import { setText, setChoices } from '../actions/textActions';\r\nimport { addToLog, setCurrentNodeKey } from '../actions/gameLogActions';\r\nimport { setVariables } from '../actions/variablesActions';\r\nimport { checkIfGameOver, checkIfGameFail, checkIfGameEnded } from './helpers';\r\n\r\n// Import Redux store from index.js where it is created.\r\n// Store can be accessed with .getState() and can .dispatch() actions.\r\nimport { store } from '../index';\r\n\r\nimport constants from '../globals/constants';\r\n\r\n\r\nexport default class GameManager {\r\n\r\n  // Check if the JSON data for a module has been loaded into the\r\n  // Redux store - return true or false.\r\n  static checkIfModuleLoaded(moduleName) {\r\n    let startingKey = '';\r\n\r\n    if (moduleName === constants.MODULE_INCIDENT) {\r\n      startingKey = constants.INCIDENT_STARTING_KEY;\r\n    }\r\n    \r\n    return (startingKey in store.getState().data.textData);\r\n  }\r\n  \r\n  // Call this method to load text and choices into the Redux store based\r\n  // on the current node key.\r\n  static loadGame() {\r\n    this.loadText();\r\n    this.loadChoices();\r\n  }\r\n\r\n  // This method loads text from the JSON text data into the Redux store\r\n  // based on the current node key.\r\n  static loadText() {\r\n    const key = store.getState().game.currentNodeKey;\r\n    let text = '';\r\n\r\n    if (checkIfGameFail(key)) {\r\n      text = constants.FAIL_TEXT;\r\n    } else if (checkIfGameEnded(key)) {\r\n      text = constants.END_TEXT;\r\n    } else {\r\n      text = store.getState().data.textData[key];\r\n      text = text.split(constants.LINE_BREAK_SEPARATOR);\r\n    }\r\n\r\n    store.dispatch(setText(text));\r\n  }\r\n\r\n  // This method loads choices from the JSON choices data into the Redux\r\n  // store based on the current node key.\r\n  static loadChoices() {\r\n    let stringTest;\r\n    let choices = [];\r\n\r\n    const currentNodeKey = store.getState().game.currentNodeKey;\r\n\r\n    if (checkIfGameFail(currentNodeKey)) {\r\n      choices.push({\r\n        key: constants.FAIL_KEY,\r\n        text: constants.END_CHOICE,\r\n        colorClass: 'color-choice'\r\n      });\r\n      \r\n    } else if (checkIfGameEnded(currentNodeKey)){\r\n      choices.push({\r\n        key: constants.END_KEY,\r\n        text: constants.END_CHOICE,\r\n        colorClass: 'color-choice'\r\n      });\r\n\r\n    } else {\r\n      const choicesData = store.getState().data.choicesData;\r\n\r\n      // TODO: Redesign to not have to search through all data\r\n      for (const i in choicesData) {\r\n        stringTest = choicesData[i].KEY;\r\n\r\n        if (stringTest.substring(0, 12) === currentNodeKey) {\r\n\r\n          if (this.checkChoice(i)) {\r\n            const choiceData = choicesData[i];\r\n\r\n            let choice = {\r\n              key: choiceData.KEY,\r\n              text: choiceData.text\r\n              \r\n            };\r\n\r\n            choices.push(choice);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    store.dispatch(setChoices(choices));\r\n  }\r\n\r\n  static checkChoice(choiceKey) {\r\n    const choice = store.getState().data.choicesData[choiceKey];\r\n    // Is this choice available to the player based on their past decisions?\r\n     if (choice.additionalVariableCostA_Key) {\r\n      const condition1 = this.checkPlayerVariables(\r\n        choice.additionalVariableCostA_Key,\r\n        choice.additionalVariableCostA_Equivalence,\r\n        choice.additionalVariableCostA_Value);\r\n\r\n      if (choice.additionalVariableCostB_Key) {\r\n        // There are two additional variable costs\r\n\r\n        const condition2 = this.checkPlayerVariables(\r\n          choice.additionalVariableCostB_Key,\r\n          choice.additionalVariableCostB_Equivalence,\r\n          choice.additionalVariableCostB_Value);\r\n\r\n        if (choice.additionalVariableCost_Operator === '&&') {\r\n          if (condition1 && condition2) {\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        } else if (choice.additionalVariableCost_Operator === '||') {\r\n          if (condition1 || condition2) {\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          // Then there's an error\r\n          return false;\r\n        }\r\n      } else {\r\n        // There's only one additional variable cost\r\n        if (condition1) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // There are no costs for this choice, so return true\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // This method checks for additional variables in the playerVariables object.\r\n  // It checks on the player's past decisions based on a reference (the variable cost key),\r\n  // the equivalence (logical operator), and value to be checked for. It then\r\n  // returns a boolean (true or false) result.\r\n  static checkPlayerVariables(reference, equivalence, value) {\r\n    const playerVariables = store.getState().variables.playerVariables;\r\n    const defaultValue = 0;\r\n\r\n    // Search for reference and value pair in playerVariables object.\r\n    // If found, checks for whether it's >, <, etc. to the value provided.\r\n    // If it doesn't pass the test to the value, or if not found, it returns false.\r\n    \r\n    // Empty string, null, undefined, and 0 are all falsy\r\n    if (!equivalence) {\r\n      // Just search for whether the additional variable is present - value doesn't matter\r\n      return (reference in playerVariables);\r\n    } else if (equivalence === '=') {\r\n      // Check for presence of variable and value\r\n      return (playerVariables[reference] === value);\r\n    } else if (equivalence === '!=' && (!value)) {\r\n      // Checks if the additional variable is present at all and returns false if present, true if not\r\n      // - opposite of first check in this series. e.g. if !(01JennethDead), then returns true.\r\n      return !(reference in playerVariables);\r\n    } else if (equivalence === '!=' && (value)) {\r\n      if (reference in playerVariables && playerVariables[reference] !== value) {\r\n        return true;\r\n      } else if (value !== defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === '<') {\r\n      if (reference in playerVariables && playerVariables[reference] < value) {\r\n        return true;\r\n      } else if (value < defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === '<=') {\r\n      if (reference in playerVariables && playerVariables[reference] <= value) {\r\n        return true;\r\n      } else if (value <= defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === '>') {\r\n      if (reference in playerVariables && playerVariables[reference] > value) {\r\n        return true;\r\n      } else if (value > defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else if (equivalence === '>=') {\r\n      if (reference in playerVariables && playerVariables[reference] >= value) {\r\n        return true;\r\n      } else if (value >= defaultValue) {\r\n        // Variable not found, so assume default value (0)\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      // In case anything goes wrong, defaults to returning false\r\n      console.log('%c checkPlayerVariables() error ', 'color:white; background:red;');\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Write story node decision to gameLog.\r\n  // Dispatch action using Redux.\r\n  static writeToGameLog(textNodeKey, choiceNodeKey) {\r\n    store.dispatch(addToLog(textNodeKey, choiceNodeKey));\r\n  }\r\n\r\n  static makeDecision(choiceNodeKey) {\r\n    const currentNodeKey = store.getState().game.currentNodeKey;\r\n    this.writeToGameLog(currentNodeKey, choiceNodeKey);\r\n\r\n    const choice = store.getState().data.choicesData[choiceNodeKey];\r\n\r\n    \r\n    // ------------------Randomize destinations------------------\r\n    let dieRollDestinationA;\r\n    let dieRollDestinationB;\r\n    let dieRollDestinationC;\r\n    let dieRollDestinationD;\r\n\r\n    // Empty string, null, undefined, and 0 are all falsy.\r\n    if (!choice.destinationA_percentage) {\r\n      // There's only one destination, go to destinationA.\r\n      this.loadStoryNode(choice.destinationA);\r\n    } else if (!choice.destinationC_percentage) {\r\n      // There's no third destination, so it's between destinationA and destinationB.\r\n      // Can't just check second destination percentage, because there may or may not be a third.\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n\r\n      if (dieRollDestinationA > dieRollDestinationB) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else {\r\n        // go to destinationB\r\n        this.loadStoryNode(choice.destinationB);\r\n      }\r\n    } else if (!choice.destinationD_percentage) {\r\n      // There's no fourth destination, so it's between destinationA, destinationB, and destinationC\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\r\n\r\n      if (dieRollDestinationA > dieRollDestinationB && dieRollDestinationA > dieRollDestinationC) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else if (dieRollDestinationB > dieRollDestinationC) {\r\n        // go to destinationB\r\n\r\n        this.loadStoryNode(choice.destinationB);\r\n      } else {\r\n        // go to destinationC\r\n        this.loadStoryNode(choice.destinationC);\r\n      }\r\n    } else {\r\n      // There are four destinations\r\n      dieRollDestinationA = this.rollDie() * choice.destinationA_percentage;\r\n      dieRollDestinationB = this.rollDie() * choice.destinationB_percentage;\r\n      dieRollDestinationC = this.rollDie() * choice.destinationC_percentage;\r\n      dieRollDestinationD = this.rollDie() * choice.destinationD_percentage;\r\n\r\n      if (dieRollDestinationA > dieRollDestinationB && dieRollDestinationA > dieRollDestinationC && dieRollDestinationA > dieRollDestinationD) {\r\n        // go to destinationA\r\n        this.loadStoryNode(choice.destinationA);\r\n      } else if (dieRollDestinationB > dieRollDestinationC && dieRollDestinationB > dieRollDestinationD) {\r\n        // go to destinationB\r\n        this.loadStoryNode(choice.destinationB);\r\n      } else if (dieRollDestinationC > dieRollDestinationD) {\r\n        // go to destinationC\r\n        this.loadStoryNode(choice.destinationC);\r\n      } else {\r\n        // go to destinationD\r\n        this.loadStoryNode(choice.destinationD);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helper method to generate random number between 1-100\r\n  static rollDie() {\r\n    return (Math.floor(Math.random() * 100) + 1);\r\n  }\r\n\r\n  // Write player variables to object in Redux store.\r\n  // These additional variables keep track of specific player decisions\r\n  // that can be evaluated later in the story.\r\n  // Expects to receive variables as an array of objects (can be only one object):\r\n  // [\r\n  //   {\r\n  //     key: additionalVariableBoostA_Key,\r\n  //     value: additionalVariableBoostA_Value\r\n  //   },\r\n  //   {\r\n  //     key: additionalVariableBoostB_Key,\r\n  //     value: additionalVariableBoostB_Value\r\n  //   }\r\n  // ]\r\n  static writeToPlayerVariables(variablesArray) {\r\n    // Get current playerVariables from the Redux store and copy it (since it is read only).\r\n    const playerVariables = Object.assign({}, store.getState().variables.playerVariables);\r\n\r\n    variablesArray.forEach(variable => {\r\n    \r\n      // Check if the variable already exists in playerVariables.\r\n      // If it does, update it.\r\n      if (variable.key in playerVariables) {\r\n        const original = playerVariables[variable.key];\r\n        playerVariables[variable.key] = original + variable.value;\r\n      } else {\r\n        // If variable doesn't exist, add it to playerVariables.\r\n        playerVariables[variable.key] = variable.value;\r\n      }\r\n    });\r\n\r\n    // Dispatch updated playerVariables object to Redux store.\r\n    // Object should retain same structure in which it was received.\r\n    store.dispatch(setVariables(playerVariables));\r\n  }\r\n\r\n  // Load the next story node based on the destination key sent as an argument.\r\n  static loadStoryNode(destination) {\r\n\r\n    // Check for either fail or game end conditions.\r\n    if (checkIfGameOver(destination)) {\r\n      this.updateCurrentNode(destination);\r\n    } else {\r\n      // Link node keys are prefixed with an X, so check for it here.\r\n      // If it's not a link node, it's a normal node, so just set it as the new current node.\r\n      if (!this.checkKeyForLinkNode(destination)) {\r\n        this.updateCurrentNode(destination);\r\n\r\n      } else {\r\n        // Link node logic - loop through as many link nodes as necessary.\r\n        // Link nodes are used to test for past decisions through the playerVariables object.\r\n        let newDestination = this.processLinkNode(destination);\r\n\r\n        while (this.checkKeyForLinkNode(newDestination)) {\r\n          newDestination = this.processLinkNode(newDestination);\r\n        }\r\n\r\n        this.updateCurrentNode(newDestination);\r\n      }\r\n    }\r\n\r\n    this.loadGame();\r\n  }\r\n\r\n  // Link node keys are prefixed with an X, so check for it here.\r\n  static checkKeyForLinkNode(nodeKey) {\r\n    return (nodeKey.substring(0, 1) === constants.LINK_NODE_PREFIX);\r\n  }\r\n\r\n  // Dispatch an action to update the currentNodeKey in the Redux store.\r\n  static updateCurrentNode(destination) {\r\n    store.dispatch(setCurrentNodeKey(destination));    \r\n  }\r\n  \r\n  // This method is used to examine a link node and determine how to proceed based\r\n  // on whether or not the player has met certain conditions based on past decisions.\r\n  // The method loads all link nodes that match the given destination key, then checks\r\n  // the requirements of each link node based on the playerVariables object in the\r\n  // Redux store. The method returns a new destination (which may be another link node).\r\n  static processLinkNode(destination) {\r\n    let loadedLinkNodes = [];\r\n    let stringTest;\r\n    let test1 = false;\r\n    let test2 = false;\r\n    let test3 = false;\r\n\r\n    // Load the link nodes matching the key pattern into an array.\r\n    // There can be multiple link nodes for a particular key in order to create\r\n    // complex condition chains, such as: IF 01MarryJeneth, go to destination 1,\r\n    // ELSE, go to destination 2. Keys in the same pattern match: \r\n    // XAA001AJ001BD01, XAA001AJ001BD02 - They are the same except for the last\r\n    // two digits, so test for the same first twelve characters.\r\n    const linkNodesData = store.getState().data.linkNodesData;\r\n\r\n    // TODO: Redesign to not have to search through all data\r\n    for (const i in linkNodesData) {\r\n      stringTest = linkNodesData[i].KEY;\r\n      if (stringTest.substring(0, 13) === destination) {\r\n        loadedLinkNodes.push(linkNodesData[i]);\r\n      }\r\n    }\r\n\r\n    // TODO: Review logic\r\n    // In this loop, we check for past decisions (playerVariables) based on\r\n    // requirements in the link node. This can't be a forEach because we need\r\n    // to be able to terminate early and return a destination.\r\n    for (let i = 0; i < loadedLinkNodes.length; i++) {\r\n      const linkNode = loadedLinkNodes[i];\r\n\r\n      if (linkNode.variable1 !== 'ELSE') {\r\n        // Empty string, null, undefined, and 0 are all falsy.\r\n        if (!linkNode.variable2) {\r\n          // If there's not second variable, then just check for variable1\r\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\r\n            test1 = true;\r\n          }\r\n        } else if (!linkNode.variable3) {\r\n          // If there's no third variable, then check for variable1 and variable2\r\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\r\n            test1 = true;\r\n          }\r\n\r\n          if (this.checkPlayerVariables(linkNode.variable2, linkNode.equivalence2, linkNode.value2)) {\r\n            test2 = true;\r\n          }\r\n        } else {\r\n          // Check for variable1, variable2, and variable3\r\n          if (this.checkPlayerVariables(linkNode.variable1, linkNode.equivalence1, linkNode.value1)) {\r\n            test1 = true;\r\n          }\r\n\r\n          if (this.checkPlayerVariables(linkNode.variable2, linkNode.equivalence2, linkNode.value2)) {\r\n            test2 = true;\r\n          }\r\n\r\n          if (this.checkPlayerVariables(linkNode.variable3, linkNode.equivalence3, linkNode.value3)) {\r\n            test3 = true;\r\n          }\r\n        }\r\n        // -------------------------------------------------------------------------\r\n        // Test the individual variables in combination\r\n        // -------------------------------------------------------------------------\r\n        // Empty string, null, undefined, and 0 are all falsy.\r\n        if (!linkNode.operator1) {\r\n          // If there are no logical operators like && or ||, then this is a single test.\r\n          if (test1) {\r\n            // Go to destination\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '&&' && !linkNode.operator2) {\r\n          if (test1 && test2) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '||' && !linkNode.operator2) {\r\n          if (test1 || test2) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '&&' && linkNode.operator2 === '&&') {\r\n          if (test1 && test2 && test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '||' && linkNode.operator2 === '&&') {\r\n          if ((test1 || test2) && test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '&&' && linkNode.operator2 === '||') {\r\n          if ((test1 && test2) || test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        } else if (linkNode.operator1 === '||' && linkNode.operator2 === '||') {\r\n          if (test1 || test2 || test3) {\r\n            return this.getRandomLinkNodeDestination(linkNode);\r\n          }\r\n        }\r\n      } else {\r\n        // variable1 is ELSE and just go to destination.\r\n        return this.getRandomLinkNodeDestination(linkNode);\r\n      }\r\n    };\r\n    // If nothing is found, an error has occurred.\r\n    console.log('%c processLinkNode() error', 'color:white; background:red;');\r\n    return null;\r\n  }\r\n\r\n  // Return a destination based on the link node's percentages.\r\n  static getRandomLinkNodeDestination(linkNode) {\r\n    let dieRollA;\r\n    let dieRollB;\r\n    let dieRollC;\r\n    let dieRollD;\r\n\r\n    // Empty string '', null, undefined, and 0 are all falsy.\r\n    if (!linkNode.destinationA_percentage) {\r\n      // There's only one destination, so go to destinationA.\r\n      return linkNode.destinationA;\r\n\r\n    } else if (!linkNode.destinationC_percentage) {\r\n      // There's no third destination, so it's between destinationA and destinationB\r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n\r\n      if (dieRollA > dieRollB) {\r\n        return linkNode.destinationA;\r\n\r\n      } else {\r\n        return linkNode.destinationB;\r\n      }\r\n\r\n    } else if (!linkNode.destinationD_percentage) {\r\n      // There's no fourth destination, so it's between destinationA, destinationB, and destinationC\r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\r\n\r\n      if (dieRollA > dieRollB && dieRollA > dieRollC) {\r\n        return linkNode.destinationA;\r\n\r\n      } else if (dieRollB > dieRollC) {\r\n        return linkNode.destinationB;\r\n\r\n      } else {\r\n        return linkNode.destinationC;\r\n      }\r\n\r\n    } else {\r\n      // There are four destinations\r\n      dieRollA = this.rollDie() * linkNode.destinationA_percentage;\r\n      dieRollB = this.rollDie() * linkNode.destinationB_percentage;\r\n      dieRollC = this.rollDie() * linkNode.destinationC_percentage;\r\n      dieRollD = this.rollDie() * linkNode.destinationD_percentage;\r\n\r\n      if (dieRollA > dieRollB && dieRollA > dieRollC && dieRollA > dieRollD) {\r\n        return linkNode.destinationA;\r\n\r\n      } else if (dieRollB > dieRollC && dieRollB > dieRollD) {\r\n        return linkNode.destinationB;\r\n\r\n      } else if (dieRollC > dieRollD) {\r\n        return linkNode.destinationC;\r\n\r\n      } else {\r\n        return linkNode.destinationD;\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}