{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\nexport var onPaginationClick = function (headerBarRef, direction) {\n  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {\n    return;\n  }\n\n  var element = headerBarRef.current; // Scroll each paginated section by 75% of what is already visible\n\n  var paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  if (direction === 1) {\n    smoothScroll(element, Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth));\n  }\n\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\nexport var hasHorizontalOverflow = function (headerBar, leftOverflowButton) {\n  var offsetWidth = headerBar.offsetWidth,\n      scrollWidth = headerBar.scrollWidth; // Need to account for pagination button width when deciding if there would be overflow without them\n\n  var paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\nexport var hasLeftOverflow = function (headerBar) {\n  return headerBar.scrollLeft > 0;\n};\nexport var hasRightOverflow = function (headerBar) {\n  var offsetWidth = headerBar.offsetWidth,\n      scrollLeft = headerBar.scrollLeft,\n      scrollWidth = headerBar.scrollWidth; // scrollLeft can be a decimal value on systems using display scaling\n\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\nexport var scrollIntoView = function (tabHeader, headerBar, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  }\n\n  if (!tabHeader || !headerBar) {\n    return;\n  } // Extra left and right margin to always make the focus ring visible\n\n\n  var margin = 2;\n  var updatedLeftScroll = headerBar.scrollLeft; // Anchor tab to left of scroll parent\n\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin); // Anchor tab to right of scroll parent\n\n  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin);\n\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,YAAP,MAAyB,iBAAzB;AAEA,OAAO,IAAMC,iBAAiB,GAAG,UAACC,YAAD,EAAkDC,SAAlD,EAAmE;EAClG,IAAI,EAACD,YAAY,SAAZ,gBAAY,WAAZ,GAAY,MAAZ,eAAY,CAAEE,OAAf,CAAJ,EAA4B;IAC1B;EACD;;EACD,IAAMC,OAAO,GAAGH,YAAY,CAACE,OAA7B,CAJkG,CAMlG;;EACA,IAAME,oBAAoB,GAAGC,IAAI,CAACC,IAAL,CAAUH,OAAO,CAACI,WAAR,GAAsB,IAAhC,CAA7B;;EAEA,IAAIN,SAAS,KAAK,CAAlB,EAAqB;IACnBH,YAAY,CACVK,OADU,EAEVE,IAAI,CAACG,GAAL,CAASL,OAAO,CAACM,UAAR,GAAqBL,oBAA9B,EAAoDD,OAAO,CAACO,WAAR,GAAsBP,OAAO,CAACQ,WAAlF,CAFU,CAAZ;EAID;;EACD,IAAIV,SAAS,KAAK,CAAC,CAAnB,EAAsB;IACpBH,YAAY,CAACK,OAAD,EAAUE,IAAI,CAACO,GAAL,CAAST,OAAO,CAACM,UAAR,GAAqBL,oBAA9B,EAAoD,CAApD,CAAV,CAAZ;EACD;AACF,CAlBM;AAoBP,OAAO,IAAMS,qBAAqB,GAAG,UACnCC,SADmC,EAEnCC,kBAFmC,EAEa;EAExC,eAAW,GAAkBD,SAAS,YAAtC;EAAA,IAAaJ,WAAW,GAAKI,SAAS,YAAtC,CAFwC,CAIhD;;EACA,IAAME,sBAAsB,GAAGD,kBAAkB,CAACb,OAAnB,IAA8B,IAAIa,kBAAkB,CAACb,OAAnB,CAA2BS,WAA5F;EACA,OAAOK,sBAAsB,GAAGN,WAAW,GAAGC,WAAW,GAAGK,sBAA/B,GAAwDN,WAAW,GAAGC,WAAnG;AACD,CATM;AAWP,OAAO,IAAMM,eAAe,GAAG,UAACH,SAAD,EAAuB;EACpD,OAAOA,SAAS,CAACL,UAAV,GAAuB,CAA9B;AACD,CAFM;AAIP,OAAO,IAAMS,gBAAgB,GAAG,UAACJ,SAAD,EAAuB;EAC7C,eAAW,GAA8BA,SAAS,YAAlD;EAAA,IAAaL,UAAU,GAAkBK,SAAS,WAAlD;EAAA,IAAyBJ,WAAW,GAAKI,SAAS,YAAlD,CAD6C,CAErD;;EACA,OAAOT,IAAI,CAACC,IAAL,CAAUG,UAAV,IAAwBC,WAAW,GAAGC,WAA7C;AACD,CAJM;AAMP,OAAO,IAAMQ,cAAc,GAAG,UAACC,SAAD,EAAyBN,SAAzB,EAAiDO,MAAjD,EAA8D;EAAb;IAAAA;EAAa;;EAC1F,IAAI,CAACD,SAAD,IAAc,CAACN,SAAnB,EAA8B;IAC5B;EACD,CAHyF,CAI1F;;;EACA,IAAMQ,MAAM,GAAG,CAAf;EACA,IAAIC,iBAAiB,GAAGT,SAAS,CAACL,UAAlC,CAN0F,CAQ1F;;EACAc,iBAAiB,GAAGlB,IAAI,CAACG,GAAL,CAASe,iBAAT,EAA4BH,SAAS,CAACI,UAAV,GAAuBF,MAAnD,CAApB,CAT0F,CAU1F;;EACAC,iBAAiB,GAAGlB,IAAI,CAACO,GAAL,CAClBW,iBADkB,EAElBH,SAAS,CAACI,UAAV,GAAuBJ,SAAS,CAACT,WAAjC,GAA+CG,SAAS,CAACH,WAAzD,GAAuEW,MAFrD,CAApB;;EAIA,IAAID,MAAJ,EAAY;IACVvB,YAAY,CAACgB,SAAD,EAAYS,iBAAZ,CAAZ;EACD,CAFD,MAEO;IACLT,SAAS,CAACL,UAAV,GAAuBc,iBAAvB;EACD;AACF,CApBM","names":["smoothScroll","onPaginationClick","headerBarRef","direction","current","element","paginatedSectionSize","Math","ceil","clientWidth","min","scrollLeft","scrollWidth","offsetWidth","max","hasHorizontalOverflow","headerBar","leftOverflowButton","paginationButtonsWidth","hasLeftOverflow","hasRightOverflow","scrollIntoView","tabHeader","smooth","margin","updatedLeftScroll","offsetLeft"],"sourceRoot":"","sources":["../../../src/tabs/scroll-utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\n\nexport const onPaginationClick = (headerBarRef: React.RefObject<HTMLUListElement>, direction: number): void => {\n  if (!headerBarRef?.current) {\n    return;\n  }\n  const element = headerBarRef.current;\n\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  if (direction === 1) {\n    smoothScroll(\n      element,\n      Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth)\n    );\n  }\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\n\nexport const hasHorizontalOverflow = (\n  headerBar: HTMLElement,\n  leftOverflowButton: React.RefObject<HTMLElement>\n): boolean => {\n  const { offsetWidth, scrollWidth } = headerBar;\n\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\n\nexport const hasLeftOverflow = (headerBar: HTMLElement): boolean => {\n  return headerBar.scrollLeft > 0;\n};\n\nexport const hasRightOverflow = (headerBar: HTMLElement): boolean => {\n  const { offsetWidth, scrollLeft, scrollWidth } = headerBar;\n  // scrollLeft can be a decimal value on systems using display scaling\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\n\nexport const scrollIntoView = (tabHeader: HTMLElement, headerBar: HTMLElement, smooth = true): void => {\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(\n    updatedLeftScroll,\n    tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin\n  );\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}