{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n/**\n * @param containerRef ref to surrounding container with sticky element\n * @param stickyRef ref to sticky element scrolled inside of containerRef\n * @param containerOffset offset between header and container\n *                        originating borders or paddings\n */\n\nexport default function stickyScrolling(containerRef, stickyRef) {\n  var scrollToTop = function () {\n    if (!containerRef.current || !stickyRef.current) {\n      return;\n    }\n\n    var scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);\n\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n\n  var scrollToItem = function (item) {\n    if (!item || !containerRef.current || !stickyRef.current) {\n      return;\n    }\n\n    var stickyBottom = stickyRef.current.getBoundingClientRect().bottom;\n    var scrollingOffset = stickyBottom - item.getBoundingClientRect().top;\n\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n\n  return {\n    scrollToTop: scrollToTop,\n    scrollToItem: scrollToItem\n  };\n}\n/**\n * Calculates the scrolling offset between container and\n * sticky element with container offset caused by border\n * or padding\n * @param container\n * @param sticky element inside of container\n * @param containerOffset caused by borders or paddings\n */\n\nexport function calculateScrollingOffset(container, sticky) {\n  var stickyRect = sticky.getBoundingClientRect();\n  var containerRect = container.getBoundingClientRect();\n  return stickyRect.top - containerRect.top;\n}\n/**\n * Scrolls suitable parent of container up by amount of pixels\n * @param amount pixels to be scrolled up\n * @param container used to determine next parent element for scrolling\n */\n\nexport function scrollUpBy(amount, container) {\n  var parent = getOverflowParents(container);\n\n  if (parent.length) {\n    // Take next overflow parent in stack\n    parent[0].scrollTop -= amount;\n  } else {\n    window.scrollTo({\n      top: window.pageYOffset - amount\n    });\n  }\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,SAASA,kBAAT,QAAmC,yCAAnC;AAEA;;;;;;;AAMA,eAAc,SAAUC,eAAV,CACZC,YADY,EAEZC,SAFY,EAEyC;EAErD,IAAMC,WAAW,GAAG;IAClB,IAAI,CAACF,YAAY,CAACG,OAAd,IAAyB,CAACF,SAAS,CAACE,OAAxC,EAAiD;MAC/C;IACD;;IACD,IAAMC,eAAe,GAAGC,wBAAwB,CAACL,YAAY,CAACG,OAAd,EAAuBF,SAAS,CAACE,OAAjC,CAAhD;;IACA,IAAIC,eAAe,GAAG,CAAtB,EAAyB;MACvBE,UAAU,CAACF,eAAD,EAAkBJ,YAAY,CAACG,OAA/B,CAAV;IACD;EACF,CARD;;EASA,IAAMI,YAAY,GAAG,UAACC,IAAD,EAAyB;IAC5C,IAAI,CAACA,IAAD,IAAS,CAACR,YAAY,CAACG,OAAvB,IAAkC,CAACF,SAAS,CAACE,OAAjD,EAA0D;MACxD;IACD;;IACD,IAAMM,YAAY,GAAGR,SAAS,CAACE,OAAV,CAAkBO,qBAAlB,GAA0CC,MAA/D;IACA,IAAMP,eAAe,GAAGK,YAAY,GAAGD,IAAI,CAACE,qBAAL,GAA6BE,GAApE;;IACA,IAAIR,eAAe,GAAG,CAAtB,EAAyB;MACvBE,UAAU,CAACF,eAAD,EAAkBJ,YAAY,CAACG,OAA/B,CAAV;IACD;EACF,CATD;;EAUA,OAAO;IACLD,WAAW,aADN;IAELK,YAAY;EAFP,CAAP;AAID;AAED;;;;;;;;;AAQA,OAAM,SAAUF,wBAAV,CAAmCQ,SAAnC,EAA2DC,MAA3D,EAA8E;EAClF,IAAMC,UAAU,GAAGD,MAAM,CAACJ,qBAAP,EAAnB;EACA,IAAMM,aAAa,GAAGH,SAAS,CAACH,qBAAV,EAAtB;EACA,OAAOK,UAAU,CAACH,GAAX,GAAiBI,aAAa,CAACJ,GAAtC;AACD;AAED;;;;;;AAKA,OAAM,SAAUN,UAAV,CAAqBW,MAArB,EAAqCJ,SAArC,EAA2D;EAC/D,IAAMK,MAAM,GAAGpB,kBAAkB,CAACe,SAAD,CAAjC;;EACA,IAAIK,MAAM,CAACC,MAAX,EAAmB;IACjB;IACAD,MAAM,CAAC,CAAD,CAAN,CAAUE,SAAV,IAAuBH,MAAvB;EACD,CAHD,MAGO;IACLI,MAAM,CAACC,QAAP,CAAgB;MAAEV,GAAG,EAAES,MAAM,CAACE,WAAP,GAAqBN;IAA5B,CAAhB;EACD;AACF","names":["getOverflowParents","stickyScrolling","containerRef","stickyRef","scrollToTop","current","scrollingOffset","calculateScrollingOffset","scrollUpBy","scrollToItem","item","stickyBottom","getBoundingClientRect","bottom","top","container","sticky","stickyRect","containerRect","amount","parent","length","scrollTop","window","scrollTo","pageYOffset"],"sourceRoot":"","sources":["../../../src/table/sticky-scrolling.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\n/**\n * @param containerRef ref to surrounding container with sticky element\n * @param stickyRef ref to sticky element scrolled inside of containerRef\n * @param containerOffset offset between header and container\n *                        originating borders or paddings\n */\nexport default function stickyScrolling(\n  containerRef: React.MutableRefObject<HTMLElement | null>,\n  stickyRef: React.MutableRefObject<HTMLElement | null>\n) {\n  const scrollToTop = () => {\n    if (!containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  const scrollToItem = (item: HTMLElement | null) => {\n    if (!item || !containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const stickyBottom = stickyRef.current.getBoundingClientRect().bottom;\n    const scrollingOffset = stickyBottom - item.getBoundingClientRect().top;\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  return {\n    scrollToTop,\n    scrollToItem,\n  };\n}\n\n/**\n * Calculates the scrolling offset between container and\n * sticky element with container offset caused by border\n * or padding\n * @param container\n * @param sticky element inside of container\n * @param containerOffset caused by borders or paddings\n */\nexport function calculateScrollingOffset(container: HTMLElement, sticky: HTMLElement) {\n  const stickyRect = sticky.getBoundingClientRect();\n  const containerRect = container.getBoundingClientRect();\n  return stickyRect.top - containerRect.top;\n}\n\n/**\n * Scrolls suitable parent of container up by amount of pixels\n * @param amount pixels to be scrolled up\n * @param container used to determine next parent element for scrolling\n */\nexport function scrollUpBy(amount: number, container: HTMLElement) {\n  const parent = getOverflowParents(container);\n  if (parent.length) {\n    // Take next overflow parent in stack\n    parent[0].scrollTop -= amount;\n  } else {\n    window.scrollTo({ top: window.pageYOffset - amount });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}