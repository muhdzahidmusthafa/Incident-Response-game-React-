{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';\nimport { getOverflowParents } from '../../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../../internal/utils/dom';\nimport tableStyles from '../styles.css.js';\nimport styles from './styles.css.js';\nvar AUTO_GROW_START_TIME = 10;\nvar AUTO_GROW_INTERVAL = 10;\nvar AUTO_GROW_INCREMENT = 5;\nexport function Resizer(_a) {\n  var onDragMove = _a.onDragMove,\n      onFinish = _a.onFinish;\n\n  var _b = useState(false),\n      isDragging = _b[0],\n      setIsDragging = _b[1];\n\n  var _c = useState(),\n      headerCell = _c[0],\n      setHeaderCell = _c[1];\n\n  var autoGrowTimeout = useRef();\n  var onFinishStable = useStableEventHandler(onFinish);\n  var onDragStable = useStableEventHandler(onDragMove);\n  useEffect(function () {\n    if (!isDragging || !headerCell) {\n      return;\n    }\n\n    var rootElement = findUpUntil(headerCell, function (element) {\n      return element.className.indexOf(tableStyles.root) > -1;\n    });\n    var tableElement = rootElement.querySelector(\"table\"); // tracker is rendered inside table wrapper to align with its size\n\n    var tracker = rootElement.querySelector(\".\".concat(styles.tracker));\n    var scrollParent = getOverflowParents(headerCell)[0];\n\n    var _a = scrollParent.getBoundingClientRect(),\n        leftEdge = _a.left,\n        rightEdge = _a.right;\n\n    var updateTrackerPosition = function (newOffset) {\n      var scrollParentLeft = tableElement.getBoundingClientRect().left;\n      tracker.style.top = headerCell.getBoundingClientRect().height + 'px'; // minus one pixel to offset the cell border\n\n      tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n\n    var updateColumnWidth = function (newWidth) {\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onDragStable(newWidth); // we read the element size again because the previous callback changes it\n\n      updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    };\n\n    var resizeColumn = function (offset) {\n      if (offset > leftEdge) {\n        var cellLeft = headerCell.getBoundingClientRect().left;\n        var newWidth = offset - cellLeft; // callbacks must be the last calls in the handler, because they may cause an extra update\n\n        updateColumnWidth(newWidth);\n      }\n    };\n\n    var onAutoGrow = function () {\n      var width = headerCell.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL); // callbacks must be the last calls in the handler, because they may cause an extra update\n\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n\n    var onMouseMove = function (event) {\n      clearTimeout(autoGrowTimeout.current);\n      var offset = event.pageX;\n\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n\n    var onMouseUp = function (event) {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onFinishStable();\n      clearTimeout(autoGrowTimeout.current);\n    };\n\n    updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    document.body.classList.add(styles['resize-active']);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    return function () {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [headerCell, isDragging, onDragStable, onFinishStable]);\n  return React.createElement(\"span\", {\n    className: clsx(styles.resizer, isDragging && styles['resizer-active']),\n    onMouseDown: function (event) {\n      if (event.button !== 0) {\n        return;\n      }\n\n      event.preventDefault();\n      var headerCell = findUpUntil(event.currentTarget, function (element) {\n        return element.tagName.toLowerCase() === 'th';\n      });\n      setIsDragging(true);\n      setHeaderCell(headerCell);\n    }\n  });\n}\nexport function ResizeTracker() {\n  return React.createElement(\"span\", {\n    className: styles.tracker\n  });\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,KAAP,IAAgBC,SAAhB,EAA2BC,MAA3B,EAAmCC,QAAnC,QAAmD,OAAnD;AACA,SAASC,qBAAT,QAAsC,+CAAtC;AACA,SAASC,kBAAT,QAAmC,4CAAnC;AACA,SAASC,WAAT,QAA4B,0BAA5B;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AAOA,IAAMC,oBAAoB,GAAG,EAA7B;AACA,IAAMC,kBAAkB,GAAG,EAA3B;AACA,IAAMC,mBAAmB,GAAG,CAA5B;AAEA,OAAM,SAAUC,OAAV,CAAkBC,EAAlB,EAAwD;MAApCC,UAAU;MAAEC,QAAQ;;EACtC,SAA8BZ,QAAQ,CAAC,KAAD,CAAtC;EAAA,IAACa,UAAU,QAAX;EAAA,IAAaC,aAAa,QAA1B;;EACA,SAA8Bd,QAAQ,EAAtC;EAAA,IAACe,UAAU,QAAX;EAAA,IAAaC,aAAa,QAA1B;;EACN,IAAMC,eAAe,GAAGlB,MAAM,EAA9B;EACA,IAAMmB,cAAc,GAAGjB,qBAAqB,CAACW,QAAD,CAA5C;EACA,IAAMO,YAAY,GAAGlB,qBAAqB,CAACU,UAAD,CAA1C;EACAb,SAAS,CAAC;IACR,IAAI,CAACe,UAAD,IAAe,CAACE,UAApB,EAAgC;MAC9B;IACD;;IACD,IAAMK,WAAW,GAAGjB,WAAW,CAACY,UAAD,EAAa,mBAAO;MAAI,cAAO,CAACM,SAAR,CAAkBC,OAAlB,CAA0BlB,WAAW,CAACmB,IAAtC,IAA8C,CAAC,CAA/C;IAAgD,CAAxE,CAA/B;IACA,IAAMC,YAAY,GAAGJ,WAAW,CAACK,aAAZ,CAAuC,OAAvC,CAArB,CALQ,CAMR;;IACA,IAAMC,OAAO,GAAGN,WAAW,CAACK,aAAZ,CAAuC,WAAIpB,MAAM,CAACqB,OAAX,CAAvC,CAAhB;IACA,IAAMC,YAAY,GAAGzB,kBAAkB,CAACa,UAAD,CAAlB,CAA+B,CAA/B,CAArB;;IACM,SAAuCY,YAAY,CAACC,qBAAb,EAAvC;IAAA,IAAQC,QAAQ,UAAhB;IAAA,IAAyBC,SAAS,WAAlC;;IAEN,IAAMC,qBAAqB,GAAG,UAACC,SAAD,EAAkB;MACtC,IAAMC,gBAAgB,GAAKT,YAAY,CAACI,qBAAb,GAAoCM,IAA/D;MACRR,OAAO,CAACS,KAAR,CAAcC,GAAd,GAAoBrB,UAAU,CAACa,qBAAX,GAAmCS,MAAnC,GAA4C,IAAhE,CAF8C,CAG9C;;MACAX,OAAO,CAACS,KAAR,CAAcD,IAAd,GAAqBF,SAAS,GAAGC,gBAAZ,GAA+B,CAA/B,GAAmC,IAAxD;IACD,CALD;;IAOA,IAAMK,iBAAiB,GAAG,UAACC,QAAD,EAAiB;MACzC;MACApB,YAAY,CAACoB,QAAD,CAAZ,CAFyC,CAGzC;;MACAR,qBAAqB,CAAChB,UAAU,CAACa,qBAAX,GAAmCY,KAApC,CAArB;IACD,CALD;;IAOA,IAAMC,YAAY,GAAG,UAACC,MAAD,EAAe;MAClC,IAAIA,MAAM,GAAGb,QAAb,EAAuB;QACrB,IAAMc,QAAQ,GAAG5B,UAAU,CAACa,qBAAX,GAAmCM,IAApD;QACA,IAAMK,QAAQ,GAAGG,MAAM,GAAGC,QAA1B,CAFqB,CAGrB;;QACAL,iBAAiB,CAACC,QAAD,CAAjB;MACD;IACF,CAPD;;IASA,IAAMK,UAAU,GAAG;MACjB,IAAMC,KAAK,GAAG9B,UAAU,CAACa,qBAAX,GAAmCiB,KAAjD;MACA5B,eAAe,CAAC6B,OAAhB,GAA0BC,UAAU,CAACH,UAAD,EAAarC,kBAAb,CAApC,CAFiB,CAGjB;;MACA+B,iBAAiB,CAACO,KAAK,GAAGrC,mBAAT,CAAjB;MACAmB,YAAY,CAACqB,UAAb,IAA2BxC,mBAA3B;IACD,CAND;;IAOA,IAAMyC,WAAW,GAAG,UAACC,KAAD,EAAkB;MACpCC,YAAY,CAAClC,eAAe,CAAC6B,OAAjB,CAAZ;MACA,IAAMJ,MAAM,GAAGQ,KAAK,CAACE,KAArB;;MACA,IAAIV,MAAM,GAAGZ,SAAb,EAAwB;QACtBb,eAAe,CAAC6B,OAAhB,GAA0BC,UAAU,CAACH,UAAD,EAAatC,oBAAb,CAApC;MACD,CAFD,MAEO;QACLmC,YAAY,CAACC,MAAD,CAAZ;MACD;IACF,CARD;;IASA,IAAMW,SAAS,GAAG,UAACH,KAAD,EAAkB;MAClCT,YAAY,CAACS,KAAK,CAACE,KAAP,CAAZ;MACAtC,aAAa,CAAC,KAAD,CAAb;MACAI,cAAc;MACdiC,YAAY,CAAClC,eAAe,CAAC6B,OAAjB,CAAZ;IACD,CALD;;IAMAf,qBAAqB,CAAChB,UAAU,CAACa,qBAAX,GAAmCY,KAApC,CAArB;IACAc,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBC,GAAxB,CAA4BpD,MAAM,CAAC,eAAD,CAAlC;IACAiD,QAAQ,CAACI,gBAAT,CAA0B,WAA1B,EAAuCT,WAAvC;IACAK,QAAQ,CAACI,gBAAT,CAA0B,SAA1B,EAAqCL,SAArC;IACA,OAAO;MACLF,YAAY,CAAClC,eAAe,CAAC6B,OAAjB,CAAZ;MACAQ,QAAQ,CAACC,IAAT,CAAcC,SAAd,CAAwBG,MAAxB,CAA+BtD,MAAM,CAAC,eAAD,CAArC;MACAiD,QAAQ,CAACM,mBAAT,CAA6B,WAA7B,EAA0CX,WAA1C;MACAK,QAAQ,CAACM,mBAAT,CAA6B,SAA7B,EAAwCP,SAAxC;IACD,CALD;EAMD,CAlEQ,EAkEN,CAACtC,UAAD,EAAaF,UAAb,EAAyBM,YAAzB,EAAuCD,cAAvC,CAlEM,CAAT;EAmEA,OACErB;IACEwB,SAAS,EAAEzB,IAAI,CAACS,MAAM,CAACwD,OAAR,EAAiBhD,UAAU,IAAIR,MAAM,CAAC,gBAAD,CAArC,CADjB;IAEEyD,WAAW,EAAE,iBAAK;MAChB,IAAIZ,KAAK,CAACa,MAAN,KAAiB,CAArB,EAAwB;QACtB;MACD;;MACDb,KAAK,CAACc,cAAN;MACA,IAAMjD,UAAU,GAAGZ,WAAW,CAAC+C,KAAK,CAACe,aAAP,EAAsB,mBAAO;QAAI,cAAO,CAACC,OAAR,CAAgBC,WAAhB,OAAkC,IAAlC;MAAsC,CAAvE,CAA9B;MACArD,aAAa,CAAC,IAAD,CAAb;MACAE,aAAa,CAACD,UAAD,CAAb;IACD;EAVH,EADF;AAcD;AAED,OAAM,SAAUqD,aAAV,GAAuB;EAC3B,OAAOvE;IAAMwB,SAAS,EAAEhB,MAAM,CAACqB;EAAxB,EAAP;AACD","names":["clsx","React","useEffect","useRef","useState","useStableEventHandler","getOverflowParents","findUpUntil","tableStyles","styles","AUTO_GROW_START_TIME","AUTO_GROW_INTERVAL","AUTO_GROW_INCREMENT","Resizer","_a","onDragMove","onFinish","isDragging","setIsDragging","headerCell","setHeaderCell","autoGrowTimeout","onFinishStable","onDragStable","rootElement","className","indexOf","root","tableElement","querySelector","tracker","scrollParent","getBoundingClientRect","leftEdge","rightEdge","updateTrackerPosition","newOffset","scrollParentLeft","left","style","top","height","updateColumnWidth","newWidth","right","resizeColumn","offset","cellLeft","onAutoGrow","width","current","setTimeout","scrollLeft","onMouseMove","event","clearTimeout","pageX","onMouseUp","document","body","classList","add","addEventListener","remove","removeEventListener","resizer","onMouseDown","button","preventDefault","currentTarget","tagName","toLowerCase","ResizeTracker"],"sourceRoot":"","sources":["../../../../src/table/resizer/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';\nimport { getOverflowParents } from '../../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../../internal/utils/dom';\nimport tableStyles from '../styles.css.js';\nimport styles from './styles.css.js';\n\ninterface ResizerProps {\n  onDragMove: (newWidth: number) => void;\n  onFinish: () => void;\n}\n\nconst AUTO_GROW_START_TIME = 10;\nconst AUTO_GROW_INTERVAL = 10;\nconst AUTO_GROW_INCREMENT = 5;\n\nexport function Resizer({ onDragMove, onFinish }: ResizerProps) {\n  const [isDragging, setIsDragging] = useState(false);\n  const [headerCell, setHeaderCell] = useState<HTMLElement>();\n  const autoGrowTimeout = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const onFinishStable = useStableEventHandler(onFinish);\n  const onDragStable = useStableEventHandler(onDragMove);\n  useEffect(() => {\n    if (!isDragging || !headerCell) {\n      return;\n    }\n    const rootElement = findUpUntil(headerCell, element => element.className.indexOf(tableStyles.root) > -1)!;\n    const tableElement = rootElement.querySelector<HTMLElement>(`table`)!;\n    // tracker is rendered inside table wrapper to align with its size\n    const tracker = rootElement.querySelector<HTMLElement>(`.${styles.tracker}`)!;\n    const scrollParent = getOverflowParents(headerCell)[0];\n    const { left: leftEdge, right: rightEdge } = scrollParent.getBoundingClientRect();\n\n    const updateTrackerPosition = (newOffset: number) => {\n      const { left: scrollParentLeft } = tableElement.getBoundingClientRect();\n      tracker.style.top = headerCell.getBoundingClientRect().height + 'px';\n      // minus one pixel to offset the cell border\n      tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n\n    const updateColumnWidth = (newWidth: number) => {\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onDragStable(newWidth);\n      // we read the element size again because the previous callback changes it\n      updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    };\n\n    const resizeColumn = (offset: number) => {\n      if (offset > leftEdge) {\n        const cellLeft = headerCell.getBoundingClientRect().left;\n        const newWidth = offset - cellLeft;\n        // callbacks must be the last calls in the handler, because they may cause an extra update\n        updateColumnWidth(newWidth);\n      }\n    };\n\n    const onAutoGrow = () => {\n      const width = headerCell.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n    const onMouseMove = (event: MouseEvent) => {\n      clearTimeout(autoGrowTimeout.current);\n      const offset = event.pageX;\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n    const onMouseUp = (event: MouseEvent) => {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onFinishStable();\n      clearTimeout(autoGrowTimeout.current);\n    };\n    updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    document.body.classList.add(styles['resize-active']);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [headerCell, isDragging, onDragStable, onFinishStable]);\n  return (\n    <span\n      className={clsx(styles.resizer, isDragging && styles['resizer-active'])}\n      onMouseDown={event => {\n        if (event.button !== 0) {\n          return;\n        }\n        event.preventDefault();\n        const headerCell = findUpUntil(event.currentTarget, element => element.tagName.toLowerCase() === 'th')!;\n        setIsDragging(true);\n        setHeaderCell(headerCell);\n      }}\n    />\n  );\n}\n\nexport function ResizeTracker() {\n  return <span className={styles.tracker} />;\n}\n"]},"metadata":{},"sourceType":"module"}