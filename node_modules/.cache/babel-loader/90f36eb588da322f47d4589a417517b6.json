{"ast":null,"code":"var SPACE_BETWEEN = 4;\nexport function formatTicks(_a) {\n  var ticks = _a.ticks,\n      scale = _a.scale,\n      getLabelSpace = _a.getLabelSpace,\n      tickFormatter = _a.tickFormatter;\n  return ticks.map(function (tick) {\n    var _a;\n\n    var position = (_a = scale.d3Scale(tick)) !== null && _a !== void 0 ? _a : NaN;\n    var label = tickFormatter ? tickFormatter(tick) : tick.toString();\n    var lines = (label + '').split('\\n');\n    return {\n      position: position,\n      lines: lines,\n      space: Math.max.apply(Math, lines.map(getLabelSpace))\n    };\n  });\n}\nexport function getVisibleTicks(ticks, from, until, balanceTicks) {\n  if (balanceTicks === void 0) {\n    balanceTicks = false;\n  }\n\n  ticks = getTicksInRange(ticks, from, until);\n  return balanceTicks ? getReducedTicks(ticks) : removeIntersections(ticks);\n}\n\nfunction getTicksInRange(ticks, from, until) {\n  return ticks.filter(function (tick) {\n    return from <= tick.position - tick.space / 2 && tick.position + tick.space / 2 <= until;\n  });\n}\n\nfunction getReducedTicks(ticks) {\n  var reduceLabelRatio = findReduceLabelRatio(ticks);\n  var reducedTicks = [];\n\n  for (var index = 0; index < ticks.length; index += reduceLabelRatio) {\n    reducedTicks.push(ticks[index]);\n  }\n\n  return reducedTicks;\n} // Returns a ratio such that all elements can be displayed with no intersections.\n\n\nfunction findReduceLabelRatio(ticks, ratio) {\n  if (ratio === void 0) {\n    ratio = 1;\n  }\n\n  if (ratio >= ticks.length) {\n    return ratio;\n  }\n\n  for (var i = ratio; i < ticks.length; i += ratio) {\n    if (hasIntersection(ticks[i - ratio], ticks[i])) {\n      return findReduceLabelRatio(ticks, ratio + 1);\n    }\n  }\n\n  return ratio;\n}\n\nfunction removeIntersections(ticks) {\n  var visibleTicks = [];\n  var prevTick = null;\n\n  for (var _i = 0, ticks_1 = ticks; _i < ticks_1.length; _i++) {\n    var tick = ticks_1[_i];\n\n    if (!prevTick || !hasIntersection(prevTick, tick)) {\n      visibleTicks.push(tick);\n      prevTick = tick;\n    }\n  }\n\n  return visibleTicks;\n}\n\nfunction hasIntersection(a, b) {\n  var _a = a.position < b.position ? [a, b] : [b, a],\n      left = _a[0],\n      right = _a[1];\n\n  var leftEdge = left.position + left.space / 2 + SPACE_BETWEEN;\n  var rightEdge = right.position - right.space / 2;\n  return leftEdge > rightEdge;\n}","map":{"version":3,"mappings":"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","names":["SPACE_BETWEEN","formatTicks","_a","ticks","scale","getLabelSpace","tickFormatter","map","position","d3Scale","tick","NaN","label","toString","lines","split","space","Math","max","apply","getVisibleTicks","from","until","balanceTicks","getTicksInRange","getReducedTicks","removeIntersections","filter","reduceLabelRatio","findReduceLabelRatio","reducedTicks","index","length","push","ratio","i","hasIntersection","visibleTicks","prevTick","_i","a","b","left","right","leftEdge","rightEdge"],"sourceRoot":"","sources":["../../../../../src/internal/components/cartesian-chart/label-utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes } from './interfaces';\nimport { ChartScale, NumericChartScale } from './scales';\n\nconst SPACE_BETWEEN = 4;\n\nexport interface FormattedTick {\n  position: number;\n  space: number;\n  lines: string[];\n}\n\nexport function formatTicks({\n  ticks,\n  scale,\n  getLabelSpace,\n  tickFormatter,\n}: {\n  ticks: readonly ChartDataTypes[];\n  scale: ChartScale | NumericChartScale;\n  getLabelSpace: (label: string) => number;\n  tickFormatter?: (value: any) => string;\n}): FormattedTick[] {\n  return ticks.map(tick => {\n    const position = scale.d3Scale(tick as any) ?? NaN;\n    const label = tickFormatter ? tickFormatter(tick as any) : tick.toString();\n    const lines = (label + '').split('\\n');\n    return { position, lines, space: Math.max(...lines.map(getLabelSpace)) };\n  });\n}\n\nexport function getVisibleTicks(ticks: readonly FormattedTick[], from: number, until: number, balanceTicks = false) {\n  ticks = getTicksInRange(ticks, from, until);\n  return balanceTicks ? getReducedTicks(ticks) : removeIntersections(ticks);\n}\n\nfunction getTicksInRange(ticks: readonly FormattedTick[], from: number, until: number) {\n  return ticks.filter(tick => from <= tick.position - tick.space / 2 && tick.position + tick.space / 2 <= until);\n}\n\nfunction getReducedTicks(ticks: readonly FormattedTick[]): readonly FormattedTick[] {\n  const reduceLabelRatio = findReduceLabelRatio(ticks);\n\n  const reducedTicks = [];\n  for (let index = 0; index < ticks.length; index += reduceLabelRatio) {\n    reducedTicks.push(ticks[index]);\n  }\n  return reducedTicks;\n}\n\n// Returns a ratio such that all elements can be displayed with no intersections.\nfunction findReduceLabelRatio(ticks: readonly FormattedTick[], ratio = 1): number {\n  if (ratio >= ticks.length) {\n    return ratio;\n  }\n  for (let i = ratio; i < ticks.length; i += ratio) {\n    if (hasIntersection(ticks[i - ratio], ticks[i])) {\n      return findReduceLabelRatio(ticks, ratio + 1);\n    }\n  }\n  return ratio;\n}\n\nfunction removeIntersections(ticks: readonly FormattedTick[]) {\n  const visibleTicks = [];\n  let prevTick = null;\n  for (const tick of ticks) {\n    if (!prevTick || !hasIntersection(prevTick, tick)) {\n      visibleTicks.push(tick);\n      prevTick = tick;\n    }\n  }\n  return visibleTicks;\n}\n\nfunction hasIntersection(a: FormattedTick, b: FormattedTick) {\n  const [left, right] = a.position < b.position ? [a, b] : [b, a];\n  const leftEdge = left.position + left.space / 2 + SPACE_BETWEEN;\n  const rightEdge = right.position - right.space / 2;\n  return leftEdge > rightEdge;\n}\n"]},"metadata":{},"sourceType":"module"}