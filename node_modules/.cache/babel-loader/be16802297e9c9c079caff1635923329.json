{"ast":null,"code":"import { isXThreshold, isYThreshold } from './utils';\n/** Combine all line series into an array of scaled data points with the given scales. */\n\nexport default function makeScaledSeries(allSeries, xScale, yScale) {\n  var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  var scaleX = function (x) {\n    return (xScale.d3Scale(x) || 0) + xOffset;\n  };\n\n  var scaleY = function (y) {\n    return yScale.d3Scale(y) || 0;\n  };\n\n  var allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(scaledPoints, xThresholdSeries, xThresholdSeriesColor) {\n    var _a, _b;\n\n    var x = scaleX(xThresholdSeries.x); // Locate a point the x-threshold can be inserted after (if such exists).\n\n    var bisectIndex = -1;\n\n    for (var i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    } // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n\n\n    if (bisectIndex !== -1) {\n      var prevY = ((_a = scaledPoints[bisectIndex].datum) === null || _a === void 0 ? void 0 : _a.y) || 0;\n      var nextY = ((_b = scaledPoints[bisectIndex + 1].datum) === null || _b === void 0 ? void 0 : _b.y) || 0;\n      var averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: {\n          x: xThresholdSeries.x,\n          y: NaN\n        },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor\n      });\n    }\n  }\n\n  var scaledSeriesX = allSeries.map(function (_a) {\n    var series = _a.series,\n        color = _a.color;\n    var scaledPoints = []; // Scale and add all line series data points.\n\n    if (series.type === 'line') {\n      for (var _i = 0, _b = series.data; _i < _b.length; _i++) {\n        var datum = _b[_i];\n        scaledPoints.push({\n          x: scaleX(datum.x),\n          y: scaleY(datum.y),\n          datum: datum,\n          series: series,\n          color: color\n        });\n      } // Sort scaled points to ensure correct x-thresholds insertion.\n\n\n      scaledPoints.sort(function (s1, s2) {\n        return s1.x - s2.x;\n      }); // Merge x-thresholds into series if they don't have a shared coordinate.\n\n      for (var _c = 0, allSeries_1 = allSeries; _c < allSeries_1.length; _c++) {\n        var otherSeries = allSeries_1[_c];\n\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    } // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (var _d = 0, allX_1 = allX; _d < allX_1.length; _d++) {\n        var x = allX_1[_d];\n        scaledPoints.push({\n          x: scaleX(x),\n          y: scaleY(series.y),\n          datum: {\n            x: x,\n            y: series.y\n          },\n          series: series,\n          color: color\n        });\n      } // Support threshold-only setup.\n\n\n      if (allX.length === 0) {\n        scaledPoints.push({\n          x: NaN,\n          y: scaleY(series.y),\n          series: series,\n          color: color\n        });\n      }\n    } // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({\n        x: scaleX(series.x),\n        y: NaN,\n        datum: {\n          x: series.x,\n          y: NaN\n        },\n        series: series,\n        color: color\n      });\n    } // Bar series are handled separately.\n\n\n    return scaledPoints;\n  }); // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n\n  return flatten(scaledSeriesX).sort(function (s1, s2) {\n    return s1.x - s2.x;\n  });\n}\n/** Collect unique x values from all data series. */\n\nfunction getAllX(series) {\n  var addDataXSet = new Set();\n\n  for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n    var s = series_1[_i].series;\n\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (var _a = 0, _b = s.data; _a < _b.length; _a++) {\n          var d = _b[_a];\n          addDataXSet.add(d.x);\n        }\n\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        } // Thresholds don't have X values.\n\n\n        break;\n    }\n  }\n\n  var allDataX = [];\n  addDataXSet.forEach(function (x) {\n    return allDataX.push(x);\n  });\n  return allDataX;\n}\n\nfunction flatten(arrays) {\n  var merged = [];\n\n  for (var _i = 0, arrays_1 = arrays; _i < arrays_1.length; _i++) {\n    var array = arrays_1[_i];\n\n    for (var _a = 0, array_1 = array; _a < array_1.length; _a++) {\n      var item = array_1[_a];\n      merged.push(item);\n    }\n  }\n\n  return merged;\n}","map":{"version":3,"mappings":"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","names":["isXThreshold","isYThreshold","makeScaledSeries","allSeries","xScale","yScale","xOffset","isCategorical","Math","max","d3Scale","bandwidth","scaleX","x","scaleY","y","allX","getAllX","mergeLineSeriesPointsWithXThresholds","scaledPoints","xThresholdSeries","xThresholdSeriesColor","bisectIndex","i","length","prevY","datum","_a","nextY","_b","averageY","push","NaN","series","color","scaledSeriesX","map","type","data","_i","sort","s1","s2","_c","otherSeries","_d","flatten","addDataXSet","Set","s","d","add","allDataX","forEach","arrays","merged","array","item"],"sourceRoot":"","sources":["../../../src/mixed-line-bar-chart/make-scaled-series.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { isXThreshold, isYThreshold } from './utils';\n\nexport interface ScaledPoint<T> {\n  x: number;\n  y: number;\n  color: string;\n  datum?: MixedLineBarChartProps.Datum<T> | undefined;\n  series: MixedLineBarChartProps.ChartSeries<T>;\n}\n\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries<T extends ChartDataTypes>(\n  allSeries: ReadonlyArray<InternalChartSeries<T>>,\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): readonly ScaledPoint<T>[] {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = (x: T) => (xScale.d3Scale(x as any) || 0) + xOffset;\n  const scaleY = (y: number) => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(\n    scaledPoints: ScaledPoint<T>[],\n    xThresholdSeries: MixedLineBarChartProps.ThresholdSeries<T> & { x: T },\n    xThresholdSeriesColor: string\n  ) {\n    const x = scaleX(xThresholdSeries.x);\n\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = scaledPoints[bisectIndex].datum?.y || 0;\n      const nextY = scaledPoints[bisectIndex + 1].datum?.y || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: { x: xThresholdSeries.x, y: NaN },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor,\n      });\n    }\n  }\n\n  const scaledSeriesX = allSeries.map(({ series, color }) => {\n    const scaledPoints: ScaledPoint<T>[] = [];\n\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data as MixedLineBarChartProps.Datum<T>[]) {\n        scaledPoints.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum, series, color });\n      }\n\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({ x: scaleX(x), y: scaleY(series.y), datum: { x, y: series.y }, series, color });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({ x: NaN, y: scaleY(series.y), series, color });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({ x: scaleX(series.x), y: NaN, datum: { x: series.x, y: NaN }, series, color });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n\n/** Collect unique x values from all data series. */\nfunction getAllX<T>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const addDataXSet = new Set<T>();\n  for (const { series: s } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX: T[] = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n\n  return allDataX;\n}\n\nfunction flatten<T>(arrays: T[][]): T[] {\n  const merged: T[] = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}\n"]},"metadata":{},"sourceType":"module"}