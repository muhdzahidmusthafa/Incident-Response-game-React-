{"ast":null,"code":"import { __assign } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { getContainingBlock, nodeContains } from '../internal/utils/dom';\nimport { useContainerQuery } from '../internal/hooks/container-queries';\nimport { calculatePosition } from './utils/positions';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nvar INITIAL_STYLES = {\n  position: 'absolute',\n  top: -9999,\n  left: -9999\n};\nexport default function PopoverContainer(_a) {\n  var position = _a.position,\n      trackRef = _a.trackRef,\n      trackKey = _a.trackKey,\n      arrow = _a.arrow,\n      children = _a.children,\n      zIndex = _a.zIndex,\n      renderWithPortal = _a.renderWithPortal;\n\n  var _b = useContainerQuery(function (rect, prev) {\n    var roundedRect = {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height)\n    };\n    return (prev === null || prev === void 0 ? void 0 : prev.width) === roundedRect.width && (prev === null || prev === void 0 ? void 0 : prev.height) === roundedRect.height ? prev : rect;\n  }),\n      popoverRect = _b[0],\n      ref = _b[1];\n\n  var bodyRef = useRef(null);\n  var arrowRef = useRef(null);\n\n  var _c = useState(INITIAL_STYLES),\n      inlineStyle = _c[0],\n      setInlineStyle = _c[1];\n\n  var _d = useState(null),\n      internalPosition = _d[0],\n      setInternalPosition = _d[1];\n\n  var isRefresh = useVisualRefresh(ref); // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n\n  var positionHandlerRef = useRef(function () {}); // Updates the position handler.\n\n  var updatePositionHandler = useCallback(function () {\n    if (!trackRef.current || !ref.current || !bodyRef.current || !arrowRef.current) {\n      return;\n    } // Get important elements\n\n\n    var body = bodyRef.current;\n    var arrow = arrowRef.current;\n    var document = ref.current.ownerDocument;\n    var track = trackRef.current; // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n\n    if (body.offsetWidth === 0 || body.offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    } // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n\n\n    var prevTop = body.style.top;\n    var prevLeft = body.style.left;\n    body.style.top = '0';\n    body.style.left = '0'; // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n\n    var viewportRect = getViewportRect(document.defaultView);\n    var trackRect = track.getBoundingClientRect();\n    var arrowRect = {\n      width: parseFloat(getComputedStyle(arrow).width),\n      height: parseFloat(getComputedStyle(arrow).height)\n    };\n    var containingBlock = getContainingBlock(body);\n    var containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect; // Round up dimensions (IE11 doesn't handle subpixels too accurately)\n\n    var bodyRect = body.getBoundingClientRect();\n    var bodyRectCeil = {\n      top: bodyRect.top,\n      left: bodyRect.left,\n      width: Math.ceil(bodyRect.width),\n      height: Math.ceil(bodyRect.height)\n    }; // Calculate the arrow direction and viewport-relative position of the popover.\n\n    var _a = calculatePosition(position, trackRect, arrowRect, bodyRectCeil, containingBlock ? containingBlockRect : getDocumentRect(document), viewportRect, renderWithPortal),\n        newInternalPosition = _a.internalPosition,\n        boundingOffset = _a.boundingOffset; // Get the position of the popover relative to the offset parent.\n\n\n    var popoverOffset = toRelativePosition(boundingOffset, containingBlockRect); // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n\n    var trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect)); // Bring back the container to its original position to prevent any\n    // flashing.\n\n    body.style.top = prevTop;\n    body.style.left = prevLeft; // Position the popover\n\n    setInternalPosition(newInternalPosition);\n    setInlineStyle({\n      top: popoverOffset.top,\n      left: popoverOffset.left\n    });\n\n    positionHandlerRef.current = function () {\n      var newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);\n      setInlineStyle({\n        top: newTrackOffset.top + trackRelativeOffset.top,\n        left: newTrackOffset.left + trackRelativeOffset.left\n      });\n    };\n  }, [position, trackRef, ref, renderWithPortal]); // Update the handler when properties change.\n\n  useLayoutEffect(function () {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey, popoverRect]); // Attach document listeners.\n\n  useLayoutEffect(function () {\n    /*\n      This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n      and by tracking the click event we can adapt the popover's position to the new layout.\n           TODO: extend this to Enter and Spacebar?\n    */\n    var updatePosition = function () {\n      return requestAnimationFrame(function () {\n        return updatePositionHandler();\n      });\n    };\n\n    var refreshPosition = function () {\n      return requestAnimationFrame(function () {\n        return positionHandlerRef.current();\n      });\n    };\n\n    window.addEventListener('click', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('scroll', refreshPosition, true);\n    return function () {\n      window.removeEventListener('click', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [updatePositionHandler]);\n  var mergedRef = useMergeRefs(bodyRef, ref);\n  return React.createElement(\"div\", {\n    ref: mergedRef,\n    style: __assign(__assign({}, inlineStyle), {\n      zIndex: zIndex\n    }),\n    className: clsx(styles.container, isRefresh && styles.refresh)\n  }, React.createElement(\"div\", {\n    ref: arrowRef,\n    className: clsx(styles[\"container-arrow\"], styles[\"container-arrow-position-\".concat(internalPosition)]),\n    \"aria-hidden\": true\n  }, arrow(internalPosition)), children);\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\n\nfunction toRelativePosition(element, parent) {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left\n  };\n}\n/**\n * Get a BoundingOffset that represents the visible viewport.\n */\n\n\nfunction getViewportRect(window) {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n}\n\nfunction getDocumentRect(document) {\n  var _a = document.documentElement.getBoundingClientRect(),\n      top = _a.top,\n      left = _a.left;\n\n  return {\n    top: top,\n    left: left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"mappings":"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","names":["React","useCallback","useLayoutEffect","useRef","useState","clsx","getContainingBlock","nodeContains","useContainerQuery","calculatePosition","styles","useVisualRefresh","useMergeRefs","INITIAL_STYLES","position","top","left","PopoverContainer","_a","trackRef","trackKey","arrow","children","zIndex","renderWithPortal","rect","prev","roundedRect","width","Math","round","height","popoverRect","ref","bodyRef","arrowRef","inlineStyle","setInlineStyle","internalPosition","setInternalPosition","isRefresh","positionHandlerRef","updatePositionHandler","current","body","document","ownerDocument","track","offsetWidth","offsetHeight","prevTop","style","prevLeft","viewportRect","getViewportRect","defaultView","trackRect","getBoundingClientRect","arrowRect","parseFloat","getComputedStyle","containingBlock","containingBlockRect","bodyRect","bodyRectCeil","ceil","getDocumentRect","newInternalPosition","boundingOffset","popoverOffset","toRelativePosition","trackRelativeOffset","newTrackOffset","updatePosition","refreshPosition","window","addEventListener","removeEventListener","mergedRef","className","container","refresh","element","parent","innerWidth","innerHeight","documentElement","scrollWidth","scrollHeight"],"sourceRoot":"","sources":["../../../src/popover/container.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { CSSProperties, useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\n\nimport { getContainingBlock, nodeContains } from '../internal/utils/dom';\nimport { ContainerQueryEntry, useContainerQuery } from '../internal/hooks/container-queries';\nimport { BoundingOffset, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition } from './utils/positions';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\n\nexport interface PopoverContainerProps {\n  /** References the element the container is positioned against. */\n  trackRef: React.RefObject<Element>;\n  /**\n    Used to update the container position in case track or track position changes:\n    \n    const trackRef = useRef<Element>(null)\n    return (<>\n      <Track style={getPosition(selectedItemId)} ref={trackRef} />\n      <PopoverContainer trackRef={trackRef} trackKey={selectedItemId} .../>\n    </>)\n  */\n  trackKey?: string | number;\n  position: PopoverProps.Position;\n  zIndex?: React.CSSProperties['zIndex'];\n  arrow: (position: InternalPosition | null) => React.ReactNode;\n  children: React.ReactNode;\n  renderWithPortal?: boolean;\n}\n\nconst INITIAL_STYLES: CSSProperties = { position: 'absolute', top: -9999, left: -9999 };\n\nexport default function PopoverContainer({\n  position,\n  trackRef,\n  trackKey,\n  arrow,\n  children,\n  zIndex,\n  renderWithPortal,\n}: PopoverContainerProps) {\n  const [popoverRect, ref] = useContainerQuery((rect, prev) => {\n    const roundedRect = { width: Math.round(rect.width), height: Math.round(rect.height) };\n    return prev?.width === roundedRect.width && prev?.height === roundedRect.height ? prev : rect;\n  }) as [ContainerQueryEntry | null, React.MutableRefObject<HTMLDivElement | null>];\n\n  const bodyRef = useRef<HTMLDivElement | null>(null);\n  const arrowRef = useRef<HTMLDivElement | null>(null);\n\n  const [inlineStyle, setInlineStyle] = useState<CSSProperties>(INITIAL_STYLES);\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n  const isRefresh = useVisualRefresh(ref);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  // Updates the position handler.\n  const updatePositionHandler = useCallback(() => {\n    if (!trackRef.current || !ref.current || !bodyRef.current || !arrowRef.current) {\n      return;\n    }\n\n    // Get important elements\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = ref.current.ownerDocument;\n    const track = trackRef.current;\n\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    if (body.offsetWidth === 0 || body.offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevTop = body.style.top;\n    const prevLeft = body.style.left;\n    body.style.top = '0';\n    body.style.left = '0';\n\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView!);\n    const trackRect = track.getBoundingClientRect();\n    const arrowRect = {\n      width: parseFloat(getComputedStyle(arrow).width),\n      height: parseFloat(getComputedStyle(arrow).height),\n    };\n    const containingBlock = getContainingBlock(body);\n    const containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;\n\n    // Round up dimensions (IE11 doesn't handle subpixels too accurately)\n    const bodyRect = body.getBoundingClientRect();\n    const bodyRectCeil = {\n      top: bodyRect.top,\n      left: bodyRect.left,\n      width: Math.ceil(bodyRect.width),\n      height: Math.ceil(bodyRect.height),\n    };\n\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const { internalPosition: newInternalPosition, boundingOffset } = calculatePosition(\n      position,\n      trackRect,\n      arrowRect,\n      bodyRectCeil,\n      containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewportRect,\n      renderWithPortal\n    );\n\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(boundingOffset, containingBlockRect);\n\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n    // Bring back the container to its original position to prevent any\n    // flashing.\n    body.style.top = prevTop;\n    body.style.left = prevLeft;\n\n    // Position the popover\n    setInternalPosition(newInternalPosition);\n    setInlineStyle({ top: popoverOffset.top, left: popoverOffset.left });\n\n    positionHandlerRef.current = () => {\n      const newTrackOffset = toRelativePosition(\n        track.getBoundingClientRect(),\n        containingBlock ? containingBlock.getBoundingClientRect() : viewportRect\n      );\n      setInlineStyle({\n        top: newTrackOffset.top + trackRelativeOffset.top,\n        left: newTrackOffset.left + trackRelativeOffset.left,\n      });\n    };\n  }, [position, trackRef, ref, renderWithPortal]);\n\n  // Update the handler when properties change.\n  useLayoutEffect(() => {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey, popoverRect]);\n\n  // Attach document listeners.\n  useLayoutEffect(() => {\n    /*\n      This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n      and by tracking the click event we can adapt the popover's position to the new layout.\n\n      TODO: extend this to Enter and Spacebar?\n    */\n    const updatePosition = () => requestAnimationFrame(() => updatePositionHandler());\n    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());\n\n    window.addEventListener('click', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('scroll', refreshPosition, true);\n    return () => {\n      window.removeEventListener('click', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [updatePositionHandler]);\n\n  const mergedRef = useMergeRefs(bodyRef, ref);\n\n  return (\n    <div\n      ref={mergedRef}\n      style={{ ...inlineStyle, zIndex }}\n      className={clsx(styles.container, isRefresh && styles.refresh)}\n    >\n      <div\n        ref={arrowRef}\n        className={clsx(styles[`container-arrow`], styles[`container-arrow-position-${internalPosition}`])}\n        aria-hidden={true}\n      >\n        {arrow(internalPosition)}\n      </div>\n      {children}\n    </div>\n  );\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left,\n  };\n}\n\n/**\n * Get a BoundingOffset that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingOffset {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingOffset {\n  const { top, left } = document.documentElement.getBoundingClientRect();\n  return {\n    top,\n    left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}