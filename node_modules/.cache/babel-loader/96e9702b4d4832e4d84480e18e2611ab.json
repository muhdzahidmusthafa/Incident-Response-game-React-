{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport var isoToDisplay = function (value) {\n  return value.replace(/-/g, '/');\n};\nexport var displayToIso = function (value) {\n  return value.replace(/\\//g, '-');\n};\nexport var daysInMonth = function (date) {\n  return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n};\n\nvar padLeftZeros = function (value, length) {\n  while (value.length < length) {\n    value = \"0\".concat(value);\n  }\n\n  return value;\n};\n\nexport function parseDate(value, strict) {\n  if (strict === void 0) {\n    strict = false;\n  }\n\n  var _a = value.split('-'),\n      year = _a[0],\n      month = _a[1],\n      day = _a[2];\n\n  var y = Number(year);\n  var m = Number(month);\n  var d = Number(day);\n\n  if (strict) {\n    if (isNaN(y) || isNaN(m) || isNaN(d)) {\n      return null;\n    }\n  }\n\n  return new Date(y, (m || 1) - 1, d || 1);\n} // we cannot use Date.toISOString because it produces GMT time where the date can be different than local\n\nexport var formatDate = function (value) {\n  var year = value.getFullYear();\n  var month = padLeftZeros(\"\".concat(value.getMonth() + 1), 2);\n  var date = padLeftZeros(\"\".concat(value.getDate()), 2);\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(date);\n};\nexport var formatTime = function (value) {\n  var hours = padLeftZeros(\"\".concat(value.getHours()), 2);\n  var minutes = padLeftZeros(\"\".concat(value.getMinutes()), 2);\n  var seconds = padLeftZeros(\"\".concat(value.getSeconds()), 2);\n  return \"\".concat(hours, \":\").concat(minutes, \":\").concat(seconds);\n};\nexport function formatISOStringWithoutTimezone(dateString, timeString) {\n  return \"\".concat(dateString, \"T\").concat(timeString);\n} // reuse date instances, to allow shallow equality checking\n\nvar memoCache = {};\nexport var memoizedDate = function (key, date) {\n  var parsed = date && date.length >= 4 && parseDate(date);\n\n  if (!(memoCache[key] && parsed && memoCache[key].getTime() === parsed.getTime())) {\n    memoCache[key] = parsed;\n  }\n\n  return memoCache[key];\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAO,IAAMA,YAAY,GAAG,UAACC,KAAD,EAAc;EAAK,YAAK,CAACC,OAAN,CAAc,IAAd,EAAoB,GAApB;AAAwB,CAAhE;AACP,OAAO,IAAMC,YAAY,GAAG,UAACF,KAAD,EAAc;EAAK,YAAK,CAACC,OAAN,CAAc,KAAd,EAAqB,GAArB;AAAyB,CAAjE;AAEP,OAAO,IAAME,WAAW,GAAG,UAACC,IAAD,EAAW;EAAK,WAAIC,IAAJ,CAASD,IAAI,CAACE,WAAL,EAAT,EAA6BF,IAAI,CAACG,QAAL,KAAkB,CAA/C,EAAkD,CAAlD,EAAqDC,OAArD;AAA8D,CAAlG;;AAEP,IAAMC,YAAY,GAAG,UAACT,KAAD,EAAgBU,MAAhB,EAA8B;EACjD,OAAOV,KAAK,CAACU,MAAN,GAAeA,MAAtB,EAA8B;IAC5BV,KAAK,GAAG,WAAIA,KAAJ,CAAR;EACD;;EACD,OAAOA,KAAP;AACD,CALD;;AAUA,OAAM,SAAUW,SAAV,CAAoBX,KAApB,EAAmCY,MAAnC,EAAiD;EAAd;IAAAA;EAAc;;EAC/C,SAAqBZ,KAAK,CAACa,KAAN,CAAY,GAAZ,CAArB;EAAA,IAACC,IAAI,QAAL;EAAA,IAAOC,KAAK,QAAZ;EAAA,IAAcC,GAAG,QAAjB;;EAEN,IAAMC,CAAC,GAAGC,MAAM,CAACJ,IAAD,CAAhB;EACA,IAAMK,CAAC,GAAGD,MAAM,CAACH,KAAD,CAAhB;EACA,IAAMK,CAAC,GAAGF,MAAM,CAACF,GAAD,CAAhB;;EAEA,IAAIJ,MAAJ,EAAY;IACV,IAAIS,KAAK,CAACJ,CAAD,CAAL,IAAYI,KAAK,CAACF,CAAD,CAAjB,IAAwBE,KAAK,CAACD,CAAD,CAAjC,EAAsC;MACpC,OAAO,IAAP;IACD;EACF;;EAED,OAAO,IAAIf,IAAJ,CAASY,CAAT,EAAY,CAACE,CAAC,IAAI,CAAN,IAAW,CAAvB,EAA0BC,CAAC,IAAI,CAA/B,CAAP;AACD,C,CAED;;AACA,OAAO,IAAME,UAAU,GAAG,UAACtB,KAAD,EAAY;EACpC,IAAMc,IAAI,GAAGd,KAAK,CAACM,WAAN,EAAb;EACA,IAAMS,KAAK,GAAGN,YAAY,CAAC,UAAGT,KAAK,CAACO,QAAN,KAAmB,CAAtB,CAAD,EAA4B,CAA5B,CAA1B;EACA,IAAMH,IAAI,GAAGK,YAAY,CAAC,UAAGT,KAAK,CAACQ,OAAN,EAAH,CAAD,EAAuB,CAAvB,CAAzB;EACA,OAAO,UAAGM,IAAH,EAAO,GAAP,EAAOS,MAAP,CAAWR,KAAX,EAAgB,GAAhB,EAAgBQ,MAAhB,CAAoBnB,IAApB,CAAP;AACD,CALM;AAOP,OAAO,IAAMoB,UAAU,GAAG,UAACxB,KAAD,EAAY;EACpC,IAAMyB,KAAK,GAAGhB,YAAY,CAAC,UAAGT,KAAK,CAAC0B,QAAN,EAAH,CAAD,EAAwB,CAAxB,CAA1B;EACA,IAAMC,OAAO,GAAGlB,YAAY,CAAC,UAAGT,KAAK,CAAC4B,UAAN,EAAH,CAAD,EAA0B,CAA1B,CAA5B;EACA,IAAMC,OAAO,GAAGpB,YAAY,CAAC,UAAGT,KAAK,CAAC8B,UAAN,EAAH,CAAD,EAA0B,CAA1B,CAA5B;EACA,OAAO,UAAGL,KAAH,EAAQ,GAAR,EAAQF,MAAR,CAAYI,OAAZ,EAAmB,GAAnB,EAAmBJ,MAAnB,CAAuBM,OAAvB,CAAP;AACD,CALM;AAOP,OAAM,SAAUE,8BAAV,CAAyCC,UAAzC,EAA6DC,UAA7D,EAA+E;EACnF,OAAO,UAAGD,UAAH,EAAa,GAAb,EAAaT,MAAb,CAAiBU,UAAjB,CAAP;AACD,C,CAED;;AACA,IAAMC,SAAS,GAAyB,EAAxC;AACA,OAAO,IAAMC,YAAY,GAAG,UAACC,GAAD,EAAchC,IAAd,EAAiC;EAC3D,IAAMiC,MAAM,GAAGjC,IAAI,IAAIA,IAAI,CAACM,MAAL,IAAe,CAAvB,IAA4BC,SAAS,CAACP,IAAD,CAApD;;EACA,IAAI,EAAE8B,SAAS,CAACE,GAAD,CAAT,IAAkBC,MAAlB,IAA4BH,SAAS,CAACE,GAAD,CAAT,CAAeE,OAAf,OAA6BD,MAAM,CAACC,OAAP,EAA3D,CAAJ,EAAkF;IAChFJ,SAAS,CAACE,GAAD,CAAT,GAAiBC,MAAjB;EACD;;EACD,OAAOH,SAAS,CAACE,GAAD,CAAhB;AACD,CANM","names":["isoToDisplay","value","replace","displayToIso","daysInMonth","date","Date","getFullYear","getMonth","getDate","padLeftZeros","length","parseDate","strict","split","year","month","day","y","Number","m","d","isNaN","formatDate","concat","formatTime","hours","getHours","minutes","getMinutes","seconds","getSeconds","formatISOStringWithoutTimezone","dateString","timeString","memoCache","memoizedDate","key","parsed","getTime"],"sourceRoot":"","sources":["../../../../../src/date-picker/calendar/utils/date.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport const isoToDisplay = (value: string) => value.replace(/-/g, '/');\nexport const displayToIso = (value: string) => value.replace(/\\//g, '-');\n\nexport const daysInMonth = (date: Date) => new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n\nconst padLeftZeros = (value: string, length: number) => {\n  while (value.length < length) {\n    value = `0${value}`;\n  }\n  return value;\n};\n\n// we cannot use new Date(string) constructor, because it produces GMT time that may have different date than the local\nexport function parseDate(value: string): Date;\nexport function parseDate(value: string, strict: boolean): Date | null;\nexport function parseDate(value: string, strict = false): Date | null {\n  const [year, month, day] = value.split('-');\n\n  const y = Number(year);\n  const m = Number(month);\n  const d = Number(day);\n\n  if (strict) {\n    if (isNaN(y) || isNaN(m) || isNaN(d)) {\n      return null;\n    }\n  }\n\n  return new Date(y, (m || 1) - 1, d || 1);\n}\n\n// we cannot use Date.toISOString because it produces GMT time where the date can be different than local\nexport const formatDate = (value: Date): string => {\n  const year = value.getFullYear();\n  const month = padLeftZeros(`${value.getMonth() + 1}`, 2);\n  const date = padLeftZeros(`${value.getDate()}`, 2);\n  return `${year}-${month}-${date}`;\n};\n\nexport const formatTime = (value: Date): string => {\n  const hours = padLeftZeros(`${value.getHours()}`, 2);\n  const minutes = padLeftZeros(`${value.getMinutes()}`, 2);\n  const seconds = padLeftZeros(`${value.getSeconds()}`, 2);\n  return `${hours}:${minutes}:${seconds}`;\n};\n\nexport function formatISOStringWithoutTimezone(dateString: string, timeString: string) {\n  return `${dateString}T${timeString}`;\n}\n\n// reuse date instances, to allow shallow equality checking\nconst memoCache: Record<string, Date> = {};\nexport const memoizedDate = (key: string, date: string | null) => {\n  const parsed = date && date.length >= 4 && parseDate(date);\n  if (!(memoCache[key] && parsed && memoCache[key].getTime() === parsed.getTime())) {\n    memoCache[key] = parsed as Date;\n  }\n  return memoCache[key];\n};\n"]},"metadata":{},"sourceType":"module"}