{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { createContext, createRef, useCallback, useEffect, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { getSplitPanelPosition } from './split-panel';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useContainerQuery, useResizeObserver } from '../../internal/hooks/container-queries';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../../internal/is-development';\nimport { warnOnce } from '../../internal/logging';\nimport { applyDefaults } from '../defaults'; // TODO simplify default params + typings\n\nvar defaults = {\n  breadcrumbs: null,\n  content: null,\n  contentHeader: null,\n  contentType: 'default',\n  disableBodyScroll: false,\n  disableContentHeaderOverlap: false,\n  disableContentPaddings: false,\n  dynamicOverlapHeight: 0,\n  headerHeight: 0,\n  footerHeight: 0,\n  handleNavigationClick: function (value) {\n    return value;\n  },\n  handleSplitPanelClick: function () {},\n  handleSplitPanelPreferencesChange: function () {},\n  handleSplitPanelResize: function () {},\n  handleToolsClick: function (value) {\n    return value;\n  },\n  hasDefaultToolsWidth: true,\n  hasNotificationsContent: false,\n  isAnyPanelOpen: false,\n  isMobile: false,\n  isNavigationOpen: false,\n  isSplitPanelForcedPosition: false,\n  isSplitPanelOpen: false,\n  isToolsOpen: false,\n  // TODO: these refs are currently only instantiated once globally\n  layoutElement: createRef(),\n  layoutWidth: 0,\n  mainElement: createRef(),\n  mainOffsetLeft: 0,\n  maxContentWidth: 0,\n  minContentWidth: 280,\n  navigation: null,\n  navigationHide: false,\n  navigationOpen: false,\n  notifications: null,\n  notificationsElement: createRef(),\n  notificationsHeight: 0,\n  offsetBottom: 0,\n  onNavigationChange: function () {},\n  onSplitPanelResize: function () {},\n  onSplitPanelToggle: function () {},\n  onSplitPanelPreferencesChange: function () {},\n  setDynamicOverlapHeight: function (value) {\n    return void value;\n  },\n  setIsNavigationOpen: function (value) {\n    return value;\n  },\n  setIsToolsOpen: function (value) {\n    return value;\n  },\n  setOffsetBottom: function (value) {\n    return void value;\n  },\n  setSplitPanelReportedSize: function (value) {\n    return void value;\n  },\n  splitPanelMaxWidth: 280,\n  splitPanelMinWidth: 280,\n  splitPanelOpen: false,\n  splitPanelPosition: 'bottom',\n  splitPanelPreferences: {\n    position: 'bottom'\n  },\n  splitPanelReportedSize: 0,\n  splitPanelSize: 0,\n  stickyNotifications: false,\n  tools: null\n};\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\n\nexport var AppLayoutContext = createContext(__assign({}, defaults));\nexport var AppLayoutProvider = React.forwardRef(function (_a, forwardRef) {\n  var _b, _c, _d;\n\n  var toolsHide = _a.toolsHide,\n      controlledToolsOpen = _a.toolsOpen,\n      navigationHide = _a.navigationHide,\n      controlledNavigationOpen = _a.navigationOpen,\n      _e = _a.contentType,\n      contentType = _e === void 0 ? 'default' : _e,\n      _f = _a.headerSelector,\n      headerSelector = _f === void 0 ? '#b #h' : _f,\n      _g = _a.footerSelector,\n      footerSelector = _g === void 0 ? '#b #h' : _g,\n      children = _a.children,\n      props = __rest(_a, [\"toolsHide\", \"toolsOpen\", \"navigationHide\", \"navigationOpen\", \"contentType\", \"headerSelector\", \"footerSelector\", \"children\"]);\n\n  var isMobile = useMobile();\n\n  if (isDevelopment) {\n    if (controlledToolsOpen && toolsHide) {\n      warnOnce('AppLayout', \"You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.\");\n    }\n  }\n  /**\n   * The overlap height has a default set in CSS but can also be dynamically overridden\n   * for content types (such as Table and Wizard) that have variable size content in the overlap.\n   */\n\n\n  var _h = useState(0),\n      dynamicOverlapHeight = _h[0],\n      setDynamicOverlapHeight = _h[1];\n  /**\n   * Set the default values for minimum and maximum content width.\n   */\n\n\n  var geckoMaxCssLength = ((1 << 30) - 1) / 60;\n  var halfGeckoMaxCssLength = geckoMaxCssLength / 2; // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n  // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n\n  var maxContentWidth = props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength ? halfGeckoMaxCssLength : (_b = props.maxContentWidth) !== null && _b !== void 0 ? _b : 0;\n  var minContentWidth = (_c = props.minContentWidth) !== null && _c !== void 0 ? _c : 280;\n  /**\n   * Determine the default state of the Navigation and Tools drawers.\n   * Mobile viewports should be closed by default under all circumstances.\n   * If the navigationOpen prop has been set then that should take precedence\n   * over the contentType prop. Desktop viewports that do not have the\n   * navigationOpen or contentType props set will use the default contentType.\n   */\n\n  var contentTypeDefaults = applyDefaults(contentType, {\n    maxContentWidth: maxContentWidth,\n    minContentWidth: minContentWidth\n  }, true);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Navigation drawer. The logic\n   * for determining the default state is colocated with the Navigation component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Navigation drawer. It will set the Navigation state with the\n   * useControllable hook and also fire the onNavigationChange function to\n   * emit the state change.\n   */\n\n  var _j = useControllable(controlledNavigationOpen, props.onNavigationChange, isMobile ? false : contentTypeDefaults.navigationOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'navigationOpen',\n    changeHandler: 'onNavigationChange'\n  }),\n      _k = _j[0],\n      isNavigationOpen = _k === void 0 ? false : _k,\n      setIsNavigationOpen = _j[1];\n\n  var handleNavigationClick = useCallback(function handleNavigationChange(isOpen) {\n    setIsNavigationOpen(isOpen);\n    fireNonCancelableEvent(props.onNavigationChange, {\n      open: isOpen\n    });\n  }, [props.onNavigationChange, setIsNavigationOpen]);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Tools drawer. The logic\n   * for determining the default state is colocated with the Tools component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Tools drawer. It will set the Tools state with the\n   * useControllable hook and also fire the onToolsChange function to\n   * emit the state change.\n   */\n\n  var toolsWidth = (_d = props.toolsWidth) !== null && _d !== void 0 ? _d : 290;\n  var hasDefaultToolsWidth = props.toolsWidth === undefined;\n\n  var _l = useControllable(controlledToolsOpen, props.onToolsChange, isMobile ? false : contentTypeDefaults.toolsOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  }),\n      _m = _l[0],\n      isToolsOpen = _m === void 0 ? false : _m,\n      setIsToolsOpen = _l[1];\n\n  var handleToolsClick = useCallback(function handleToolsChange(isOpen) {\n    setIsToolsOpen(isOpen);\n    fireNonCancelableEvent(props.onToolsChange, {\n      open: isOpen\n    });\n  }, [props.onToolsChange, setIsToolsOpen]);\n  var navigationVisible = !navigationHide && isNavigationOpen;\n  var toolsVisible = !toolsHide && isToolsOpen;\n  var isAnyPanelOpen = navigationVisible || toolsVisible;\n  /**\n   * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n   * that consumes 100% of the viewport height and width. The body content could potentially\n   * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n   * added to the document body that sets overflow to hidden.\n   */\n\n  useEffect(function handleBodyScroll() {\n    if (isMobile && (isNavigationOpen || isToolsOpen)) {\n      document.body.classList.add(styles['block-body-scroll']);\n    } else {\n      document.body.classList.remove(styles['block-body-scroll']);\n    } // Ensure the CSS class is removed from the body on side effect cleanup\n\n\n    return function cleanup() {\n      document.body.classList.remove(styles['block-body-scroll']);\n    };\n  }, [isMobile, isNavigationOpen, isToolsOpen]);\n  /**\n   * The useImperativeHandle hook in conjunction with the forwardRef function\n   * in the AppLayout component definition expose the following callable\n   * functions to component consumers when they put a ref as a property on\n   * their component implementation.\n   */\n\n  useImperativeHandle(forwardRef, function createImperativeHandle() {\n    return {\n      closeNavigationIfNecessary: function () {\n        isMobile && handleNavigationClick(false);\n      },\n      openTools: function () {\n        handleToolsClick(true);\n      }\n    };\n  }, [isMobile, handleNavigationClick, handleToolsClick]);\n  /**\n   * Query the DOM for the header and footer elements based on the selectors provided\n   * by the properties and pass the heights to the custom property definitions.\n   */\n\n  var _o = useState(0),\n      headerHeight = _o[0],\n      setHeaderHeight = _o[1];\n\n  var getHeader = useCallback(function () {\n    return document.querySelector(headerSelector);\n  }, [headerSelector]);\n  useResizeObserver(getHeader, function (entry) {\n    return setHeaderHeight(entry.borderBoxHeight);\n  });\n\n  var _p = useState(0),\n      footerHeight = _p[0],\n      setFooterHeight = _p[1];\n\n  var getFooter = useCallback(function () {\n    return document.querySelector(footerSelector);\n  }, [footerSelector]);\n  useResizeObserver(getFooter, function (entry) {\n    return setFooterHeight(entry.borderBoxHeight);\n  });\n  /**\n   * Set the default values for the minimum and maximum Split Panel width when it is\n   * in the side position. The useLayoutEffect will compute the available space in the\n   * DOM for the Split Panel given the current state. The minimum and maximum\n   * widths will potentially trigger a side effect that will put the Split Panel into\n   * a forced position on the bottom.\n   */\n\n  var splitPanelMinWidth = 280;\n\n  var _q = useState(splitPanelMinWidth),\n      splitPanelMaxWidth = _q[0],\n      setSplitPanelMaxWidth = _q[1];\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Split Panel. By default\n   * the Split Panel should always be closed on page load.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the click events that will change the state of the SplitPanel\n   * to open or closed given the current state. It will set the isSplitPanelOpen\n   * controlled state and fire the onSplitPanelToggle event.\n   */\n\n\n  var _r = useControllable(props.splitPanelOpen, props.onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  }),\n      isSplitPanelOpen = _r[0],\n      setIsSplitPanelOpen = _r[1];\n\n  var handleSplitPanelClick = useCallback(function handleSplitPanelChange() {\n    setIsSplitPanelOpen(!isSplitPanelOpen);\n    fireNonCancelableEvent(props.onSplitPanelToggle, {\n      open: !isSplitPanelOpen\n    });\n  }, [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]);\n  /**\n   * The useControllable hook will manage the controlled or uncontrolled\n   * state of the splitPanelPreferences. By default the splitPanelPreferences\n   * is undefined. When set the object shape should have a single key to indicate\n   * either bottom or side position.\n   *\n   * The callback that will handle changes to the splitPanelPreferences\n   * object that will determine if the SplitPanel is rendered either on the\n   * bottom of the viewport or within the Tools container.\n   */\n\n  var _s = useControllable(props.splitPanelPreferences, props.onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  }),\n      splitPanelPreferences = _s[0],\n      setSplitPanelPreferences = _s[1];\n  /**\n   * The Split Panel will be in forced (bottom) position if the defined minimum width is\n   * greater than the maximum width. In other words, the maximum width is the currently\n   * available horizontal space based on all other components that are rendered. If the\n   * minimum width exceeds this value then there is not enough horizontal space and we must\n   * force it to the bottom position.\n   */\n\n\n  var _t = useState(false),\n      isSplitPanelForcedPosition = _t[0],\n      setSplitPanelForcedPosition = _t[1];\n\n  var splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n  useLayoutEffect(function handleSplitPanelForcePosition() {\n    setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);\n  }, [splitPanelMaxWidth, splitPanelMinWidth]);\n  /**\n   * The useControllable hook will set the default size of the SplitPanel based\n   * on the default position set in the splitPanelPreferences. The logic for the\n   * default size is contained in the SplitPanel component. The splitPanelControlledSize\n   * will be bound to the size property in the SplitPanel context for rendering.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the resize events that will change the size of the SplitPanel.\n   * It will set the splitPanelControlledSize controlled state and fire the\n   * onSplitPanelResize event.\n   */\n\n  var _u = useState(0),\n      splitPanelReportedSize = _u[0],\n      setSplitPanelReportedSize = _u[1];\n\n  var _v = useControllable(props.splitPanelSize, props.onSplitPanelResize, getSplitPanelDefaultSize(splitPanelPosition), {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  }),\n      splitPanelSize = _v[0],\n      setSplitPanelSize = _v[1];\n\n  var handleSplitPanelResize = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelSize(detail.size);\n    fireNonCancelableEvent(props.onSplitPanelResize, detail);\n  }, [props.onSplitPanelResize, setSplitPanelSize]);\n  var handleSplitPanelPreferencesChange = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelPreferences(detail);\n    fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n  }, [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]);\n  /**\n   * The Layout element is not necessarily synonymous with the client\n   * viewport width. There can be content in the horizontal viewport\n   * that exists on either side of the AppLayout. This resize observer\n   * will set the custom property of the Layout element width that\n   * is used for various horizontal constraints such as the maximum\n   * allowed width of the Tools container.\n   *\n   * The offsetLeft of the Main will return the distance that the\n   * Main element has from the left edge of the Layout component.\n   * The offsetLeft value can vary based on the presence and state\n   * of the Navigation as well as content gaps in the grid definition.\n   * This value is used to determine the max width constraint calculation\n   * for the Tools container.\n   */\n\n  var _w = useContainerQuery(function (rect) {\n    return rect.width;\n  }),\n      layoutContainerQuery = _w[0],\n      layoutElement = _w[1];\n\n  var layoutWidth = layoutContainerQuery !== null && layoutContainerQuery !== void 0 ? layoutContainerQuery : 0;\n  var mainElement = useRef(null);\n\n  var _x = useState(0),\n      mainOffsetLeft = _x[0],\n      setMainOffsetLeft = _x[1];\n\n  useLayoutEffect(function handleMainOffsetLeft() {\n    var _a, _b;\n\n    setMainOffsetLeft((_b = (_a = mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) === null || _a === void 0 ? void 0 : _a.offsetLeft) !== null && _b !== void 0 ? _b : 0);\n  }, [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]);\n  useLayoutEffect(function handleSplitPanelMaxWidth() {\n    /**\n     * Warning! This is a hack! In order to accurately calculate if there is adequate\n     * horizontal space for the Split Panel to be in the side position we need two values\n     * that are not available in JavaScript.\n     *\n     * The first is the the content gap on the right which is stored in a design token\n     * and applied in the Layout CSS:\n     *\n     *  $contentGapRight: #{awsui.$space-scaled-2x-xxxl};\n     *\n     * The second is the width of the element that has the circular buttons for the\n     * Tools and Split Panel. This could be suppressed given the state of the Tools\n     * drawer returning a zero value. It would, however, be rendered if the Split Panel\n     * were to move into the side position. This is calculated in the Tools CSS and\n     * the Trigger button CSS with design tokens:\n     *\n     * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n     * width: awsui.$space-layout-toggle-diameter;\n     *\n     * These values will be defined below as static integers that are rough approximations\n     * of their computed width when rendered in the DOM, but doubled to ensure adequate\n     * spacing for the Split Panel to be in side position.\n     */\n    var contentGapRight = 80; // Approximately 40px when rendered but doubled for safety\n\n    var toolsFormOffsetWidth = 160; // Approximately 80px when rendered but doubled for safety\n\n    var toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;\n    setSplitPanelMaxWidth(layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth);\n  }, [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]);\n  /**\n   * Because the notifications slot does not give us any direction insight into\n   * what the state of the child content is we need to have a mechanism for\n   * tracking the height of the notifications and whether or not it has content.\n   * The height of the notifications is an integer that will be used as a custom\n   * property on the Layout component to determine what the sticky offset should\n   * be if there are sticky notifications. This could be any number including\n   * zero based on how the child content renders. The hasNotificationsContent boolean\n   * is simply centralizing the logic of the notifications height being > 0 such\n   * that it is not repeated in various components (such as AppBar) that need to\n   * know if the notifications slot is empty.\n   */\n\n  var _y = useContainerQuery(function (rect) {\n    return rect.height;\n  }),\n      notificationsContainerQuery = _y[0],\n      notificationsElement = _y[1];\n\n  var _z = useState(0),\n      notificationsHeight = _z[0],\n      setNotificationsHeight = _z[1];\n\n  var _0 = useState(false),\n      hasNotificationsContent = _0[0],\n      setHasNotificationsContent = _0[1];\n\n  useEffect(function handleNotificationsContent() {\n    setNotificationsHeight(notificationsContainerQuery !== null && notificationsContainerQuery !== void 0 ? notificationsContainerQuery : 0);\n    setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);\n  }, [notificationsContainerQuery]);\n  /**\n   * The offsetBottom value is used to determine the distance from the bottom of the\n   * viewport a sticky element should be placed. A non-zero value means that there\n   * is either a footer outside of the AppLayout, a SplitPanel in the bottom position\n   * within the AppLayout, or both.\n   */\n\n  var _1 = useState(0),\n      offsetBottom = _1[0],\n      setOffsetBottom = _1[1];\n\n  return React.createElement(AppLayoutContext.Provider, {\n    value: __assign(__assign(__assign({}, defaults), props), {\n      contentType: contentType,\n      dynamicOverlapHeight: dynamicOverlapHeight,\n      headerHeight: headerHeight,\n      footerHeight: footerHeight,\n      hasDefaultToolsWidth: hasDefaultToolsWidth,\n      handleNavigationClick: handleNavigationClick,\n      handleSplitPanelClick: handleSplitPanelClick,\n      handleSplitPanelPreferencesChange: handleSplitPanelPreferencesChange,\n      handleSplitPanelResize: handleSplitPanelResize,\n      handleToolsClick: handleToolsClick,\n      hasNotificationsContent: hasNotificationsContent,\n      isAnyPanelOpen: isAnyPanelOpen,\n      isMobile: isMobile,\n      isNavigationOpen: isNavigationOpen !== null && isNavigationOpen !== void 0 ? isNavigationOpen : false,\n      isSplitPanelForcedPosition: isSplitPanelForcedPosition,\n      isSplitPanelOpen: isSplitPanelOpen,\n      isToolsOpen: isToolsOpen,\n      layoutElement: layoutElement,\n      layoutWidth: layoutWidth,\n      mainElement: mainElement,\n      mainOffsetLeft: mainOffsetLeft,\n      maxContentWidth: maxContentWidth,\n      minContentWidth: minContentWidth,\n      navigationHide: navigationHide,\n      notificationsElement: notificationsElement,\n      notificationsHeight: notificationsHeight,\n      offsetBottom: offsetBottom,\n      setDynamicOverlapHeight: setDynamicOverlapHeight,\n      setOffsetBottom: setOffsetBottom,\n      setSplitPanelReportedSize: setSplitPanelReportedSize,\n      splitPanelMaxWidth: splitPanelMaxWidth,\n      splitPanelMinWidth: splitPanelMinWidth,\n      splitPanelPosition: splitPanelPosition,\n      splitPanelPreferences: splitPanelPreferences,\n      splitPanelReportedSize: splitPanelReportedSize,\n      splitPanelSize: splitPanelSize,\n      toolsHide: toolsHide,\n      toolsOpen: isToolsOpen,\n      toolsWidth: toolsWidth\n    })\n  }, children);\n});","map":{"version":3,"mappings":"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","names":["React","createContext","createRef","useCallback","useEffect","useLayoutEffect","useImperativeHandle","useRef","useState","fireNonCancelableEvent","getSplitPanelPosition","useControllable","useMobile","useContainerQuery","useResizeObserver","getSplitPanelDefaultSize","styles","isDevelopment","warnOnce","applyDefaults","defaults","breadcrumbs","content","contentHeader","contentType","disableBodyScroll","disableContentHeaderOverlap","disableContentPaddings","dynamicOverlapHeight","headerHeight","footerHeight","handleNavigationClick","value","handleSplitPanelClick","handleSplitPanelPreferencesChange","handleSplitPanelResize","handleToolsClick","hasDefaultToolsWidth","hasNotificationsContent","isAnyPanelOpen","isMobile","isNavigationOpen","isSplitPanelForcedPosition","isSplitPanelOpen","isToolsOpen","layoutElement","layoutWidth","mainElement","mainOffsetLeft","maxContentWidth","minContentWidth","navigation","navigationHide","navigationOpen","notifications","notificationsElement","notificationsHeight","offsetBottom","onNavigationChange","onSplitPanelResize","onSplitPanelToggle","onSplitPanelPreferencesChange","setDynamicOverlapHeight","setIsNavigationOpen","setIsToolsOpen","setOffsetBottom","setSplitPanelReportedSize","splitPanelMaxWidth","splitPanelMinWidth","splitPanelOpen","splitPanelPosition","splitPanelPreferences","position","splitPanelReportedSize","splitPanelSize","stickyNotifications","tools","AppLayoutContext","AppLayoutProvider","forwardRef","_a","controlledToolsOpen","controlledNavigationOpen","_e","_f","headerSelector","_g","footerSelector","children","props","toolsHide","geckoMaxCssLength","halfGeckoMaxCssLength","_b","_c","contentTypeDefaults","componentName","controlledProp","changeHandler","_k","handleNavigationChange","isOpen","open","toolsWidth","_d","undefined","onToolsChange","toolsOpen","_m","handleToolsChange","navigationVisible","toolsVisible","handleBodyScroll","document","body","classList","add","remove","cleanup","createImperativeHandle","closeNavigationIfNecessary","openTools","setHeaderHeight","getHeader","querySelector","entry","borderBoxHeight","setFooterHeight","getFooter","setSplitPanelMaxWidth","setIsSplitPanelOpen","handleSplitPanelChange","setSplitPanelPreferences","setSplitPanelForcedPosition","handleSplitPanelForcePosition","setSplitPanelSize","detail","size","width","layoutContainerQuery","setMainOffsetLeft","handleMainOffsetLeft","current","offsetLeft","handleSplitPanelMaxWidth","contentGapRight","toolsFormOffsetWidth","toolsOffsetWidth","height","notificationsContainerQuery","setNotificationsHeight","setHasNotificationsContent","handleNotificationsContent","Provider"],"sourceRoot":"","sources":["../../../../src/app-layout/visual-refresh/context.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, {\n  createContext,\n  createRef,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport { AppLayoutProps } from '../interfaces';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { getSplitPanelPosition } from './split-panel';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useContainerQuery, useResizeObserver } from '../../internal/hooks/container-queries';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../../internal/is-development';\nimport { warnOnce } from '../../internal/logging';\nimport { applyDefaults } from '../defaults';\n\ninterface AppLayoutContextProps extends AppLayoutProps {\n  dynamicOverlapHeight: number;\n  handleSplitPanelClick: () => void;\n  handleNavigationClick: (isOpen: boolean) => void;\n  handleSplitPanelPreferencesChange: (detail: AppLayoutProps.SplitPanelPreferences) => void;\n  handleSplitPanelResize: (detail: { size: number }) => void;\n  handleToolsClick: (value: boolean) => void;\n  hasDefaultToolsWidth: boolean;\n  hasNotificationsContent: boolean;\n  isAnyPanelOpen: boolean;\n  isMobile: boolean;\n  isNavigationOpen: boolean;\n  isSplitPanelForcedPosition: boolean;\n  isSplitPanelOpen?: boolean;\n  isToolsOpen?: boolean;\n  layoutElement: React.Ref<HTMLElement>;\n  layoutWidth: number;\n  mainElement: React.Ref<HTMLDivElement>;\n  mainOffsetLeft: number;\n  notificationsElement: React.Ref<HTMLDivElement>;\n  notificationsHeight: number;\n  offsetBottom: number;\n  setDynamicOverlapHeight: (value: number) => void;\n  setIsNavigationOpen: (value: boolean) => void;\n  setIsToolsOpen: (value: boolean) => void;\n  setOffsetBottom: (value: number) => void;\n  setSplitPanelReportedSize: (value: number) => void;\n  headerHeight: number;\n  footerHeight: number;\n  splitPanelMaxWidth: number;\n  splitPanelMinWidth: number;\n  splitPanelPosition: AppLayoutProps.SplitPanelPosition;\n  splitPanelReportedSize: number;\n}\n\n// TODO simplify default params + typings\nconst defaults: AppLayoutContextProps = {\n  breadcrumbs: null,\n  content: null,\n  contentHeader: null,\n  contentType: 'default',\n  disableBodyScroll: false,\n  disableContentHeaderOverlap: false,\n  disableContentPaddings: false,\n  dynamicOverlapHeight: 0,\n  headerHeight: 0,\n  footerHeight: 0,\n  handleNavigationClick: (value: boolean) => value,\n  handleSplitPanelClick: () => {},\n  handleSplitPanelPreferencesChange: () => {},\n  handleSplitPanelResize: () => {},\n  handleToolsClick: (value: boolean) => value,\n  hasDefaultToolsWidth: true,\n  hasNotificationsContent: false,\n  isAnyPanelOpen: false,\n  isMobile: false,\n  isNavigationOpen: false,\n  isSplitPanelForcedPosition: false,\n  isSplitPanelOpen: false,\n  isToolsOpen: false,\n  // TODO: these refs are currently only instantiated once globally\n  layoutElement: createRef<HTMLElement>(),\n  layoutWidth: 0,\n  mainElement: createRef<HTMLDivElement>(),\n  mainOffsetLeft: 0,\n  maxContentWidth: 0,\n  minContentWidth: 280,\n  navigation: null,\n  navigationHide: false,\n  navigationOpen: false,\n  notifications: null,\n  notificationsElement: createRef<HTMLDivElement>(),\n  notificationsHeight: 0,\n  offsetBottom: 0,\n  onNavigationChange: () => {},\n  onSplitPanelResize: () => {},\n  onSplitPanelToggle: () => {},\n  onSplitPanelPreferencesChange: () => {},\n  setDynamicOverlapHeight: (value: number) => void value,\n  setIsNavigationOpen: (value: boolean) => value,\n  setIsToolsOpen: (value: boolean) => value,\n  setOffsetBottom: (value: number) => void value,\n  setSplitPanelReportedSize: (value: number) => void value,\n  splitPanelMaxWidth: 280,\n  splitPanelMinWidth: 280,\n  splitPanelOpen: false,\n  splitPanelPosition: 'bottom',\n  splitPanelPreferences: { position: 'bottom' },\n  splitPanelReportedSize: 0,\n  splitPanelSize: 0,\n  stickyNotifications: false,\n  tools: null,\n};\n\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\nexport const AppLayoutContext = createContext({ ...defaults });\n\ntype AppLayoutProviderProps = AppLayoutProps & {\n  children: React.ReactNode;\n};\n\nexport const AppLayoutProvider = React.forwardRef(\n  (\n    {\n      toolsHide,\n      toolsOpen: controlledToolsOpen,\n      navigationHide,\n      navigationOpen: controlledNavigationOpen,\n      contentType = 'default',\n      headerSelector = '#b #h',\n      footerSelector = '#b #h',\n      children,\n      ...props\n    }: AppLayoutProviderProps,\n    forwardRef: React.Ref<AppLayoutProps.Ref>\n  ) => {\n    const isMobile = useMobile();\n\n    if (isDevelopment) {\n      if (controlledToolsOpen && toolsHide) {\n        warnOnce(\n          'AppLayout',\n          `You have enabled both the \\`toolsOpen\\` prop and the \\`toolsHide\\` prop. This is not supported. Set \\`toolsOpen\\` to \\`false\\` when you set \\`toolsHide\\` to \\`true\\`.`\n        );\n      }\n    }\n\n    /**\n     * The overlap height has a default set in CSS but can also be dynamically overridden\n     * for content types (such as Table and Wizard) that have variable size content in the overlap.\n     */\n    const [dynamicOverlapHeight, setDynamicOverlapHeight] = useState(0);\n\n    /**\n     * Set the default values for minimum and maximum content width.\n     */\n    const geckoMaxCssLength = ((1 << 30) - 1) / 60;\n    const halfGeckoMaxCssLength = geckoMaxCssLength / 2;\n    // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n    // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n    const maxContentWidth =\n      props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength\n        ? halfGeckoMaxCssLength\n        : props.maxContentWidth ?? 0;\n    const minContentWidth = props.minContentWidth ?? 280;\n\n    /**\n     * Determine the default state of the Navigation and Tools drawers.\n     * Mobile viewports should be closed by default under all circumstances.\n     * If the navigationOpen prop has been set then that should take precedence\n     * over the contentType prop. Desktop viewports that do not have the\n     * navigationOpen or contentType props set will use the default contentType.\n     */\n    const contentTypeDefaults = applyDefaults(contentType, { maxContentWidth, minContentWidth }, true);\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Navigation drawer. The logic\n     * for determining the default state is colocated with the Navigation component.\n     *\n     * The callback that will be passed to the Navigation and AppBar\n     * components to handle the click events that will change the state\n     * of the Navigation drawer. It will set the Navigation state with the\n     * useControllable hook and also fire the onNavigationChange function to\n     * emit the state change.\n     */\n    const [isNavigationOpen = false, setIsNavigationOpen] = useControllable(\n      controlledNavigationOpen,\n      props.onNavigationChange,\n      isMobile ? false : contentTypeDefaults.navigationOpen,\n      { componentName: 'AppLayout', controlledProp: 'navigationOpen', changeHandler: 'onNavigationChange' }\n    );\n\n    const handleNavigationClick = useCallback(\n      function handleNavigationChange(isOpen: boolean) {\n        setIsNavigationOpen(isOpen);\n        fireNonCancelableEvent(props.onNavigationChange, { open: isOpen });\n      },\n      [props.onNavigationChange, setIsNavigationOpen]\n    );\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Tools drawer. The logic\n     * for determining the default state is colocated with the Tools component.\n     *\n     * The callback that will be passed to the Navigation and AppBar\n     * components to handle the click events that will change the state\n     * of the Tools drawer. It will set the Tools state with the\n     * useControllable hook and also fire the onToolsChange function to\n     * emit the state change.\n     */\n    const toolsWidth = props.toolsWidth ?? 290;\n    const hasDefaultToolsWidth = props.toolsWidth === undefined;\n\n    const [isToolsOpen = false, setIsToolsOpen] = useControllable(\n      controlledToolsOpen,\n      props.onToolsChange,\n      isMobile ? false : contentTypeDefaults.toolsOpen,\n      { componentName: 'AppLayout', controlledProp: 'toolsOpen', changeHandler: 'onToolsChange' }\n    );\n\n    const handleToolsClick = useCallback(\n      function handleToolsChange(isOpen: boolean) {\n        setIsToolsOpen(isOpen);\n        fireNonCancelableEvent(props.onToolsChange, { open: isOpen });\n      },\n      [props.onToolsChange, setIsToolsOpen]\n    );\n\n    const navigationVisible = !navigationHide && isNavigationOpen;\n    const toolsVisible = !toolsHide && isToolsOpen;\n    const isAnyPanelOpen = navigationVisible || toolsVisible;\n\n    /**\n     * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n     * that consumes 100% of the viewport height and width. The body content could potentially\n     * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n     * added to the document body that sets overflow to hidden.\n     */\n    useEffect(\n      function handleBodyScroll() {\n        if (isMobile && (isNavigationOpen || isToolsOpen)) {\n          document.body.classList.add(styles['block-body-scroll']);\n        } else {\n          document.body.classList.remove(styles['block-body-scroll']);\n        }\n\n        // Ensure the CSS class is removed from the body on side effect cleanup\n        return function cleanup() {\n          document.body.classList.remove(styles['block-body-scroll']);\n        };\n      },\n      [isMobile, isNavigationOpen, isToolsOpen]\n    );\n\n    /**\n     * The useImperativeHandle hook in conjunction with the forwardRef function\n     * in the AppLayout component definition expose the following callable\n     * functions to component consumers when they put a ref as a property on\n     * their component implementation.\n     */\n    useImperativeHandle(\n      forwardRef,\n      function createImperativeHandle() {\n        return {\n          closeNavigationIfNecessary: function () {\n            isMobile && handleNavigationClick(false);\n          },\n          openTools: function () {\n            handleToolsClick(true);\n          },\n        };\n      },\n      [isMobile, handleNavigationClick, handleToolsClick]\n    );\n\n    /**\n     * Query the DOM for the header and footer elements based on the selectors provided\n     * by the properties and pass the heights to the custom property definitions.\n     */\n    const [headerHeight, setHeaderHeight] = useState(0);\n    const getHeader = useCallback(() => document.querySelector(headerSelector), [headerSelector]);\n    useResizeObserver(getHeader, entry => setHeaderHeight(entry.borderBoxHeight));\n\n    const [footerHeight, setFooterHeight] = useState(0);\n    const getFooter = useCallback(() => document.querySelector(footerSelector), [footerSelector]);\n    useResizeObserver(getFooter, entry => setFooterHeight(entry.borderBoxHeight));\n\n    /**\n     * Set the default values for the minimum and maximum Split Panel width when it is\n     * in the side position. The useLayoutEffect will compute the available space in the\n     * DOM for the Split Panel given the current state. The minimum and maximum\n     * widths will potentially trigger a side effect that will put the Split Panel into\n     * a forced position on the bottom.\n     */\n    const splitPanelMinWidth = 280;\n    const [splitPanelMaxWidth, setSplitPanelMaxWidth] = useState(splitPanelMinWidth);\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Split Panel. By default\n     * the Split Panel should always be closed on page load.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the click events that will change the state of the SplitPanel\n     * to open or closed given the current state. It will set the isSplitPanelOpen\n     * controlled state and fire the onSplitPanelToggle event.\n     */\n    const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(\n      props.splitPanelOpen,\n      props.onSplitPanelToggle,\n      false,\n      { componentName: 'AppLayout', controlledProp: 'splitPanelOpen', changeHandler: 'onSplitPanelToggle' }\n    );\n\n    const handleSplitPanelClick = useCallback(\n      function handleSplitPanelChange() {\n        setIsSplitPanelOpen(!isSplitPanelOpen);\n        fireNonCancelableEvent(props.onSplitPanelToggle, { open: !isSplitPanelOpen });\n      },\n      [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]\n    );\n\n    /**\n     * The useControllable hook will manage the controlled or uncontrolled\n     * state of the splitPanelPreferences. By default the splitPanelPreferences\n     * is undefined. When set the object shape should have a single key to indicate\n     * either bottom or side position.\n     *\n     * The callback that will handle changes to the splitPanelPreferences\n     * object that will determine if the SplitPanel is rendered either on the\n     * bottom of the viewport or within the Tools container.\n     */\n    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(\n      props.splitPanelPreferences,\n      props.onSplitPanelPreferencesChange,\n      undefined,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelPreferences',\n        changeHandler: 'onSplitPanelPreferencesChange',\n      }\n    );\n\n    /**\n     * The Split Panel will be in forced (bottom) position if the defined minimum width is\n     * greater than the maximum width. In other words, the maximum width is the currently\n     * available horizontal space based on all other components that are rendered. If the\n     * minimum width exceeds this value then there is not enough horizontal space and we must\n     * force it to the bottom position.\n     */\n    const [isSplitPanelForcedPosition, setSplitPanelForcedPosition] = useState(false);\n    const splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n\n    useLayoutEffect(\n      function handleSplitPanelForcePosition() {\n        setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);\n      },\n      [splitPanelMaxWidth, splitPanelMinWidth]\n    );\n\n    /**\n     * The useControllable hook will set the default size of the SplitPanel based\n     * on the default position set in the splitPanelPreferences. The logic for the\n     * default size is contained in the SplitPanel component. The splitPanelControlledSize\n     * will be bound to the size property in the SplitPanel context for rendering.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the resize events that will change the size of the SplitPanel.\n     * It will set the splitPanelControlledSize controlled state and fire the\n     * onSplitPanelResize event.\n     */\n    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n\n    const [splitPanelSize, setSplitPanelSize] = useControllable(\n      props.splitPanelSize,\n      props.onSplitPanelResize,\n      getSplitPanelDefaultSize(splitPanelPosition),\n      { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }\n    );\n\n    const handleSplitPanelResize = useCallback(\n      function handleSplitPanelChange(detail: { size: number }) {\n        setSplitPanelSize(detail.size);\n        fireNonCancelableEvent(props.onSplitPanelResize, detail);\n      },\n      [props.onSplitPanelResize, setSplitPanelSize]\n    );\n\n    const handleSplitPanelPreferencesChange = useCallback(\n      function handleSplitPanelChange(detail: AppLayoutProps.SplitPanelPreferences) {\n        setSplitPanelPreferences(detail);\n        fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n      },\n      [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]\n    );\n\n    /**\n     * The Layout element is not necessarily synonymous with the client\n     * viewport width. There can be content in the horizontal viewport\n     * that exists on either side of the AppLayout. This resize observer\n     * will set the custom property of the Layout element width that\n     * is used for various horizontal constraints such as the maximum\n     * allowed width of the Tools container.\n     *\n     * The offsetLeft of the Main will return the distance that the\n     * Main element has from the left edge of the Layout component.\n     * The offsetLeft value can vary based on the presence and state\n     * of the Navigation as well as content gaps in the grid definition.\n     * This value is used to determine the max width constraint calculation\n     * for the Tools container.\n     */\n    const [layoutContainerQuery, layoutElement] = useContainerQuery(rect => rect.width);\n    const layoutWidth = layoutContainerQuery ?? 0;\n\n    const mainElement = useRef<HTMLDivElement>(null);\n    const [mainOffsetLeft, setMainOffsetLeft] = useState(0);\n\n    useLayoutEffect(\n      function handleMainOffsetLeft() {\n        setMainOffsetLeft(mainElement?.current?.offsetLeft ?? 0);\n      },\n      [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]\n    );\n\n    useLayoutEffect(\n      function handleSplitPanelMaxWidth() {\n        /**\n         * Warning! This is a hack! In order to accurately calculate if there is adequate\n         * horizontal space for the Split Panel to be in the side position we need two values\n         * that are not available in JavaScript.\n         *\n         * The first is the the content gap on the right which is stored in a design token\n         * and applied in the Layout CSS:\n         *\n         *  $contentGapRight: #{awsui.$space-scaled-2x-xxxl};\n         *\n         * The second is the width of the element that has the circular buttons for the\n         * Tools and Split Panel. This could be suppressed given the state of the Tools\n         * drawer returning a zero value. It would, however, be rendered if the Split Panel\n         * were to move into the side position. This is calculated in the Tools CSS and\n         * the Trigger button CSS with design tokens:\n         *\n         * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n         * width: awsui.$space-layout-toggle-diameter;\n         *\n         * These values will be defined below as static integers that are rough approximations\n         * of their computed width when rendered in the DOM, but doubled to ensure adequate\n         * spacing for the Split Panel to be in side position.\n         */\n        const contentGapRight = 80; // Approximately 40px when rendered but doubled for safety\n        const toolsFormOffsetWidth = 160; // Approximately 80px when rendered but doubled for safety\n        const toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;\n\n        setSplitPanelMaxWidth(\n          layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth\n        );\n      },\n      [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]\n    );\n\n    /**\n     * Because the notifications slot does not give us any direction insight into\n     * what the state of the child content is we need to have a mechanism for\n     * tracking the height of the notifications and whether or not it has content.\n     * The height of the notifications is an integer that will be used as a custom\n     * property on the Layout component to determine what the sticky offset should\n     * be if there are sticky notifications. This could be any number including\n     * zero based on how the child content renders. The hasNotificationsContent boolean\n     * is simply centralizing the logic of the notifications height being > 0 such\n     * that it is not repeated in various components (such as AppBar) that need to\n     * know if the notifications slot is empty.\n     */\n    const [notificationsContainerQuery, notificationsElement] = useContainerQuery(rect => rect.height);\n    const [notificationsHeight, setNotificationsHeight] = useState(0);\n    const [hasNotificationsContent, setHasNotificationsContent] = useState(false);\n\n    useEffect(\n      function handleNotificationsContent() {\n        setNotificationsHeight(notificationsContainerQuery ?? 0);\n        setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);\n      },\n      [notificationsContainerQuery]\n    );\n\n    /**\n     * The offsetBottom value is used to determine the distance from the bottom of the\n     * viewport a sticky element should be placed. A non-zero value means that there\n     * is either a footer outside of the AppLayout, a SplitPanel in the bottom position\n     * within the AppLayout, or both.\n     */\n    const [offsetBottom, setOffsetBottom] = useState(0);\n\n    return (\n      <AppLayoutContext.Provider\n        value={{\n          ...defaults,\n          ...props,\n          contentType,\n          dynamicOverlapHeight,\n          headerHeight,\n          footerHeight,\n          hasDefaultToolsWidth,\n          handleNavigationClick,\n          handleSplitPanelClick,\n          handleSplitPanelPreferencesChange,\n          handleSplitPanelResize,\n          handleToolsClick,\n          hasNotificationsContent,\n          isAnyPanelOpen,\n          isMobile,\n          isNavigationOpen: isNavigationOpen ?? false,\n          isSplitPanelForcedPosition,\n          isSplitPanelOpen,\n          isToolsOpen,\n          layoutElement,\n          layoutWidth,\n          mainElement,\n          mainOffsetLeft,\n          maxContentWidth,\n          minContentWidth,\n          navigationHide,\n          notificationsElement,\n          notificationsHeight,\n          offsetBottom,\n          setDynamicOverlapHeight,\n          setOffsetBottom,\n          setSplitPanelReportedSize,\n          splitPanelMaxWidth,\n          splitPanelMinWidth,\n          splitPanelPosition,\n          splitPanelPreferences,\n          splitPanelReportedSize,\n          splitPanelSize,\n          toolsHide,\n          toolsOpen: isToolsOpen,\n          toolsWidth,\n        }}\n      >\n        {children}\n      </AppLayoutContext.Provider>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}