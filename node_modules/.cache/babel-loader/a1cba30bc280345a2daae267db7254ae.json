{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { matchFilteringProperty, matchOperator, matchOperatorPrefix, trimFirstSpace, trimStart } from './utils';\nexport var getQueryActions = function (query, onChange, inputRef, preventFocus) {\n  var tokens = query.tokens,\n      operation = query.operation;\n\n  var fireOnChange = function (tokens, operation) {\n    return fireNonCancelableEvent(onChange, {\n      tokens: tokens,\n      operation: operation\n    });\n  };\n\n  var setToken = function (index, newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n\n    if (newTokens && index < newTokens.length) {\n      newTokens[index] = newToken;\n    }\n\n    fireOnChange(newTokens, operation);\n  };\n\n  var removeToken = function (index) {\n    var _a;\n\n    var newTokens = tokens.filter(function (_, i) {\n      return i !== index;\n    });\n    fireOnChange(newTokens, operation);\n    preventFocus.current = true;\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  };\n\n  var removeAllTokens = function () {\n    var _a;\n\n    fireOnChange([], operation);\n    preventFocus.current = true;\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  };\n\n  var addToken = function (newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n\n    newTokens.push(newToken);\n    fireOnChange(newTokens, operation);\n  };\n\n  var setOperation = function (newOperation) {\n    fireOnChange(tokens, newOperation);\n  };\n\n  return {\n    setToken: setToken,\n    removeToken: removeToken,\n    removeAllTokens: removeAllTokens,\n    addToken: addToken,\n    setOperation: setOperation\n  };\n};\nexport var getAllowedOperators = function (property) {\n  var _a;\n\n  var operators = property.operators,\n      defaultOperator = property.defaultOperator;\n  var operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'];\n  var operatorSet = (_a = {}, _a[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = true, _a);\n  operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {\n    return operatorSet[op] = true;\n  });\n  return operatorOrder.filter(function (op) {\n    return operatorSet[op];\n  });\n};\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\n\nexport var parseText = function (filteringText, filteringProperties, disableFreeTextFiltering) {\n  if (filteringProperties === void 0) {\n    filteringProperties = [];\n  }\n\n  var negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);\n\n  if (!disableFreeTextFiltering && negatedGlobalQuery) {\n    return {\n      step: 'free-text',\n      operator: '!:',\n      value: negatedGlobalQuery[2]\n    };\n  }\n\n  var property = matchFilteringProperty(filteringProperties, filteringText);\n\n  if (!property) {\n    return {\n      step: 'free-text',\n      value: filteringText\n    };\n  }\n\n  var allowedOps = getAllowedOperators(property);\n  var textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  var operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n\n  if (operator) {\n    var operatorLastIndex = textWithoutProperty.indexOf(operator) + operator.length;\n    var textWithoutPropertyAndOperator = textWithoutProperty.slice(operatorLastIndex);\n    return {\n      step: 'property',\n      property: property,\n      operator: operator,\n      // We need to remove the first leading space in case the user presses space\n      // after the operator, for example: Owner: admin, will result in value of ` admin`\n      // and we need to remove the first space, if the user added any more spaces only the\n      // first one will be removed.\n      value: trimFirstSpace(textWithoutPropertyAndOperator)\n    };\n  }\n\n  var operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n\n  if (operatorPrefix !== null) {\n    return {\n      step: 'operator',\n      property: property,\n      operatorPrefix: operatorPrefix\n    };\n  }\n\n  return {\n    step: 'free-text',\n    value: filteringText\n  };\n};\nexport var getPropertyOptions = function (filteringProperty, filteringOptions) {\n  return filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.filter(function (option) {\n    return option.propertyKey === filteringProperty.key;\n  });\n};\nexport var getAllValueSuggestions = function (filteringOptions, filteringProperties, operator, i18nStrings, customGroupsText) {\n  if (operator === void 0) {\n    operator = '=';\n  }\n\n  var defaultGroup = {\n    label: i18nStrings.groupValuesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.forEach(function (filteringOption) {\n    var property = getPropertyByKey(filteringProperties, filteringOption.propertyKey); // given option refers to a non-existent filtering property\n\n    if (!property) {\n      return;\n    } // this option's filtering property does not support current operator\n\n\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n\n    if (property.group && !customGroups[property.group]) {\n      var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) {\n        return customGroup.group === property.group ? customGroup.values : acc;\n      }, '')) || '';\n      customGroups[property.group] = {\n        label: label,\n        options: []\n      };\n    }\n\n    var propertyGroup = property.group ? customGroups[property.group] : defaultGroup;\n    propertyGroup.options.push({\n      tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,\n      label: filteringOption.value,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '=')\n    });\n  });\n  return __spreadArray([defaultGroup], Object.keys(customGroups).map(function (group) {\n    return customGroups[group];\n  }), true);\n};\nexport var getPropertyByKey = function (filteringProperties, key) {\n  var propertyMap = filteringProperties.reduce(function (acc, property) {\n    acc[property.key] = property;\n    return acc;\n  }, {});\n  return propertyMap[key];\n};\n\nvar filteringPropertyToAutosuggestOption = function (filteringProperty) {\n  return {\n    value: filteringProperty.propertyLabel,\n    keepOpenOnSelect: true\n  };\n};\n\nexport function getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToOption) {\n  var defaultGroup = {\n    label: i18nStrings.groupPropertiesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringProperties.forEach(function (filteringProperty) {\n    var group = filteringProperty.group;\n    var optionsGroup = defaultGroup;\n\n    if (group) {\n      if (!customGroups[group]) {\n        var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) {\n          return customGroup.group === group ? customGroup.properties : acc;\n        }, '')) || '';\n        customGroups[group] = {\n          options: [],\n          label: label\n        };\n      }\n\n      optionsGroup = customGroups[group];\n    }\n\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  var defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  var customGroupsArray = Object.keys(customGroups).map(function (groupKey) {\n    return customGroups[groupKey];\n  });\n  return __spreadArray(__spreadArray([], defaultGroupArray, true), customGroupsArray, true);\n}\nexport var getAutosuggestOptions = function (parsedText, filteringOptions, filteringProperties, customGroupsText, i18nStrings) {\n  switch (parsedText.step) {\n    case 'property':\n      {\n        var _a = parsedText.property,\n            propertyLabel_1 = _a.propertyLabel,\n            groupValuesLabel = _a.groupValuesLabel;\n        var options = getPropertyOptions(parsedText.property, filteringOptions);\n        return {\n          __filterText: parsedText.value,\n          options: [{\n            options: (options || []).map(function (_a) {\n              var value = _a.value;\n              return {\n                tokenValue: propertyLabel_1 + parsedText.operator + value,\n                label: value,\n                __labelPrefix: propertyLabel_1 + ' ' + parsedText.operator\n              };\n            }),\n            label: groupValuesLabel\n          }]\n        };\n      }\n\n    case 'operator':\n      {\n        return {\n          __filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n          options: __spreadArray(__spreadArray([], getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption), true), [{\n            options: getAllowedOperators(parsedText.property).map(function (value) {\n              return {\n                value: parsedText.property.propertyLabel + ' ' + value + ' ',\n                label: parsedText.property.propertyLabel + ' ' + value,\n                description: operatorToDescription(value, i18nStrings),\n                keepOpenOnSelect: true\n              };\n            }),\n            label: i18nStrings.operatorsText\n          }], false)\n        };\n      }\n\n    case 'free-text':\n      {\n        var needsValueSuggestions = !!parsedText.value;\n        var needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n        return {\n          __filterText: parsedText.value,\n          options: __spreadArray(__spreadArray([], needsPropertySuggestions ? getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption) : [], true), needsValueSuggestions ? getAllValueSuggestions(filteringOptions, filteringProperties, parsedText.operator, i18nStrings, customGroupsText) : [], true)\n        };\n      }\n  }\n};\nexport var operatorToDescription = function (operator, i18nStrings) {\n  var _a;\n\n  var mapping = (_a = {}, _a['<'] = i18nStrings.operatorLessText, _a['<='] = i18nStrings.operatorLessOrEqualText, _a['>'] = i18nStrings.operatorGreaterText, _a['>='] = i18nStrings.operatorGreaterOrEqualText, _a[':'] = i18nStrings.operatorContainsText, _a['!:'] = i18nStrings.operatorDoesNotContainText, _a['='] = i18nStrings.operatorEqualsText, _a['!='] = i18nStrings.operatorDoesNotEqualText, _a);\n  return mapping[operator];\n};","map":{"version":3,"mappings":"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","names":["fireNonCancelableEvent","matchFilteringProperty","matchOperator","matchOperatorPrefix","trimFirstSpace","trimStart","getQueryActions","query","onChange","inputRef","preventFocus","operation","fireOnChange","tokens","setToken","index","newToken","newTokens","length","removeToken","filter","_","i","current","_a","focus","removeAllTokens","addToken","push","setOperation","newOperation","getAllowedOperators","property","defaultOperator","operatorOrder","operatorSet","operators","forEach","op","parseText","filteringText","filteringProperties","disableFreeTextFiltering","negatedGlobalQuery","exec","step","operator","value","allowedOps","textWithoutProperty","substring","propertyLabel","operatorLastIndex","indexOf","textWithoutPropertyAndOperator","slice","operatorPrefix","getPropertyOptions","filteringProperty","filteringOptions","propertyKey","key","getAllValueSuggestions","i18nStrings","customGroupsText","defaultGroup","label","groupValuesText","options","customGroups","getPropertyByKey","filteringOption","group","reduce","acc","customGroup","values","propertyGroup","tokenValue","__labelPrefix","Object","keys","map","propertyMap","filteringPropertyToAutosuggestOption","keepOpenOnSelect","getPropertySuggestions","filteringPropertyToOption","groupPropertiesText","optionsGroup","properties","defaultGroupArray","customGroupsArray","groupKey","getAutosuggestOptions","parsedText","propertyLabel_1","groupValuesLabel","__filterText","description","operatorToDescription","operatorsText","needsValueSuggestions","needsPropertySuggestions","mapping","operatorLessText","operatorLessOrEqualText","operatorGreaterText","operatorGreaterOrEqualText","operatorContainsText","operatorDoesNotContainText","operatorEqualsText","operatorDoesNotEqualText"],"sourceRoot":"","sources":["../../../src/property-filter/controller.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PropertyFilterProps } from './interfaces';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { AutosuggestProps } from '../autosuggest/interfaces';\nimport { InputProps } from '../input/interfaces';\nimport { matchFilteringProperty, matchOperator, matchOperatorPrefix, trimFirstSpace, trimStart } from './utils';\n\nexport const getQueryActions = (\n  query: PropertyFilterProps['query'],\n  onChange: PropertyFilterProps['onChange'],\n  inputRef: React.RefObject<InputProps.Ref>,\n  preventFocus: React.MutableRefObject<boolean>\n) => {\n  const { tokens, operation } = query;\n  const fireOnChange = (tokens: readonly PropertyFilterProps.Token[], operation: PropertyFilterProps.JoinOperation) =>\n    fireNonCancelableEvent(onChange, { tokens, operation });\n  const setToken = (index: number, newToken: PropertyFilterProps.Token) => {\n    const newTokens = [...tokens];\n    if (newTokens && index < newTokens.length) {\n      newTokens[index] = newToken;\n    }\n    fireOnChange(newTokens, operation);\n  };\n  const removeToken = (index: number) => {\n    const newTokens = tokens.filter((_, i) => i !== index);\n    fireOnChange(newTokens, operation);\n    preventFocus.current = true;\n    inputRef.current?.focus();\n  };\n  const removeAllTokens = () => {\n    fireOnChange([], operation);\n    preventFocus.current = true;\n    inputRef.current?.focus();\n  };\n  const addToken = (newToken: PropertyFilterProps.Token) => {\n    const newTokens = [...tokens];\n    newTokens.push(newToken);\n    fireOnChange(newTokens, operation);\n  };\n  const setOperation = (newOperation: PropertyFilterProps.JoinOperation) => {\n    fireOnChange(tokens, newOperation);\n  };\n  return {\n    setToken,\n    removeToken,\n    removeAllTokens,\n    addToken,\n    setOperation,\n  };\n};\n\nexport type ParsedText =\n  | {\n      step: 'property';\n      property: PropertyFilterProps.FilteringProperty;\n      operator: PropertyFilterProps.ComparisonOperator;\n      value: string;\n    }\n  | { step: 'operator'; property: PropertyFilterProps.FilteringProperty; operatorPrefix: string }\n  | { step: 'free-text'; operator?: PropertyFilterProps.ComparisonOperator; value: string };\n\nexport const getAllowedOperators = (\n  property: PropertyFilterProps.FilteringProperty\n): PropertyFilterProps.ComparisonOperator[] => {\n  const { operators, defaultOperator } = property;\n  const operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'] as const;\n  const operatorSet: { [key: string]: true } = { [defaultOperator ?? '=']: true };\n  operators?.forEach(op => (operatorSet[op] = true));\n  return operatorOrder.filter(op => operatorSet[op]);\n};\n\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\nexport const parseText = (\n  filteringText: string,\n  filteringProperties: PropertyFilterProps['filteringProperties'] = [],\n  disableFreeTextFiltering: boolean\n): ParsedText => {\n  const negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);\n  if (!disableFreeTextFiltering && negatedGlobalQuery) {\n    return {\n      step: 'free-text',\n      operator: '!:',\n      value: negatedGlobalQuery[2],\n    };\n  }\n\n  const property = matchFilteringProperty(filteringProperties, filteringText);\n  if (!property) {\n    return {\n      step: 'free-text',\n      value: filteringText,\n    };\n  }\n\n  const allowedOps = getAllowedOperators(property);\n  const textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  const operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n  if (operator) {\n    const operatorLastIndex = textWithoutProperty.indexOf(operator) + operator.length;\n    const textWithoutPropertyAndOperator = textWithoutProperty.slice(operatorLastIndex);\n    return {\n      step: 'property',\n      property,\n      operator,\n      // We need to remove the first leading space in case the user presses space\n      // after the operator, for example: Owner: admin, will result in value of ` admin`\n      // and we need to remove the first space, if the user added any more spaces only the\n      // first one will be removed.\n      value: trimFirstSpace(textWithoutPropertyAndOperator),\n    };\n  }\n\n  const operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n  if (operatorPrefix !== null) {\n    return { step: 'operator', property, operatorPrefix };\n  }\n\n  return {\n    step: 'free-text',\n    value: filteringText,\n  };\n};\n\nexport const getPropertyOptions = (\n  filteringProperty: PropertyFilterProps.FilteringProperty,\n  filteringOptions: PropertyFilterProps['filteringOptions']\n) => {\n  return filteringOptions?.filter(option => option.propertyKey === filteringProperty.key);\n};\n\ninterface OptionGroup<T> {\n  label: string;\n  options: T[];\n}\n\ninterface ExtendedAutosuggestOption extends AutosuggestProps.Option {\n  tokenValue: string;\n}\n\nexport const getAllValueSuggestions = (\n  filteringOptions: PropertyFilterProps['filteringOptions'],\n  filteringProperties: PropertyFilterProps['filteringProperties'],\n  operator: PropertyFilterProps.ComparisonOperator | undefined = '=',\n  i18nStrings: Pick<PropertyFilterProps.I18nStrings, 'groupValuesText'>,\n  customGroupsText: PropertyFilterProps['customGroupsText']\n) => {\n  const defaultGroup: OptionGroup<ExtendedAutosuggestOption> = {\n    label: i18nStrings.groupValuesText,\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<ExtendedAutosuggestOption> } = {};\n  filteringOptions?.forEach(filteringOption => {\n    const property = getPropertyByKey(filteringProperties, filteringOption.propertyKey);\n    // given option refers to a non-existent filtering property\n    if (!property) {\n      return;\n    }\n    // this option's filtering property does not support current operator\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n    if (property.group && !customGroups[property.group]) {\n      const label =\n        customGroupsText?.reduce<string>(\n          (acc, customGroup) => (customGroup.group === property.group ? customGroup.values : acc),\n          ''\n        ) || '';\n      customGroups[property.group] = {\n        label,\n        options: [],\n      };\n    }\n    const propertyGroup = property.group ? customGroups[property.group] : defaultGroup;\n    propertyGroup.options.push({\n      tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,\n      label: filteringOption.value,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '='),\n    });\n  });\n  return [defaultGroup, ...Object.keys(customGroups).map(group => customGroups[group])];\n};\n\nexport const getPropertyByKey = (filteringProperties: PropertyFilterProps['filteringProperties'], key: string) => {\n  const propertyMap = filteringProperties.reduce<{ [K: string]: PropertyFilterProps.FilteringProperty }>(\n    (acc, property) => {\n      acc[property.key] = property;\n      return acc;\n    },\n    {}\n  );\n  return propertyMap[key] as PropertyFilterProps.FilteringProperty | undefined;\n};\n\nconst filteringPropertyToAutosuggestOption = (filteringProperty: PropertyFilterProps.FilteringProperty) => ({\n  value: filteringProperty.propertyLabel,\n  keepOpenOnSelect: true,\n});\n\nexport function getPropertySuggestions<T>(\n  filteringProperties: PropertyFilterProps['filteringProperties'],\n  customGroupsText: PropertyFilterProps['customGroupsText'],\n  i18nStrings: Pick<PropertyFilterProps['i18nStrings'], 'groupPropertiesText'>,\n  filteringPropertyToOption: (filteringProperty: PropertyFilterProps.FilteringProperty) => T\n) {\n  const defaultGroup: OptionGroup<T> = {\n    label: i18nStrings.groupPropertiesText,\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<T> } = {};\n\n  filteringProperties.forEach(filteringProperty => {\n    const { group } = filteringProperty;\n    let optionsGroup = defaultGroup;\n    if (group) {\n      if (!customGroups[group]) {\n        const label =\n          customGroupsText?.reduce<string>(\n            (acc, customGroup) => (customGroup.group === group ? customGroup.properties : acc),\n            ''\n          ) || '';\n        customGroups[group] = { options: [], label };\n      }\n      optionsGroup = customGroups[group];\n    }\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  const defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  const customGroupsArray = Object.keys(customGroups).map(groupKey => customGroups[groupKey]);\n  return [...defaultGroupArray, ...customGroupsArray];\n}\n\nexport type OperatorStrings =\n  | 'operatorLessText'\n  | 'operatorLessOrEqualText'\n  | 'operatorGreaterText'\n  | 'operatorGreaterOrEqualText'\n  | 'operatorContainsText'\n  | 'operatorDoesNotContainText'\n  | 'operatorEqualsText'\n  | 'operatorDoesNotEqualText';\nexport const getAutosuggestOptions = (\n  parsedText: ParsedText,\n  filteringOptions: PropertyFilterProps['filteringOptions'],\n  filteringProperties: PropertyFilterProps['filteringProperties'],\n  customGroupsText: PropertyFilterProps['customGroupsText'],\n  i18nStrings: Pick<\n    PropertyFilterProps['i18nStrings'],\n    'groupPropertiesText' | 'groupValuesText' | 'operatorsText' | OperatorStrings\n  >\n) => {\n  switch (parsedText.step) {\n    case 'property': {\n      const { propertyLabel, groupValuesLabel } = parsedText.property;\n      const options = getPropertyOptions(parsedText.property, filteringOptions);\n      return {\n        __filterText: parsedText.value,\n        options: [\n          {\n            options: (options || []).map(({ value }) => ({\n              tokenValue: propertyLabel + parsedText.operator + value,\n              label: value,\n              __labelPrefix: propertyLabel + ' ' + parsedText.operator,\n            })),\n            label: groupValuesLabel,\n          },\n        ],\n      };\n    }\n    case 'operator': {\n      return {\n        __filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n        options: [\n          ...getPropertySuggestions(\n            filteringProperties,\n            customGroupsText,\n            i18nStrings,\n            filteringPropertyToAutosuggestOption\n          ),\n          {\n            options: getAllowedOperators(parsedText.property).map(value => ({\n              value: parsedText.property.propertyLabel + ' ' + value + ' ',\n              label: parsedText.property.propertyLabel + ' ' + value,\n              description: operatorToDescription(value, i18nStrings),\n              keepOpenOnSelect: true,\n            })),\n            label: i18nStrings.operatorsText,\n          },\n        ],\n      };\n    }\n    case 'free-text': {\n      const needsValueSuggestions = !!parsedText.value;\n      const needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n      return {\n        __filterText: parsedText.value,\n        options: [\n          ...(needsPropertySuggestions\n            ? getPropertySuggestions(\n                filteringProperties,\n                customGroupsText,\n                i18nStrings,\n                filteringPropertyToAutosuggestOption\n              )\n            : []),\n          ...(needsValueSuggestions\n            ? getAllValueSuggestions(\n                filteringOptions,\n                filteringProperties,\n                parsedText.operator,\n                i18nStrings,\n                customGroupsText\n              )\n            : []),\n        ],\n      };\n    }\n  }\n};\n\nexport const operatorToDescription = (\n  operator: PropertyFilterProps.ComparisonOperator,\n  i18nStrings: Pick<PropertyFilterProps['i18nStrings'], OperatorStrings>\n) => {\n  const mapping: { [K in PropertyFilterProps.ComparisonOperator]: string } = {\n    ['<']: i18nStrings.operatorLessText,\n    ['<=']: i18nStrings.operatorLessOrEqualText,\n    ['>']: i18nStrings.operatorGreaterText,\n    ['>=']: i18nStrings.operatorGreaterOrEqualText,\n    [':']: i18nStrings.operatorContainsText,\n    ['!:']: i18nStrings.operatorDoesNotContainText,\n    ['=']: i18nStrings.operatorEqualsText,\n    ['!=']: i18nStrings.operatorDoesNotEqualText,\n  };\n  return mapping[operator];\n};\n"]},"metadata":{},"sourceType":"module"}