{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { padLeftZeros, insertAt } from './strings';\n\nvar MaskFormat =\n/** @class */\nfunction () {\n  function MaskFormat(_a) {\n    var separator = _a.separator,\n        _b = _a.inputSeparators,\n        inputSeparators = _b === void 0 ? [] : _b,\n        segments = _a.segments;\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n    this.inputSeparators = __spreadArray(__spreadArray([], inputSeparators, true), [separator], false);\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  MaskFormat.prototype.tryAppendSeparator = function (value) {\n    var withSeparator = \"\".concat(value).concat(this.separator);\n    return this.isValid(withSeparator) ? withSeparator : value;\n  };\n\n  MaskFormat.prototype.isSeparator = function (key) {\n    return this.inputSeparators.indexOf(key) !== -1;\n  };\n\n  MaskFormat.prototype.isValid = function (value) {\n    var _this = this;\n\n    var inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every(function (segmentValue, i) {\n      var segment = _this.segments[i]; // disallow empty segments\n\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      } // only allow numerals\n\n\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      } // disallow incomplete segments, except at end\n\n\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      } // limit numerical value\n\n\n      var intValue = parseInt(segmentValue, 10); // Handles values padded with 0s that are lost during parsing\n\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  };\n\n  MaskFormat.prototype.getValidValue = function (value) {\n    var validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  };\n\n  MaskFormat.prototype.autoComplete = function (value) {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    var _a = value.split(this.separator).reverse(),\n        lastSegmentValue = _a[0],\n        completeSegmentValues = _a.slice(1);\n\n    var lastSegment = this.segments[completeSegmentValues.length]; // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n\n    var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment); // recombine, and pad with extra segments for the full format\n\n    var partial = __spreadArray(__spreadArray([], completeSegmentValues.reverse(), true), [paddedLastSegmentValue], false);\n\n    while (partial.length < this.segments.length) {\n      var nextSegment = this.segments[partial.length];\n      var segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  };\n\n  MaskFormat.prototype.getSegmentValueWithAddition = function (position, value, enteredDigit) {\n    var segment = this.positionFormats[position];\n    var segmentValue = value.substr(segment.start, segment.length);\n    var segmentPosition = position - segment.start;\n    var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  };\n\n  MaskFormat.prototype.replaceDigitsWithZeroes = function (value, cursorStart, cursorEnd) {\n    var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart; // move selection forwards if it starts with a separator\n\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    } // first, insert zeros in a partial segment at beginning of selection\n\n\n    if (!this.isSegmentStart(cursorStart)) {\n      var segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    } // then loop through remaining segments, filling with zeros\n\n\n    var currentSegment;\n\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.handleSeparatorInput = function (value, position) {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      var segment = this.positionFormats[position];\n      var segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value: value,\n        position: value.length\n      };\n    }\n  };\n\n  MaskFormat.prototype.isCursorAtSeparator = function (position) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  };\n\n  MaskFormat.prototype.isSegmentStart = function (position) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  };\n\n  MaskFormat.prototype.getSegmentMaxValue = function (value, position) {\n    return this.positionFormats[position].max(value);\n  };\n\n  MaskFormat.prototype.getSegmentMinValue = function (value, position) {\n    return this.positionFormats[position].min;\n  };\n\n  MaskFormat.prototype.getMaxLength = function () {\n    var last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  };\n\n  MaskFormat.prototype.deleteSeparator = function (value, position) {\n    value = insertAt(value, '0', position - 2, position - 1);\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2\n    };\n  };\n\n  MaskFormat.prototype.deleteDigit = function (value, position) {\n    value = insertAt(value, '0', position - 1, position); // 23:59|: => backspace => 23:5|\n\n    var length = value.length;\n\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1\n    };\n  };\n\n  MaskFormat.prototype.correctMinMaxValues = function (value) {\n    var segment = this.positionFormats[0];\n\n    while (segment && value.length >= segment.end) {\n      var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      var segmentMax = segment.max(value);\n\n      if (segmentValue < segment.min) {\n        var toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n\n      segment = this.positionFormats[segment.end + 1];\n    }\n\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  };\n\n  MaskFormat.prototype.formatPastedText = function (text, value, cursorStart, cursorEnd) {\n    var keyArr = text.trim().split('');\n    var position = cursorStart;\n    var formattedValue = value; // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {\n      var key = keyArr_1[_i];\n\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      var result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  };\n\n  MaskFormat.prototype.processKey = function (initialValue, key, initialPosition) {\n    var value = initialValue;\n    var position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      var result = this.handleSeparatorInput(value, position);\n\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      var isCursorAtEnd = position === value.length;\n      var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      var segmentMaxValue = this.getSegmentMaxValue(value, position);\n      var segmentMinValue = this.getSegmentMinValue(value, position);\n      var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, \"0\".concat(key), position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value); // Move cursor in front of separator if behind after overwriting a character\n\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.padWithDefaultValue = function (segmentValue, segment) {\n    var defaultValue = (segment[\"default\"] || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  };\n\n  MaskFormat.prototype.enrichSegmentDefinitions = function (segments) {\n    this.positionFormats = {};\n    this.segments = [];\n    var position = 0;\n\n    var _loop_1 = function (segment) {\n      var max = segment.max;\n\n      var fullSegment = __assign(__assign({}, segment), {\n        max: typeof max === 'number' ? function () {\n          return max;\n        } : max,\n        start: position,\n        end: position + segment.length\n      });\n\n      this_1.segments.push(fullSegment); // insert this format segment for every char in the max value\n\n      for (var j = 0; j < fullSegment.length; j++) {\n        this_1.positionFormats[position++] = fullSegment;\n      } // skip a position for separator\n\n\n      position++;\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n      var segment = segments_1[_i];\n\n      _loop_1(segment);\n    }\n  };\n\n  return MaskFormat;\n}();\n\nexport default MaskFormat;","map":{"version":3,"mappings":"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","names":["padLeftZeros","insertAt","_a","separator","_b","inputSeparators","segments","positionFormats","__spreadArray","enrichSegmentDefinitions","MaskFormat","value","withSeparator","concat","isValid","key","indexOf","inputSegments","split","length","every","segmentValue","i","segment","_this","match","intValue","parseInt","min","max","validValue","tryAppendSeparator","substring","reverse","lastSegmentValue","completeSegmentValues","lastSegment","paddedLastSegmentValue","padWithDefaultValue","partial","nextSegment","push","join","correctMinMaxValues","position","enteredDigit","substr","start","segmentPosition","newValue","cursorStart","cursorEnd","isCursorAtSeparator","isSegmentStart","end","currentSegment","insertionEnd","Math","getMaxLength","undefined","last","slice","segmentMax","toInsert","toFixed","text","keyArr","trim","formattedValue","_i","result","processKey","initialValue","initialPosition","isSeparator","handleSeparatorInput","isCursorAtEnd","getSegmentValueWithAddition","segmentMaxValue","getSegmentMaxValue","segmentMinValue","getSegmentMinValue","firstDigitGreater","isValidPosition","exceedsMaxAtSegmentStart","defaultValue","fullSegment","this_1","j"],"sourceRoot":"","sources":["../../../../../../src/internal/components/masked-input/utils/mask-format.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros, insertAt } from './strings';\n\ninterface FormatSegment {\n  min: number;\n  max: number | ((value: string) => number);\n  length: number;\n  default?: number;\n}\n\ninterface FormatSegmentFull extends FormatSegment {\n  start: number;\n  max(value: string): number;\n  end: number;\n}\n\nexport interface MaskArgs {\n  separator: string;\n  inputSeparators?: Array<string>;\n  segments: Array<FormatSegment>;\n}\n\nexport interface ChangeResult {\n  value: string;\n  position: number;\n}\n\nclass MaskFormat {\n  separator: string;\n  private inputSeparators: Array<string>;\n  private segments: Array<FormatSegmentFull>;\n  private positionFormats: { [x: number]: FormatSegmentFull };\n\n  constructor({ separator, inputSeparators = [], segments }: MaskArgs) {\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n\n    this.inputSeparators = [...inputSeparators, separator];\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  tryAppendSeparator(value: string) {\n    const withSeparator = `${value}${this.separator}`;\n    return this.isValid(withSeparator) ? withSeparator : value;\n  }\n\n  isSeparator(key: string): boolean {\n    return this.inputSeparators.indexOf(key) !== -1;\n  }\n\n  isValid(value: string): boolean {\n    const inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every((segmentValue, i) => {\n      const segment = this.segments[i];\n\n      // disallow empty segments\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      // only allow numerals\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n      // disallow incomplete segments, except at end\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n      // limit numerical value\n      const intValue = parseInt(segmentValue, 10);\n\n      // Handles values padded with 0s that are lost during parsing\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n  }\n\n  getValidValue(value: string): string {\n    let validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  }\n\n  autoComplete(value: string): string {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    const [lastSegmentValue, ...completeSegmentValues] = value.split(this.separator).reverse();\n    const lastSegment = this.segments[completeSegmentValues.length];\n\n    // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n    const paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n\n    // recombine, and pad with extra segments for the full format\n    const partial = [...completeSegmentValues.reverse(), paddedLastSegmentValue];\n    while (partial.length < this.segments.length) {\n      const nextSegment = this.segments[partial.length];\n      const segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  }\n\n  getSegmentValueWithAddition(position: number, value: string, enteredDigit: string) {\n    const segment = this.positionFormats[position];\n    const segmentValue = value.substr(segment.start, segment.length);\n    const segmentPosition = position - segment.start;\n    const newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  }\n\n  replaceDigitsWithZeroes(value: string, cursorStart: number, cursorEnd: number): ChangeResult {\n    const position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n\n    // move selection forwards if it starts with a separator\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n\n    // first, insert zeros in a partial segment at beginning of selection\n    if (!this.isSegmentStart(cursorStart)) {\n      const segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n\n    // then loop through remaining segments, filling with zeros\n    let currentSegment: FormatSegmentFull;\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      const insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(\n        value,\n        padLeftZeros('', insertionEnd - currentSegment.start),\n        currentSegment.start,\n        insertionEnd\n      );\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n\n    return {\n      value,\n      position,\n    };\n  }\n\n  handleSeparatorInput(value: string, position: number): ChangeResult | void {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      const segment = this.positionFormats[position];\n      let segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value,\n        position: value.length,\n      };\n    }\n  }\n\n  isCursorAtSeparator(position: number) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  }\n\n  isSegmentStart(position: number) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  }\n\n  getSegmentMaxValue(value: string, position: number): number {\n    return this.positionFormats[position].max(value);\n  }\n\n  getSegmentMinValue(value: string, position: number): number {\n    return this.positionFormats[position].min;\n  }\n\n  getMaxLength() {\n    const last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  }\n\n  deleteSeparator(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 2, position - 1);\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2,\n    };\n  }\n\n  deleteDigit(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 1, position);\n\n    // 23:59|: => backspace => 23:5|\n    const length = value.length;\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1,\n    };\n  }\n\n  correctMinMaxValues(value: string): string {\n    let segment = this.positionFormats[0];\n    while (segment && value.length >= segment.end) {\n      const segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      const segmentMax = segment.max(value);\n      if (segmentValue < segment.min) {\n        let toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n      segment = this.positionFormats[segment.end + 1];\n    }\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  }\n\n  formatPastedText(text: string, value: string, cursorStart: number, cursorEnd: number): string {\n    const keyArr = text.trim().split('');\n\n    let position = cursorStart;\n\n    let formattedValue = value;\n    // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (const key of keyArr) {\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      const result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  }\n\n  processKey(initialValue: string, key: string, initialPosition: number) {\n    let value = initialValue;\n    let position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      const result = this.handleSeparatorInput(value, position);\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      const isCursorAtEnd = position === value.length;\n      const segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      const segmentMaxValue = this.getSegmentMaxValue(value, position);\n      const segmentMinValue = this.getSegmentMinValue(value, position);\n      const firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      const isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      const exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, `0${key}`, position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value);\n\n    // Move cursor in front of separator if behind after overwriting a character\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return { value, position };\n  }\n\n  private padWithDefaultValue(segmentValue: string, segment: FormatSegmentFull) {\n    let defaultValue = (segment.default || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  }\n\n  private enrichSegmentDefinitions(segments: FormatSegment[]) {\n    this.positionFormats = {};\n    this.segments = [];\n    let position = 0;\n    for (const segment of segments) {\n      const max = segment.max;\n      const fullSegment: FormatSegmentFull = {\n        ...segment,\n        max: typeof max === 'number' ? () => max : max,\n        start: position,\n        end: position + segment.length,\n      };\n      this.segments.push(fullSegment);\n      // insert this format segment for every char in the max value\n      for (let j = 0; j < fullSegment.length; j++) {\n        this.positionFormats[position++] = fullSegment;\n      }\n      // skip a position for separator\n      position++;\n    }\n  }\n}\n\nexport default MaskFormat;\n"]},"metadata":{},"sourceType":"module"}