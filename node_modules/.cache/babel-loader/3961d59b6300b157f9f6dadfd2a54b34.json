{"ast":null,"code":"/**\n * Handles character removal\n *\n * @param initialValue Current value of input\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport var backspaceHandler = function (initialValue, format, selectionStart, selectionEnd) {\n  var multiCharDelete = selectionStart !== selectionEnd;\n\n  if (multiCharDelete) {\n    var isCursorAtEnd = selectionEnd === initialValue.length;\n\n    if (!isCursorAtEnd) {\n      return format.replaceDigitsWithZeroes(initialValue, selectionStart, selectionEnd);\n    }\n\n    return {\n      value: initialValue.slice(0, selectionStart),\n      position: selectionStart\n    };\n  }\n\n  var isSeparator = format.isSegmentStart(selectionStart);\n  var atEnd = selectionStart === initialValue.length;\n\n  if (!atEnd) {\n    if (isSeparator) {\n      return format.deleteSeparator(initialValue, selectionStart);\n    } else {\n      return format.deleteDigit(initialValue, selectionStart);\n    }\n  }\n\n  if (isSeparator) {\n    return {\n      value: initialValue.slice(0, selectionStart - 2),\n      position: selectionStart - 2\n    };\n  }\n\n  return {\n    value: initialValue.slice(0, selectionStart - 1),\n    position: selectionStart - 1\n  };\n};\n/**\n * Handle key down events\n *\n * @param initialValue Current value of input\n * @param key Key that was pressed\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\n\nexport var keyHandler = function (initialValue, key, format, selectionStart, selectionEnd) {\n  var value = initialValue;\n  var position = selectionStart; // return if no more digits can be added at the end\n\n  if (selectionStart === value.length && value.length === format.getMaxLength()) {\n    return {\n      value: value,\n      position: position\n    };\n  } // if range is selected to the end, remove all of that selection first\n\n\n  if (selectionStart !== value.length && selectionEnd === value.length) {\n    var sliceEnd = format.isCursorAtSeparator(selectionStart) ? selectionStart + 1 : selectionStart;\n    value = initialValue.slice(0, sliceEnd);\n  }\n\n  if (format.isCursorAtSeparator(position)) {\n    return {\n      value: value,\n      position: position + 1\n    };\n  }\n\n  return format.processKey(value, key, position);\n};\nexport var enterHandler = function (value, format) {\n  var autoCompletedValue = format.autoComplete(value);\n  var position = autoCompletedValue.length;\n  return {\n    value: autoCompletedValue,\n    position: position\n  };\n};","map":{"version":3,"mappings":"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","names":["backspaceHandler","initialValue","format","selectionStart","selectionEnd","multiCharDelete","isCursorAtEnd","length","replaceDigitsWithZeroes","value","slice","position","isSeparator","isSegmentStart","atEnd","deleteSeparator","deleteDigit","keyHandler","key","getMaxLength","sliceEnd","isCursorAtSeparator","processKey","enterHandler","autoCompletedValue","autoComplete"],"sourceRoot":"","sources":["../../../../../src/internal/components/masked-input/keyboard-handler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport MaskFormat from './utils/mask-format';\n\nexport interface HandlerResult {\n  position: number;\n  value: string;\n}\n\n/**\n * Handles character removal\n *\n * @param initialValue Current value of input\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const backspaceHandler = (\n  initialValue: string,\n  format: MaskFormat,\n  selectionStart: number,\n  selectionEnd: number\n): HandlerResult => {\n  const multiCharDelete = selectionStart !== selectionEnd;\n  if (multiCharDelete) {\n    const isCursorAtEnd = selectionEnd === initialValue.length;\n    if (!isCursorAtEnd) {\n      return format.replaceDigitsWithZeroes(initialValue, selectionStart, selectionEnd);\n    }\n\n    return {\n      value: initialValue.slice(0, selectionStart),\n      position: selectionStart,\n    };\n  }\n\n  const isSeparator = format.isSegmentStart(selectionStart);\n  const atEnd = selectionStart === initialValue.length;\n\n  if (!atEnd) {\n    if (isSeparator) {\n      return format.deleteSeparator(initialValue, selectionStart);\n    } else {\n      return format.deleteDigit(initialValue, selectionStart);\n    }\n  }\n\n  if (isSeparator) {\n    return {\n      value: initialValue.slice(0, selectionStart - 2),\n      position: selectionStart - 2,\n    };\n  }\n\n  return {\n    value: initialValue.slice(0, selectionStart - 1),\n    position: selectionStart - 1,\n  };\n};\n\n/**\n * Handle key down events\n *\n * @param initialValue Current value of input\n * @param key Key that was pressed\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const keyHandler = (\n  initialValue: string,\n  key: string,\n  format: MaskFormat,\n  selectionStart: number,\n  selectionEnd: number\n): HandlerResult => {\n  let value = initialValue;\n  const position = selectionStart;\n\n  // return if no more digits can be added at the end\n  if (selectionStart === value.length && value.length === format.getMaxLength()) {\n    return { value, position };\n  }\n\n  // if range is selected to the end, remove all of that selection first\n  if (selectionStart !== value.length && selectionEnd === value.length) {\n    const sliceEnd = format.isCursorAtSeparator(selectionStart) ? selectionStart + 1 : selectionStart;\n    value = initialValue.slice(0, sliceEnd);\n  }\n\n  if (format.isCursorAtSeparator(position)) {\n    return { value, position: position + 1 };\n  }\n\n  return format.processKey(value, key, position);\n};\n\nexport const enterHandler = (value: string, format: MaskFormat): HandlerResult => {\n  const autoCompletedValue = format.autoComplete(value);\n  const position = autoCompletedValue.length;\n  return { value: autoCompletedValue, position };\n};\n"]},"metadata":{},"sourceType":"module"}