{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __spreadArray } from \"tslib\";\nimport { isDataSeries, isXThreshold, isYThreshold, matchesX } from './utils';\nexport function computeDomainX(series, xScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce(function (acc, s) {\n      if (isDataSeries(s.series)) {\n        s.series.data.forEach(function (_a) {\n          var x = _a.x;\n\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n\n      if (isXThreshold(s.series)) {\n        if (acc.indexOf(s.series.x) === -1) {\n          acc.push(s.series.x);\n        }\n      }\n\n      return acc;\n    }, []);\n  }\n\n  return series.reduce(function (acc, curr) {\n    // Y-thresholds don't have X value.\n    if (isYThreshold(curr.series)) {\n      return acc;\n    } // Compare x-threshold X with current min, max.\n\n\n    if (isXThreshold(curr.series)) {\n      var min = acc[0],\n          max = acc[1];\n      var newMin = min === undefined || curr.series.x < min ? curr.series.x : min;\n      var newMax = max === undefined || max < curr.series.x ? curr.series.x : max;\n      return [newMin, newMax];\n    } // Compare all series X values with current min, max.\n\n\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(function (_a, _b) {\n        var min = _a[0],\n            max = _a[1];\n        var x = _b.x;\n        var newMin = min === undefined || x < min ? x : min;\n        var newMax = max === undefined || max < x ? x : max;\n        return [newMin, newMax];\n      }, acc);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction find(arr, func) {\n  for (var i = 0; i < arr.length; i++) {\n    var found = func(arr[i]);\n\n    if (found) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nexport function computeDomainY(series, scaleType, stackedBars) {\n  var _series = series; // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n\n  if (stackedBars) {\n    var _a = series.reduce(function (acc, curr) {\n      if (curr.series.type === 'bar') {\n        curr.series.data.forEach(function (_a) {\n          var x = _a.x,\n              y = _a.y;\n          var data = y < 0 ? acc.negativeData : acc.positiveData;\n          var stackedDatum = find(data, function (el) {\n            return matchesX(el.x, x);\n          });\n\n          if (stackedDatum) {\n            stackedDatum.y += y;\n          } else {\n            data.push({\n              x: x,\n              y: y\n            });\n          }\n\n          return acc;\n        });\n      }\n\n      return acc;\n    }, {\n      positiveData: [],\n      negativeData: []\n    }),\n        positiveData = _a.positiveData,\n        negativeData = _a.negativeData; // Artificial series with the sum of all bars when stacked\n\n\n    var stackedSeries = [{\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'positive',\n        data: positiveData\n      }\n    }, {\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'negative',\n        data: negativeData\n      }\n    }]; // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n\n    _series = __spreadArray(__spreadArray([], stackedSeries, true), _series.filter(function (s) {\n      return s.series.type !== 'bar';\n    }), true);\n  }\n\n  var domain = _series.reduce(function (acc, curr) {\n    // Compare threshold Y value with current min, max.\n    if (isYThreshold(curr.series)) {\n      var min = acc[0],\n          max = acc[1];\n      var newMin = min === undefined || curr.series.y < min ? curr.series.y : min;\n      var newMax = max === undefined || max < curr.series.y ? curr.series.y : max;\n      return [newMin, newMax];\n    } // X-thresholds don't have Y value.\n\n\n    if (isXThreshold(curr.series)) {\n      return acc;\n    } // Compare all series Y values with current min, max.\n\n\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(function (_a, _b) {\n        var min = _a[0],\n            max = _a[1];\n        var y = _b.y;\n        var newMin = min === undefined || y < min ? y : min;\n        var newMax = max === undefined || max < y ? y : max;\n        return [newMin, newMax];\n      }, acc);\n    }\n\n    return acc;\n  }, [0, 0]); // Log scales can't start from 0, so if possible, start from 1.\n\n\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n\n  return domain;\n}","map":{"version":3,"mappings":"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","names":["isDataSeries","isXThreshold","isYThreshold","matchesX","computeDomainX","series","xScaleType","reduce","acc","s","data","forEach","_a","x","indexOf","push","curr","max","newMin","min","undefined","newMax","_b","find","arr","func","i","length","found","computeDomainY","scaleType","stackedBars","_series","type","y","negativeData","positiveData","stackedDatum","el","stackedSeries","color","index","NaN","title","filter","domain"],"sourceRoot":"","sources":["../../../src/mixed-line-bar-chart/domain.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { InternalChartSeries, MixedLineBarChartProps, ScaleType } from './interfaces';\nimport { isDataSeries, isXThreshold, isYThreshold, matchesX } from './utils';\n\nexport function computeDomainX<T>(series: readonly InternalChartSeries<T>[], xScaleType: ScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce((acc, s) => {\n      if (isDataSeries(s.series)) {\n        s.series.data.forEach(({ x }) => {\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n      if (isXThreshold(s.series)) {\n        if (acc.indexOf(s.series.x) === -1) {\n          acc.push(s.series.x);\n        }\n      }\n      return acc;\n    }, [] as T[]);\n  }\n\n  return series.reduce((acc, curr) => {\n    // Y-thresholds don't have X value.\n    if (isYThreshold(curr.series)) {\n      return acc;\n    }\n\n    // Compare x-threshold X with current min, max.\n    if (isXThreshold(curr.series)) {\n      const [min, max] = acc;\n      const newMin = min === undefined || curr.series.x < min ? curr.series.x : min;\n      const newMax = max === undefined || max < curr.series.x ? curr.series.x : max;\n      return [newMin, newMax] as T[];\n    }\n\n    // Compare all series X values with current min, max.\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(([min, max], { x }) => {\n        const newMin = min === undefined || x < min ? x : min;\n        const newMax = max === undefined || max < x ? x : max;\n        return [newMin, newMax] as T[];\n      }, acc);\n    }\n\n    return acc;\n  }, [] as T[]);\n}\n\nfunction find<Q>(arr: readonly Q[], func: (el: Q) => boolean) {\n  for (let i = 0; i < arr.length; i++) {\n    const found = func(arr[i]);\n    if (found) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n\nexport function computeDomainY<T>(\n  series: readonly InternalChartSeries<T>[],\n  scaleType: 'linear' | 'log',\n  stackedBars: boolean\n) {\n  let _series = series;\n\n  // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n  if (stackedBars) {\n    const { positiveData, negativeData } = series.reduce(\n      (acc, curr) => {\n        if (curr.series.type === 'bar') {\n          curr.series.data.forEach(({ x, y }) => {\n            const data = y < 0 ? acc.negativeData : acc.positiveData;\n            const stackedDatum = find(data, el => matchesX(el.x, x));\n            if (stackedDatum) {\n              stackedDatum.y += y;\n            } else {\n              data.push({ x, y });\n            }\n            return acc;\n          });\n        }\n        return acc;\n      },\n      {\n        positiveData: [] as MixedLineBarChartProps.Datum<T>[],\n        negativeData: [] as MixedLineBarChartProps.Datum<T>[],\n      }\n    );\n\n    // Artificial series with the sum of all bars when stacked\n    const stackedSeries: InternalChartSeries<T>[] = [\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'positive',\n          data: positiveData as any,\n        },\n      },\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'negative',\n          data: negativeData as any,\n        },\n      },\n    ];\n\n    // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n    _series = [...stackedSeries, ..._series.filter(s => s.series.type !== 'bar')];\n  }\n\n  const domain = _series.reduce(\n    (acc, curr) => {\n      // Compare threshold Y value with current min, max.\n      if (isYThreshold(curr.series)) {\n        const [min, max] = acc;\n        const newMin = min === undefined || curr.series.y < min ? curr.series.y : min;\n        const newMax = max === undefined || max < curr.series.y ? curr.series.y : max;\n        return [newMin, newMax];\n      }\n\n      // X-thresholds don't have Y value.\n      if (isXThreshold(curr.series)) {\n        return acc;\n      }\n\n      // Compare all series Y values with current min, max.\n      if (isDataSeries(curr.series)) {\n        return curr.series.data.reduce(([min, max], { y }) => {\n          const newMin = min === undefined || y < min ? y : min;\n          const newMax = max === undefined || max < y ? y : max;\n          return [newMin, newMax];\n        }, acc);\n      }\n\n      return acc;\n    },\n    [0, 0]\n  );\n\n  // Log scales can't start from 0, so if possible, start from 1.\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n  return domain;\n}\n"]},"metadata":{},"sourceType":"module"}