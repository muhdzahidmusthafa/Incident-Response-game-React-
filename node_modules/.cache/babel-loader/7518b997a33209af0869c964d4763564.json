{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState, useLayoutEffect, useCallback, useEffect, createContext, useMemo } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\nexport var StickyHeaderContext = createContext({\n  isStuck: false\n});\nexport var useStickyHeader = function (rootRef, headerRef, __stickyHeader, __stickyOffset) {\n  var currentRootRef = rootRef.current;\n  var currentHeaderRef = headerRef.current;\n  var totalBorder = useMemo(function () {\n    var containerRootBorder = currentRootRef ? parseInt(getComputedStyle(currentRootRef).getPropertyValue('border-top-width'), 10) : 0;\n    var headerBorder = currentHeaderRef ? parseInt(getComputedStyle(currentHeaderRef).getPropertyValue('border-top-width'), 10) : 0;\n    return containerRootBorder + headerBorder;\n  }, [currentRootRef, currentHeaderRef]); // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n\n  var stickyOffsetTop = useAppLayoutContext().stickyOffsetTop;\n  var isSticky = useSupportsStickyHeader() && !!__stickyHeader;\n  var isRefresh = useVisualRefresh(rootRef); // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n\n  var _a = useState(false),\n      hasInnerOverflowParents = _a[0],\n      setHasInnerOverflowParents = _a[1];\n\n  var _b = useState(false),\n      isStuck = _b[0],\n      setIsStuck = _b[1];\n\n  useLayoutEffect(function () {\n    if (rootRef.current) {\n      var overflowParents = getOverflowParents(rootRef.current);\n      var mainElement = findUpUntil(rootRef.current, function (elem) {\n        return elem.tagName === 'MAIN';\n      }); // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n  var effectiveStickyOffset = __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : hasInnerOverflowParents ? 0 : stickyOffsetTop;\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n\n  var computedOffset = \"\".concat(effectiveStickyOffset - totalBorder, \"px\");\n\n  if (isRefresh && !hasInnerOverflowParents) {\n    computedOffset = \"var(\".concat(customCssProps.offsetTopWithNotifications, \", \").concat(computedOffset, \")\");\n  }\n\n  var stickyStyles = isSticky ? {\n    style: {\n      top: computedOffset\n    }\n  } : {}; // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n\n  var checkIfStuck = useCallback(function () {\n    if (rootRef.current && headerRef.current) {\n      var rootTop = rootRef.current.getBoundingClientRect().top;\n      var headerTop = headerRef.current.getBoundingClientRect().top;\n\n      if (rootTop + totalBorder < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef, totalBorder]);\n  useEffect(function () {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return function () {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky: isSticky,\n    isStuck: isStuck,\n    stickyStyles: stickyStyles\n  };\n};\nexport function useSupportsStickyHeader() {\n  var isMobile = useMobile();\n  return supportsStickyPosition() && !isMobile;\n}","map":{"version":3,"mappings":"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","names":["useState","useLayoutEffect","useCallback","useEffect","createContext","useMemo","useAppLayoutContext","useMobile","findUpUntil","supportsStickyPosition","getOverflowParents","useVisualRefresh","customCssProps","StickyHeaderContext","isStuck","useStickyHeader","rootRef","headerRef","__stickyHeader","__stickyOffset","currentRootRef","current","currentHeaderRef","totalBorder","containerRootBorder","parseInt","getComputedStyle","getPropertyValue","headerBorder","stickyOffsetTop","isSticky","useSupportsStickyHeader","isRefresh","hasInnerOverflowParents","setHasInnerOverflowParents","setIsStuck","overflowParents","mainElement","tagName","length","effectiveStickyOffset","computedOffset","offsetTopWithNotifications","concat","stickyStyles","style","top","checkIfStuck","rootTop","getBoundingClientRect","headerTop","window","addEventListener","removeEventListener","isMobile"],"sourceRoot":"","sources":["../../../src/container/use-sticky-header.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject, useState, useLayoutEffect, useCallback, useEffect, createContext, useMemo } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\n\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({ isStuck: false });\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number\n) => {\n  const currentRootRef = rootRef.current;\n  const currentHeaderRef = headerRef.current;\n  const totalBorder = useMemo(() => {\n    const containerRootBorder = currentRootRef\n      ? parseInt(getComputedStyle(currentRootRef).getPropertyValue('border-top-width'), 10)\n      : 0;\n    const headerBorder = currentHeaderRef\n      ? parseInt(getComputedStyle(currentHeaderRef).getPropertyValue('border-top-width'), 10)\n      : 0;\n    return containerRootBorder + headerBorder;\n  }, [currentRootRef, currentHeaderRef]);\n\n  // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n  const { stickyOffsetTop } = useAppLayoutContext();\n  const isSticky = useSupportsStickyHeader() && !!__stickyHeader;\n  const isRefresh = useVisualRefresh(rootRef);\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const effectiveStickyOffset = __stickyOffset ?? (hasInnerOverflowParents ? 0 : stickyOffsetTop);\n\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n  let computedOffset = `${effectiveStickyOffset - totalBorder}px`;\n  if (isRefresh && !hasInnerOverflowParents) {\n    computedOffset = `var(${customCssProps.offsetTopWithNotifications}, ${computedOffset})`;\n  }\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(() => {\n    if (rootRef.current && headerRef.current) {\n      const rootTop = rootRef.current.getBoundingClientRect().top;\n      const headerTop = headerRef.current.getBoundingClientRect().top;\n      if (rootTop + totalBorder < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef, totalBorder]);\n  useEffect(() => {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return () => {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    stickyStyles,\n  };\n};\n\nexport function useSupportsStickyHeader() {\n  const isMobile = useMobile();\n  return supportsStickyPosition() && !isMobile;\n}\n"]},"metadata":{},"sourceType":"module"}