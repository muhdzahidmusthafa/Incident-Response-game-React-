{"ast":null,"code":"var _a, _b, _c;\n\nimport { __spreadArray } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { getTrackableValue } from './utils';\nimport selectionStyles from './selection-control/styles.css.js';\nimport { joinStrings } from '../internal/utils/strings';\nvar SELECTION_ITEM = 'selection-item';\nvar SELECTION_ROOT = 'selection-root';\n\nfunction findSelectionControlByIndex(rootContainer, index) {\n  if (index === -1) {\n    // find \"select all\" checkbox\n    return rootContainer.querySelector(\"[data-\".concat(SELECTION_ITEM, \"=\\\"all\\\"] .\").concat(selectionStyles.root, \" input\"));\n  }\n\n  return rootContainer.querySelectorAll(\"[data-\".concat(SELECTION_ITEM, \"=\\\"item\\\"] .\").concat(selectionStyles.root, \" input\"))[index];\n}\n\nfunction findRootContainer(element) {\n  return findUpUntil(element, function (node) {\n    return node.dataset.selectionRoot === 'true';\n  });\n}\n\nexport function useFocusMove(selectionType, totalItems) {\n  if (selectionType !== 'multi') {\n    return {};\n  }\n\n  function moveFocus(sourceElement, fromIndex, direction) {\n    var index = fromIndex;\n    var rootContainer = findRootContainer(sourceElement);\n\n    while (index >= -1 && index < totalItems) {\n      index += direction;\n      var control = findSelectionControlByIndex(rootContainer, index);\n\n      if (control && !control.disabled) {\n        control.focus();\n        break;\n      }\n    }\n  }\n\n  var _a = [1, -1].map(function (direction) {\n    return function (event) {\n      var target = event.currentTarget;\n      var itemNode = findUpUntil(target, function (node) {\n        return node.dataset.selectionItem === 'item';\n      });\n      var fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);\n      moveFocus(target, fromIndex, direction);\n    };\n  }),\n      moveFocusDown = _a[0],\n      moveFocusUp = _a[1];\n\n  return {\n    moveFocusDown: moveFocusDown,\n    moveFocusUp: moveFocusUp,\n    moveFocus: moveFocus\n  };\n} // A set, that compares items by their \"trackables\" (the results of applying `trackBy` to them)\n\nvar ItemSet =\n/** @class */\nfunction () {\n  function ItemSet(trackBy, items) {\n    var _this = this;\n\n    this.map = new Map();\n\n    this.put = function (item) {\n      return _this.map.set.call(_this.map, getTrackableValue(_this.trackBy, item), item);\n    };\n\n    this.has = function (item) {\n      return _this.map.has.call(_this.map, getTrackableValue(_this.trackBy, item));\n    };\n\n    this.forEach = this.map.forEach.bind(this.map);\n    this.trackBy = trackBy;\n    items.forEach(this.put);\n  }\n\n  return ItemSet;\n}();\n\nexport var focusMarkers = {\n  item: (_a = {}, _a['data-' + SELECTION_ITEM] = 'item', _a),\n  all: (_b = {}, _b['data-' + SELECTION_ITEM] = 'all', _b),\n  root: (_c = {}, _c['data-' + SELECTION_ROOT] = 'true', _c)\n};\nexport function useSelection(_a) {\n  var _b;\n\n  var items = _a.items,\n      _c = _a.selectedItems,\n      selectedItems = _c === void 0 ? [] : _c,\n      selectionType = _a.selectionType,\n      _d = _a.isItemDisabled,\n      isItemDisabled = _d === void 0 ? function () {\n    return false;\n  } : _d,\n      trackBy = _a.trackBy,\n      onSelectionChange = _a.onSelectionChange,\n      ariaLabels = _a.ariaLabels;\n\n  var _e = useState(false),\n      shiftPressed = _e[0],\n      setShiftPressed = _e[1];\n\n  var _f = useState(null),\n      lastClickedItem = _f[0],\n      setLastClickedItem = _f[1];\n\n  var selectionName = useUniqueId();\n  var finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  var selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  var itemIndexesMap = new Map();\n  items.forEach(function (item, i) {\n    return itemIndexesMap.set(getTrackableValue(trackBy, item), i);\n  });\n  var isItemSelected = selectedSet.has.bind(selectedSet);\n\n  var getItemState = function (item) {\n    return {\n      disabled: isItemDisabled(item),\n      selected: isItemSelected(item)\n    };\n  };\n\n  var _g = selectionType ? items.reduce(function (_a, item) {\n    var allDisabled = _a[0],\n        allEnabledSelected = _a[1];\n\n    var _b = getItemState(item),\n        disabled = _b.disabled,\n        selected = _b.selected;\n\n    return [// all items are disabled (or none are present)\n    allDisabled && disabled, // all enabled items are selected (or none are present)\n    allEnabledSelected && (selected || disabled)];\n  }, [true, true]) : [true, true],\n      allDisabled = _g[0],\n      allEnabledSelected = _g[1]; // the page has at least one selected item\n\n\n  var hasSelected = finalSelectedItems.length > 0;\n\n  var handleToggleAll = function () {\n    var requestedItems = new ItemSet(trackBy, items);\n    var newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, {\n      selectedItems: newSelectedItems\n    });\n  };\n\n  var getRequestedItems = function (item) {\n    var requestedItems = new ItemSet(trackBy, [item]);\n    var lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    } // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n\n\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      var currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));\n      var start = Math.min(currentItemIndex, lastClickedItemIndex);\n      var end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(function (item) {\n        return requestedItems.put(item);\n      });\n    }\n\n    return requestedItems;\n  };\n\n  var deselectItems = function (requestedItems) {\n    var newSelectedItems = [];\n    selectedItems.forEach(function (selectedItem) {\n      var toUnselect = requestedItems.has(selectedItem);\n\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  var selectItems = function (requestedItems) {\n    var newSelectedItems = __spreadArray([], selectedItems, true);\n\n    requestedItems.forEach(function (newItem) {\n      var _a = getItemState(newItem),\n          selected = _a.selected,\n          disabled = _a.disabled;\n\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  var handleToggleItem = function (item) {\n    return function () {\n      var _a = getItemState(item),\n          disabled = _a.disabled,\n          selected = _a.selected;\n\n      if (disabled || selectionType === 'single' && selected) {\n        return;\n      }\n\n      if (selectionType === 'single') {\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: [item]\n        });\n      } else {\n        var requestedItems = getRequestedItems(item);\n        var selectedItems_1 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: selectedItems_1\n        });\n        setLastClickedItem(item);\n      }\n    };\n  };\n\n  return {\n    isItemSelected: isItemSelected,\n    selectAllProps: {\n      name: selectionName,\n      disabled: allDisabled,\n      selectionType: selectionType,\n      indeterminate: hasSelected && !allEnabledSelected,\n      checked: hasSelected && allEnabledSelected,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, {\n        selectedItems: selectedItems\n      }))\n    },\n    getItemSelectionProps: function (item) {\n      var _a;\n\n      return {\n        name: selectionName,\n        selectionType: selectionType,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems: selectedItems\n        }, item)),\n        onChange: handleToggleItem(item),\n        checked: isItemSelected(item),\n        disabled: isItemDisabled(item)\n      };\n    },\n    updateShiftToggle: function (value) {\n      setShiftPressed(value);\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useState","fireNonCancelableEvent","useUniqueId","findUpUntil","getTrackableValue","selectionStyles","joinStrings","SELECTION_ITEM","SELECTION_ROOT","findSelectionControlByIndex","rootContainer","index","querySelector","concat","root","querySelectorAll","findRootContainer","element","dataset","selectionRoot","useFocusMove","selectionType","totalItems","moveFocus","sourceElement","fromIndex","direction","control","disabled","focus","map","event","target","currentTarget","itemNode","selectionItem","Array","prototype","indexOf","call","parentElement","children","moveFocusDown","moveFocusUp","trackBy","items","Map","item","set","_this","has","forEach","bind","put","focusMarkers","_a","all","_b","_c","useSelection","selectedItems","_d","isItemDisabled","onSelectionChange","ariaLabels","shiftPressed","setShiftPressed","lastClickedItem","setLastClickedItem","selectionName","finalSelectedItems","slice","selectedSet","ItemSet","itemIndexesMap","i","isItemSelected","getItemState","selected","reduce","allDisabled","allEnabledSelected","hasSelected","length","handleToggleAll","requestedItems","newSelectedItems","deselectItems","selectItems","getRequestedItems","lastClickedItemIndex","get","undefined","currentItemIndex","start","Math","min","end","max","toUnselect","selectedItem","push","newItem","handleToggleItem","selectedItems_1","selectAllProps","name","indeterminate","checked","onChange","ariaLabel","selectionGroupLabel","allItemsSelectionLabel","getItemSelectionProps","itemSelectionLabel","updateShiftToggle","value"],"sourceRoot":"","sources":["../../../src/table/use-selection.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { KeyboardEvent, useState } from 'react';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { TableProps } from './interfaces';\nimport { getTrackableValue } from './utils';\nimport selectionStyles from './selection-control/styles.css.js';\nimport { joinStrings } from '../internal/utils/strings';\n\nconst SELECTION_ITEM = 'selection-item';\nconst SELECTION_ROOT = 'selection-root';\n\nfunction findSelectionControlByIndex(rootContainer: HTMLElement, index: number) {\n  if (index === -1) {\n    // find \"select all\" checkbox\n    return rootContainer.querySelector<HTMLInputElement>(\n      `[data-${SELECTION_ITEM}=\"all\"] .${selectionStyles.root} input`\n    );\n  }\n  return rootContainer.querySelectorAll<HTMLInputElement>(\n    `[data-${SELECTION_ITEM}=\"item\"] .${selectionStyles.root} input`\n  )[index];\n}\n\nfunction findRootContainer(element: HTMLElement) {\n  return findUpUntil(element, node => node.dataset.selectionRoot === 'true')!;\n}\n\nexport function useFocusMove(selectionType: TableProps['selectionType'], totalItems: number) {\n  if (selectionType !== 'multi') {\n    return {};\n  }\n  function moveFocus(sourceElement: HTMLElement, fromIndex: number, direction: -1 | 1) {\n    let index = fromIndex;\n    const rootContainer = findRootContainer(sourceElement);\n\n    while (index >= -1 && index < totalItems) {\n      index += direction;\n      const control = findSelectionControlByIndex(rootContainer, index);\n      if (control && !control.disabled) {\n        control.focus();\n        break;\n      }\n    }\n  }\n  const [moveFocusDown, moveFocusUp] = ([1, -1] as const).map(direction => {\n    return (event: KeyboardEvent) => {\n      const target = event.currentTarget as HTMLElement;\n      const itemNode = findUpUntil(target, node => node.dataset.selectionItem === 'item')!;\n      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement!.children, itemNode);\n      moveFocus(target, fromIndex, direction);\n    };\n  });\n  return {\n    moveFocusDown,\n    moveFocusUp,\n    moveFocus,\n  };\n}\n\n// A set, that compares items by their \"trackables\" (the results of applying `trackBy` to them)\nclass ItemSet<T> {\n  constructor(trackBy: TableProps.TrackBy<T> | undefined, items: ReadonlyArray<T>) {\n    this.trackBy = trackBy;\n    items.forEach(this.put);\n  }\n  private trackBy: TableProps.TrackBy<T> | undefined;\n  private map: Map<unknown, T> = new Map();\n  put = (item: T) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);\n  has = (item: T) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));\n  forEach = this.map.forEach.bind(this.map);\n}\n\nexport const focusMarkers = {\n  item: { ['data-' + SELECTION_ITEM]: 'item' },\n  all: { ['data-' + SELECTION_ITEM]: 'all' },\n  root: { ['data-' + SELECTION_ROOT]: 'true' },\n};\n\nexport function useSelection<T>({\n  items,\n  selectedItems = [],\n  selectionType,\n  isItemDisabled = () => false,\n  trackBy,\n  onSelectionChange,\n  ariaLabels,\n}: Pick<\n  TableProps<T>,\n  'ariaLabels' | 'items' | 'selectedItems' | 'selectionType' | 'isItemDisabled' | 'trackBy' | 'onSelectionChange'\n>) {\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState<T | null>(null);\n  const selectionName = useUniqueId();\n  const finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  const selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  const itemIndexesMap = new Map();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  const getItemState = (item: T) => ({\n    disabled: isItemDisabled(item),\n    selected: isItemSelected(item),\n  });\n  const [allDisabled, allEnabledSelected] = selectionType\n    ? items.reduce(\n        ([allDisabled, allEnabledSelected], item) => {\n          const { disabled, selected } = getItemState(item);\n          return [\n            // all items are disabled (or none are present)\n            allDisabled && disabled,\n            // all enabled items are selected (or none are present)\n            allEnabledSelected && (selected || disabled),\n          ];\n        },\n        [true, true]\n      )\n    : [true, true];\n\n  // the page has at least one selected item\n  const hasSelected = finalSelectedItems.length > 0;\n\n  const handleToggleAll = () => {\n    const requestedItems = new ItemSet(trackBy, items);\n    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });\n  };\n\n  const getRequestedItems = (item: T) => {\n    const requestedItems = new ItemSet(trackBy, [item]);\n    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    }\n    // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item)) as number;\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(item => requestedItems.put(item));\n    }\n    return requestedItems;\n  };\n\n  const deselectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems: Array<T> = [];\n    selectedItems.forEach(selectedItem => {\n      const toUnselect = requestedItems.has(selectedItem);\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const selectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      const { selected, disabled } = getItemState(newItem);\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const handleToggleItem = (item: T) => () => {\n    const { disabled, selected } = getItemState(item);\n    if (disabled || (selectionType === 'single' && selected)) {\n      return;\n    }\n    if (selectionType === 'single') {\n      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });\n    } else {\n      const requestedItems = getRequestedItems(item);\n      const selectedItems = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, { selectedItems });\n      setLastClickedItem(item);\n    }\n  };\n  return {\n    isItemSelected,\n    selectAllProps: {\n      name: selectionName,\n      disabled: allDisabled,\n      selectionType: selectionType,\n      indeterminate: hasSelected && !allEnabledSelected,\n      checked: hasSelected && allEnabledSelected,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels?.selectionGroupLabel, ariaLabels?.allItemsSelectionLabel?.({ selectedItems })),\n    },\n    getItemSelectionProps: (item: T) => ({\n      name: selectionName,\n      selectionType: selectionType,\n      ariaLabel: joinStrings(\n        ariaLabels?.selectionGroupLabel,\n        ariaLabels?.itemSelectionLabel?.({ selectedItems }, item)\n      ),\n      onChange: handleToggleItem(item),\n      checked: isItemSelected(item),\n      disabled: isItemDisabled(item),\n    }),\n    updateShiftToggle: (value: boolean) => {\n      setShiftPressed(value);\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}