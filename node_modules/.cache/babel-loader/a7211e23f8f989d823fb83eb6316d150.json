{"ast":null,"code":"import { __assign } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nexport function useNavigation(_a) {\n  var series = _a.series,\n      visibleSeries = _a.visibleSeries,\n      scaledSeries = _a.scaledSeries,\n      barGroups = _a.barGroups,\n      xScale = _a.xScale,\n      yScale = _a.yScale,\n      highlightedPoint = _a.highlightedPoint,\n      highlightedGroupIndex = _a.highlightedGroupIndex,\n      highlightedSeries = _a.highlightedSeries,\n      legendSeries = _a.legendSeries,\n      isHandlersDisabled = _a.isHandlersDisabled,\n      pinPopover = _a.pinPopover,\n      highlightSeries = _a.highlightSeries,\n      highlightGroup = _a.highlightGroup,\n      highlightPoint = _a.highlightPoint;\n\n  var _b = useState(null),\n      targetX = _b[0],\n      setTargetX = _b[1]; // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n\n\n  var isGroupNavigation = visibleSeries.some(function (_a) {\n    var series = _a.series;\n    return series.type === 'bar';\n  }); // Make a list of series that can be navigated between. Bar series are treated as one.\n\n  var navigableSeries = useMemo(function () {\n    return findNavigableSeries(visibleSeries);\n  }, [visibleSeries]).navigableSeries;\n\n  var onBarGroupFocus = function () {\n    var groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  var onLineGroupFocus = function () {\n    var _a, _b, _c;\n\n    if (!highlightedSeries || !highlightedPoint) {\n      var targetSeries = (_c = (_a = highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : legendSeries) !== null && _a !== void 0 ? _a : (_b = series[0]) === null || _b === void 0 ? void 0 : _b.series) !== null && _c !== void 0 ? _c : null;\n      highlightSeries(targetSeries);\n\n      for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {\n        var scaledS = scaledSeries_1[_i];\n\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n\n  var onFocus = function () {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n\n  var moveBetweenSeries = useCallback(function (direction) {\n    var _a, _b, _c, _d;\n\n    if (isGroupNavigation) {\n      return;\n    }\n\n    var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    var MAX_SERIES_INDEX = navigableSeries.length - 1; // Find the index of the currently highlighted series (if any)\n\n    var previousSeriesIndex = -1;\n\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    } // Move forwards or backwards to the new series\n\n\n    var nextSeriesIndex = 0;\n\n    if (previousSeriesIndex !== -1) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = 0;\n      } else if (nextSeriesIndex < 0) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n\n    var nextSeries = navigableSeries[nextSeriesIndex];\n    var nextInternalSeries = series.filter(function (_a) {\n      var series = _a.series;\n      return series === nextSeries;\n    })[0]; // 2. Find point in the next series\n\n    var targetXPoint = ((_a = xScale.d3Scale(targetX)) !== null && _a !== void 0 ? _a : NaN) + xOffset;\n\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n\n    if (nextSeries.type === 'line') {\n      var nextScaledSeries = scaledSeries.filter(function (it) {\n        return it.series === nextSeries;\n      });\n      var closestNextSeriesPoint = nextScaledSeries.reduce(function (prev, curr) {\n        return Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev;\n      }, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightSeries(nextSeries);\n      highlightPoint(__assign(__assign({}, closestNextSeriesPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (isYThreshold(nextSeries)) {\n      var scaledTargetIndex = scaledSeries.map(function (it) {\n        var _a;\n\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(targetX);\n      highlightSeries(nextSeries);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_b = yScale.d3Scale(nextSeries.y)) !== null && _b !== void 0 ? _b : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_c = scaledSeries[scaledTargetIndex]) === null || _c === void 0 ? void 0 : _c.datum\n      });\n    } else if (isXThreshold(nextSeries)) {\n      highlightSeries(nextSeries);\n      highlightPoint({\n        x: (_d = xScale.d3Scale(nextSeries.x)) !== null && _d !== void 0 ? _d : NaN,\n        y: yScale.d3Scale.range()[0],\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: {\n          x: nextSeries.x,\n          y: NaN\n        }\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, scaledSeries, series, targetX, highlightSeries, highlightPoint, yScale]);\n  var moveWithinSeries = useCallback(function (direction) {\n    var _a;\n\n    var series = highlightedSeries || visibleSeries[0].series;\n    var previousPoint = highlightedPoint || scaledSeries[0];\n\n    if (series.type === 'line' || isYThreshold(series)) {\n      var targetScaledSeries = scaledSeries.filter(function (it) {\n        return it.series === series;\n      });\n      var indexOfPreviousPoint = targetScaledSeries.map(function (it) {\n        return it.x;\n      }).indexOf(previousPoint.x);\n      var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n      var nextPoint = targetScaledSeries[nextPointIndex];\n      setTargetX(((_a = nextPoint.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      highlightSeries(series);\n      highlightPoint(nextPoint);\n    } else if (series.type === 'bar') {\n      var xDomain = xScale.domain;\n      var MAX_GROUP_INDEX = xDomain.length - 1;\n      var nextGroupIndex = 0;\n\n      if (highlightedGroupIndex !== null) {\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n\n      var nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, highlightedPoint, scaledSeries, highlightSeries, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup]);\n  var onKeyDown = useCallback(function (event) {\n    var keyCode = event.keyCode;\n\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (isHandlersDisabled) {\n      return;\n    }\n\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]);\n  return {\n    isGroupNavigation: isGroupNavigation,\n    onFocus: onFocus,\n    onKeyDown: onKeyDown\n  };\n} // Returns given index if it is in range or the opposite range boundary otherwise.\n\nfunction circleIndex(index, _a) {\n  var from = _a[0],\n      to = _a[1];\n\n  if (index < from) {\n    return to;\n  }\n\n  if (index > to) {\n    return from;\n  }\n\n  return index;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useState","KeyCode","findNavigableSeries","isXThreshold","isYThreshold","nextValidDomainIndex","useNavigation","_a","series","visibleSeries","scaledSeries","barGroups","xScale","yScale","highlightedPoint","highlightedGroupIndex","highlightedSeries","legendSeries","isHandlersDisabled","pinPopover","highlightSeries","highlightGroup","highlightPoint","targetX","setTargetX","isGroupNavigation","some","type","navigableSeries","onBarGroupFocus","groupIndex","domain","onLineGroupFocus","targetSeries","_b","_c","_i","scaledS","onFocus","moveBetweenSeries","direction","xOffset","isCategorical","Math","max","d3Scale","bandwidth","MAX_SERIES_INDEX","length","previousSeriesIndex","indexOf","nextSeriesIndex","nextSeries","nextInternalSeries","filter","targetXPoint","NaN","isFinite","nextScaledSeries","closestNextSeriesPoint","reduce","prev","curr","abs","x","Infinity","y","color","scaledTargetIndex","map","datum","_d","range","moveWithinSeries","previousPoint","targetScaledSeries","indexOfPreviousPoint","nextPointIndex","circleIndex","nextPoint","xDomain","MAX_GROUP_INDEX","nextGroupIndex","nextDomainIndex","onKeyDown","event","keyCode","up","right","down","left","space","enter","preventDefault","index","from","to"],"sourceRoot":"","sources":["../../../../src/mixed-line-bar-chart/hooks/use-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  legendSeries: null | MixedLineBarChartProps.ChartSeries<T>;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  clearHighlightedSeries(): void;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  legendSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = visibleSeries.some(({ series }) => series.type === 'bar');\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineGroupFocus = () => {\n    if (!highlightedSeries || !highlightedPoint) {\n      const targetSeries = highlightedSeries ?? legendSeries ?? series[0]?.series ?? null;\n      highlightSeries(targetSeries);\n      for (const scaledS of scaledSeries) {\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n\n  const moveBetweenSeries = useCallback(\n    (direction: number) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== -1) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = 0;\n        } else if (nextSeriesIndex < 0) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(targetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightSeries(nextSeries);\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(targetX);\n        highlightSeries(nextSeries);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightSeries(nextSeries);\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      scaledSeries,\n      series,\n      targetX,\n      highlightSeries,\n      highlightPoint,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n      const previousPoint = highlightedPoint || scaledSeries[0];\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        highlightSeries(series);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      highlightedPoint,\n      scaledSeries,\n      highlightSeries,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n    ]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown };\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"module"}