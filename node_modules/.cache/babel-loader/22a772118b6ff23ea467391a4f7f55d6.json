{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { useEffect, useState } from 'react';\nimport styles from './styles.css.js';\nimport { getOverflowParentDimensions } from '../internal/utils/scrollable-containers';\nimport { browserScrollbarSize } from '../internal/utils/browser-scrollbar-size';\nimport { supportsStickyPosition, getContainingBlock } from '../internal/utils/dom';\n\nvar updatePosition = function (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) {\n  if (!tableEl || !scrollbarEl || !wrapperEl) {\n    return;\n  } // parent is either some container or document itself\n\n\n  var parent = getOverflowParentDimensions(wrapperEl)[0];\n  var parentBottom = parent.top + parent.height; // table bottom is visible when\n  // 1. table bottom reached end of the window\n  // 2. table bottom is not overlapped by footer\n\n  var _a = tableEl.getBoundingClientRect(),\n      tableTop = _a.top,\n      tableBottom = _a.bottom,\n      tableWidth = _a.width;\n\n  var wrapperWidth = wrapperEl.getBoundingClientRect().width; //scrollbar correction is needed for\n  // #1 when scrollbars are constantly visible,\n  // we want no visible break when switching between fake and real scrollbars\n  // #2 when scrollbars are visible only on scrolling and half transparent (on mac)\n  // we want to avoid any overlap between fake and real scrollbar\n  // using 15 px as a height of transparent scrollbar on mac\n\n  var scrollbarHeight = browserScrollbarSize().height;\n  var scrollBarCorrection = scrollbarHeight > 0 ? scrollbarHeight : -15 / 2;\n  var tableBottomIsVisible = parentBottom - consideredFooterHeight >= tableBottom + scrollBarCorrection;\n  var tableTopIsHidden = tableTop >= parentBottom - consideredFooterHeight - scrollBarCorrection;\n  var areaIsScrollable = tableWidth > wrapperWidth;\n\n  if (tableBottomIsVisible || tableTopIsHidden || !areaIsScrollable) {\n    scrollbarEl.classList.remove(styles['sticky-scrollbar-visible']);\n  } else {\n    // when scrollbar is not displayed scrollLeft property cannot be set by useScrollSync\n    // that's why syncing it separately\n    if (!scrollbarEl.classList.contains(styles['sticky-scrollbar-visible'])) {\n      requestAnimationFrame(function () {\n        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;\n      });\n    }\n\n    scrollbarEl.classList.add(styles['sticky-scrollbar-visible']);\n  }\n\n  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {\n    scrollbarEl.style.height = \"\".concat(scrollbarHeight, \"px\");\n    scrollbarContentEl.style.height = \"\".concat(scrollbarHeight, \"px\");\n  }\n\n  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {\n    var parent_1 = getOverflowParentDimensions(wrapperEl)[0];\n    var wrapperElRect = wrapperEl.getBoundingClientRect();\n    var tableElRect = tableEl.getBoundingClientRect();\n    scrollbarEl.style.width = \"\".concat(wrapperElRect.width, \"px\");\n    scrollbarContentEl.style.width = \"\".concat(tableElRect.width, \"px\"); // when using sticky scrollbars in containers\n    // we agreed to ignore dynamic bottom calculations for footer overlap\n\n    scrollbarEl.style.left = hasContainingBlock ? '0px' : \"\".concat(wrapperElRect.left, \"px\");\n    scrollbarEl.style.top = hasContainingBlock ? '0px' : \"\".concat(Math.min(parent_1.top + parent_1.height, window.innerHeight - consideredFooterHeight), \"px\");\n  }\n};\n\nexport function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight) {\n  // We don't take into account containing-block calculations because that would\n  // unnecessarily overcomplicate the position logic. For now, we assume that a\n  // containing block, if present, is below the app layout and above the overflow\n  // parent, which is a pretty safe assumption.\n  var _a = useState(false),\n      hasContainingBlock = _a[0],\n      setHasContainingBlock = _a[1];\n\n  var consideredFooterHeight = hasContainingBlock ? 0 : footerHeight;\n  useEffect(function () {\n    if (supportsStickyPosition()) {\n      var scrollHandler_1 = function () {\n        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n      };\n\n      scrollHandler_1();\n      window.addEventListener('scroll', scrollHandler_1, true);\n      return function () {\n        window.removeEventListener('scroll', scrollHandler_1, true);\n      };\n    }\n  }, [scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, scrollbarContentRef, hasContainingBlock]);\n  var wrapperEl = wrapperRef.current;\n  useEffect(function () {\n    if (wrapperEl && supportsStickyPosition()) {\n      setHasContainingBlock(!!getContainingBlock(wrapperEl));\n    }\n  }, [wrapperEl]);\n  useEffect(function () {\n    if (supportsStickyPosition() && tableRef.current) {\n      var observer_1 = new ResizeObserver(function (entries) {\n        if (scrollbarContentRef.current) {\n          scrollbarContentRef.current.style.width = \"\".concat(entries[0].borderBoxSize[0].inlineSize, \"px\");\n          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n        }\n      });\n      observer_1.observe(tableRef.current);\n      return function () {\n        observer_1.disconnect();\n      };\n    }\n  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);\n  useEffect(function () {\n    if (supportsStickyPosition()) {\n      var resizeHandler_1 = function () {\n        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n      };\n\n      window.addEventListener('resize', resizeHandler_1);\n      return function () {\n        window.removeEventListener('resize', resizeHandler_1);\n      };\n    }\n  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,SAASA,cAAT,QAA+B,yBAA/B;AACA,SAAoBC,SAApB,EAA+BC,QAA/B,QAA+C,OAA/C;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AAEA,SAASC,2BAAT,QAA4C,yCAA5C;AACA,SAASC,oBAAT,QAAqC,0CAArC;AACA,SAASC,sBAAT,EAAiCC,kBAAjC,QAA2D,uBAA3D;;AAEA,IAAMC,cAAc,GAAG,UACrBC,OADqB,EAErBC,SAFqB,EAGrBC,WAHqB,EAIrBC,kBAJqB,EAKrBC,kBALqB,EAMrBC,sBANqB,EAMS;EAE9B,IAAI,CAACL,OAAD,IAAY,CAACE,WAAb,IAA4B,CAACD,SAAjC,EAA4C;IAC1C;EACD,CAJ6B,CAM9B;;;EACA,IAAMK,MAAM,GAAGX,2BAA2B,CAACM,SAAD,CAA3B,CAAuC,CAAvC,CAAf;EACA,IAAMM,YAAY,GAAGD,MAAM,CAACE,GAAP,GAAaF,MAAM,CAACG,MAAzC,CAR8B,CAU9B;EACA;EACA;;EACM,SAA4DT,OAAO,CAACU,qBAAR,EAA5D;EAAA,IAAOC,QAAQ,SAAf;EAAA,IAAyBC,WAAW,YAApC;EAAA,IAA6CC,UAAU,WAAvD;;EACE,IAAOC,YAAY,GAAKb,SAAS,CAACS,qBAAV,GAAiCK,KAAzD,CAdsB,CAgB9B;EACA;EACA;EACA;EACA;EACA;;EACA,IAAMC,eAAe,GAAGpB,oBAAoB,GAAGa,MAA/C;EACA,IAAMQ,mBAAmB,GAAGD,eAAe,GAAG,CAAlB,GAAsBA,eAAtB,GAAwC,CAAC,EAAD,GAAM,CAA1E;EACA,IAAME,oBAAoB,GAAGX,YAAY,GAAGF,sBAAf,IAAyCO,WAAW,GAAGK,mBAApF;EACA,IAAME,gBAAgB,GAAGR,QAAQ,IAAIJ,YAAY,GAAGF,sBAAf,GAAwCY,mBAA7E;EACA,IAAMG,gBAAgB,GAAGP,UAAU,GAAGC,YAAtC;;EAEA,IAAII,oBAAoB,IAAIC,gBAAxB,IAA4C,CAACC,gBAAjD,EAAmE;IACjElB,WAAW,CAACmB,SAAZ,CAAsBC,MAAtB,CAA6B5B,MAAM,CAAC,0BAAD,CAAnC;EACD,CAFD,MAEO;IACL;IACA;IACA,IAAI,CAACQ,WAAW,CAACmB,SAAZ,CAAsBE,QAAtB,CAA+B7B,MAAM,CAAC,0BAAD,CAArC,CAAL,EAAyE;MACvE8B,qBAAqB,CAAC;QACpBtB,WAAW,CAACuB,UAAZ,GAAyBxB,SAAS,CAACwB,UAAnC;MACD,CAFoB,CAArB;IAGD;;IAEDvB,WAAW,CAACmB,SAAZ,CAAsBK,GAAtB,CAA0BhC,MAAM,CAAC,0BAAD,CAAhC;EACD;;EAED,IAAIsB,eAAe,IAAId,WAAnB,IAAkCC,kBAAtC,EAA0D;IACxDD,WAAW,CAACyB,KAAZ,CAAkBlB,MAAlB,GAA2B,UAAGO,eAAH,EAAkB,IAAlB,CAA3B;IACAb,kBAAkB,CAACwB,KAAnB,CAAyBlB,MAAzB,GAAkC,UAAGO,eAAH,EAAkB,IAAlB,CAAlC;EACD;;EAED,IAAIhB,OAAO,IAAIC,SAAX,IAAwBE,kBAAxB,IAA8CD,WAAlD,EAA+D;IAC7D,IAAM0B,QAAM,GAAGjC,2BAA2B,CAACM,SAAD,CAA3B,CAAuC,CAAvC,CAAf;IAEA,IAAM4B,aAAa,GAAG5B,SAAS,CAACS,qBAAV,EAAtB;IACA,IAAMoB,WAAW,GAAG9B,OAAO,CAACU,qBAAR,EAApB;IACAR,WAAW,CAACyB,KAAZ,CAAkBZ,KAAlB,GAA0B,UAAGc,aAAa,CAACd,KAAjB,EAAsB,IAAtB,CAA1B;IACAZ,kBAAkB,CAACwB,KAAnB,CAAyBZ,KAAzB,GAAiC,UAAGe,WAAW,CAACf,KAAf,EAAoB,IAApB,CAAjC,CAN6D,CAQ7D;IACA;;IACAb,WAAW,CAACyB,KAAZ,CAAkBI,IAAlB,GAAyB3B,kBAAkB,GAAG,KAAH,GAAW,UAAGyB,aAAa,CAACE,IAAjB,EAAqB,IAArB,CAAtD;IACA7B,WAAW,CAACyB,KAAZ,CAAkBnB,GAAlB,GAAwBJ,kBAAkB,GACtC,KADsC,GAEtC,UAAG4B,IAAI,CAACC,GAAL,CAASL,QAAM,CAACpB,GAAP,GAAaoB,QAAM,CAACnB,MAA7B,EAAqCyB,MAAM,CAACC,WAAP,GAAqB9B,sBAA1D,CAAH,EAAoF,IAApF,CAFJ;EAGD;AACF,CApED;;AAsEA,OAAM,SAAU+B,kBAAV,CACJC,YADI,EAEJC,mBAFI,EAGJC,QAHI,EAIJC,UAJI,EAKJC,YALI,EAKgB;EAEpB;EACA;EACA;EACA;EACM,SAA8ChD,QAAQ,CAAC,KAAD,CAAtD;EAAA,IAACW,kBAAkB,QAAnB;EAAA,IAAqBsC,qBAAqB,QAA1C;;EACN,IAAMrC,sBAAsB,GAAGD,kBAAkB,GAAG,CAAH,GAAOqC,YAAxD;EAEAjD,SAAS,CAAC;IACR,IAAIK,sBAAsB,EAA1B,EAA8B;MAC5B,IAAM8C,eAAa,GAAG;QACpB5C,cAAc,CACZwC,QAAQ,CAACK,OADG,EAEZJ,UAAU,CAACI,OAFC,EAGZP,YAAY,CAACO,OAHD,EAIZN,mBAAmB,CAACM,OAJR,EAKZxC,kBALY,EAMZC,sBANY,CAAd;MAQD,CATD;;MAUAsC,eAAa;MACbT,MAAM,CAACW,gBAAP,CAAwB,QAAxB,EAAkCF,eAAlC,EAAiD,IAAjD;MACA,OAAO;QACLT,MAAM,CAACY,mBAAP,CAA2B,QAA3B,EAAqCH,eAArC,EAAoD,IAApD;MACD,CAFD;IAGD;EACF,CAlBQ,EAkBN,CAACN,YAAD,EAAeE,QAAf,EAAyBC,UAAzB,EAAqCnC,sBAArC,EAA6DiC,mBAA7D,EAAkFlC,kBAAlF,CAlBM,CAAT;EAoBA,IAAMH,SAAS,GAAGuC,UAAU,CAACI,OAA7B;EACApD,SAAS,CAAC;IACR,IAAIS,SAAS,IAAIJ,sBAAsB,EAAvC,EAA2C;MACzC6C,qBAAqB,CAAC,CAAC,CAAC5C,kBAAkB,CAACG,SAAD,CAArB,CAArB;IACD;EACF,CAJQ,EAIN,CAACA,SAAD,CAJM,CAAT;EAMAT,SAAS,CAAC;IACR,IAAIK,sBAAsB,MAAM0C,QAAQ,CAACK,OAAzC,EAAkD;MAChD,IAAMG,UAAQ,GAAG,IAAIxD,cAAJ,CAAmB,mBAAO;QACzC,IAAI+C,mBAAmB,CAACM,OAAxB,EAAiC;UAC/BN,mBAAmB,CAACM,OAApB,CAA4BjB,KAA5B,CAAkCZ,KAAlC,GAA0C,UAAGiC,OAAO,CAAC,CAAD,CAAP,CAAWC,aAAX,CAAyB,CAAzB,EAA4BC,UAA/B,EAAyC,IAAzC,CAA1C;UACAnD,cAAc,CACZwC,QAAQ,CAACK,OADG,EAEZJ,UAAU,CAACI,OAFC,EAGZP,YAAY,CAACO,OAHD,EAIZN,mBAAmB,CAACM,OAJR,EAKZxC,kBALY,EAMZC,sBANY,CAAd;QAQD;MACF,CAZgB,CAAjB;MAaA0C,UAAQ,CAACI,OAAT,CAAiBZ,QAAQ,CAACK,OAA1B;MACA,OAAO;QACLG,UAAQ,CAACK,UAAT;MACD,CAFD;IAGD;EACF,CApBQ,EAoBN,CAACd,mBAAD,EAAsBD,YAAtB,EAAoCE,QAApC,EAA8CC,UAA9C,EAA0DnC,sBAA1D,EAAkFD,kBAAlF,CApBM,CAAT;EAsBAZ,SAAS,CAAC;IACR,IAAIK,sBAAsB,EAA1B,EAA8B;MAC5B,IAAMwD,eAAa,GAAG;QACpBtD,cAAc,CACZwC,QAAQ,CAACK,OADG,EAEZJ,UAAU,CAACI,OAFC,EAGZP,YAAY,CAACO,OAHD,EAIZN,mBAAmB,CAACM,OAJR,EAKZxC,kBALY,EAMZC,sBANY,CAAd;MAQD,CATD;;MAUA6B,MAAM,CAACW,gBAAP,CAAwB,QAAxB,EAAkCQ,eAAlC;MACA,OAAO;QACLnB,MAAM,CAACY,mBAAP,CAA2B,QAA3B,EAAqCO,eAArC;MACD,CAFD;IAGD;EACF,CAjBQ,EAiBN,CAACd,QAAD,EAAWC,UAAX,EAAuBH,YAAvB,EAAqCC,mBAArC,EAA0DlC,kBAA1D,EAA8EC,sBAA9E,CAjBM,CAAT;AAkBD","names":["ResizeObserver","useEffect","useState","styles","getOverflowParentDimensions","browserScrollbarSize","supportsStickyPosition","getContainingBlock","updatePosition","tableEl","wrapperEl","scrollbarEl","scrollbarContentEl","hasContainingBlock","consideredFooterHeight","parent","parentBottom","top","height","getBoundingClientRect","tableTop","tableBottom","tableWidth","wrapperWidth","width","scrollbarHeight","scrollBarCorrection","tableBottomIsVisible","tableTopIsHidden","areaIsScrollable","classList","remove","contains","requestAnimationFrame","scrollLeft","add","style","parent_1","wrapperElRect","tableElRect","left","Math","min","window","innerHeight","useStickyScrollbar","scrollbarRef","scrollbarContentRef","tableRef","wrapperRef","footerHeight","setHasContainingBlock","scrollHandler_1","current","addEventListener","removeEventListener","observer_1","entries","borderBoxSize","inlineSize","observe","disconnect","resizeHandler_1"],"sourceRoot":"","sources":["../../../src/table/use-sticky-scrollbar.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { RefObject, useEffect, useState } from 'react';\nimport styles from './styles.css.js';\n\nimport { getOverflowParentDimensions } from '../internal/utils/scrollable-containers';\nimport { browserScrollbarSize } from '../internal/utils/browser-scrollbar-size';\nimport { supportsStickyPosition, getContainingBlock } from '../internal/utils/dom';\n\nconst updatePosition = (\n  tableEl: HTMLElement | null,\n  wrapperEl: HTMLElement | null,\n  scrollbarEl: HTMLElement | null,\n  scrollbarContentEl: HTMLElement | null,\n  hasContainingBlock: boolean,\n  consideredFooterHeight: number\n) => {\n  if (!tableEl || !scrollbarEl || !wrapperEl) {\n    return;\n  }\n\n  // parent is either some container or document itself\n  const parent = getOverflowParentDimensions(wrapperEl)[0];\n  const parentBottom = parent.top + parent.height;\n\n  // table bottom is visible when\n  // 1. table bottom reached end of the window\n  // 2. table bottom is not overlapped by footer\n  const { top: tableTop, bottom: tableBottom, width: tableWidth } = tableEl.getBoundingClientRect();\n  const { width: wrapperWidth } = wrapperEl.getBoundingClientRect();\n\n  //scrollbar correction is needed for\n  // #1 when scrollbars are constantly visible,\n  // we want no visible break when switching between fake and real scrollbars\n  // #2 when scrollbars are visible only on scrolling and half transparent (on mac)\n  // we want to avoid any overlap between fake and real scrollbar\n  // using 15 px as a height of transparent scrollbar on mac\n  const scrollbarHeight = browserScrollbarSize().height;\n  const scrollBarCorrection = scrollbarHeight > 0 ? scrollbarHeight : -15 / 2;\n  const tableBottomIsVisible = parentBottom - consideredFooterHeight >= tableBottom + scrollBarCorrection;\n  const tableTopIsHidden = tableTop >= parentBottom - consideredFooterHeight - scrollBarCorrection;\n  const areaIsScrollable = tableWidth > wrapperWidth;\n\n  if (tableBottomIsVisible || tableTopIsHidden || !areaIsScrollable) {\n    scrollbarEl.classList.remove(styles['sticky-scrollbar-visible']);\n  } else {\n    // when scrollbar is not displayed scrollLeft property cannot be set by useScrollSync\n    // that's why syncing it separately\n    if (!scrollbarEl.classList.contains(styles['sticky-scrollbar-visible'])) {\n      requestAnimationFrame(() => {\n        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;\n      });\n    }\n\n    scrollbarEl.classList.add(styles['sticky-scrollbar-visible']);\n  }\n\n  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {\n    scrollbarEl.style.height = `${scrollbarHeight}px`;\n    scrollbarContentEl.style.height = `${scrollbarHeight}px`;\n  }\n\n  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {\n    const parent = getOverflowParentDimensions(wrapperEl)[0];\n\n    const wrapperElRect = wrapperEl.getBoundingClientRect();\n    const tableElRect = tableEl.getBoundingClientRect();\n    scrollbarEl.style.width = `${wrapperElRect.width}px`;\n    scrollbarContentEl.style.width = `${tableElRect.width}px`;\n\n    // when using sticky scrollbars in containers\n    // we agreed to ignore dynamic bottom calculations for footer overlap\n    scrollbarEl.style.left = hasContainingBlock ? '0px' : `${wrapperElRect.left}px`;\n    scrollbarEl.style.top = hasContainingBlock\n      ? '0px'\n      : `${Math.min(parent.top + parent.height, window.innerHeight - consideredFooterHeight)}px`;\n  }\n};\n\nexport function useStickyScrollbar(\n  scrollbarRef: RefObject<HTMLDivElement>,\n  scrollbarContentRef: RefObject<HTMLDivElement>,\n  tableRef: RefObject<HTMLTableElement>,\n  wrapperRef: RefObject<HTMLDivElement>,\n  footerHeight: number\n) {\n  // We don't take into account containing-block calculations because that would\n  // unnecessarily overcomplicate the position logic. For now, we assume that a\n  // containing block, if present, is below the app layout and above the overflow\n  // parent, which is a pretty safe assumption.\n  const [hasContainingBlock, setHasContainingBlock] = useState(false);\n  const consideredFooterHeight = hasContainingBlock ? 0 : footerHeight;\n\n  useEffect(() => {\n    if (supportsStickyPosition()) {\n      const scrollHandler = () => {\n        updatePosition(\n          tableRef.current,\n          wrapperRef.current,\n          scrollbarRef.current,\n          scrollbarContentRef.current,\n          hasContainingBlock,\n          consideredFooterHeight\n        );\n      };\n      scrollHandler();\n      window.addEventListener('scroll', scrollHandler, true);\n      return () => {\n        window.removeEventListener('scroll', scrollHandler, true);\n      };\n    }\n  }, [scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, scrollbarContentRef, hasContainingBlock]);\n\n  const wrapperEl = wrapperRef.current;\n  useEffect(() => {\n    if (wrapperEl && supportsStickyPosition()) {\n      setHasContainingBlock(!!getContainingBlock(wrapperEl));\n    }\n  }, [wrapperEl]);\n\n  useEffect(() => {\n    if (supportsStickyPosition() && tableRef.current) {\n      const observer = new ResizeObserver(entries => {\n        if (scrollbarContentRef.current) {\n          scrollbarContentRef.current.style.width = `${entries[0].borderBoxSize[0].inlineSize}px`;\n          updatePosition(\n            tableRef.current,\n            wrapperRef.current,\n            scrollbarRef.current,\n            scrollbarContentRef.current,\n            hasContainingBlock,\n            consideredFooterHeight\n          );\n        }\n      });\n      observer.observe(tableRef.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);\n\n  useEffect(() => {\n    if (supportsStickyPosition()) {\n      const resizeHandler = () => {\n        updatePosition(\n          tableRef.current,\n          wrapperRef.current,\n          scrollbarRef.current,\n          scrollbarContentRef.current,\n          hasContainingBlock,\n          consideredFooterHeight\n        );\n      };\n      window.addEventListener('resize', resizeHandler);\n      return () => {\n        window.removeEventListener('resize', resizeHandler);\n      };\n    }\n  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);\n}\n"]},"metadata":{},"sourceType":"module"}