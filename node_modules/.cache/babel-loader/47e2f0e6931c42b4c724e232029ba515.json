{"ast":null,"code":"export var getOverflowParents = function (element) {\n  var parents = [];\n  var node = element;\n\n  while ((node = node.parentElement) && node !== document.body) {\n    getComputedStyle(node).overflow !== 'visible' && parents.push(node);\n  }\n\n  return parents;\n};\nexport var getOverflowParentDimensions = function (element, excludeClosestParent, expandToViewport, canExpandOutsideViewport) {\n  if (excludeClosestParent === void 0) {\n    excludeClosestParent = false;\n  }\n\n  if (expandToViewport === void 0) {\n    expandToViewport = false;\n  }\n\n  if (canExpandOutsideViewport === void 0) {\n    canExpandOutsideViewport = false;\n  }\n\n  var parents = expandToViewport ? [] : getOverflowParents(element).map(function (el) {\n    var _a = el.getBoundingClientRect(),\n        height = _a.height,\n        width = _a.width,\n        top = _a.top,\n        left = _a.left;\n\n    return {\n      // Treat the whole scrollable area as the available height\n      // if we're allowed to expand past the viewport.\n      height: canExpandOutsideViewport ? el.scrollHeight : height,\n      width: width,\n      top: top,\n      left: left\n    };\n  });\n\n  if (canExpandOutsideViewport && !expandToViewport) {\n    var documentDimensions = document.documentElement.getBoundingClientRect();\n    parents.push({\n      width: Math.max(documentDimensions.width, document.documentElement.clientWidth),\n      height: Math.max(documentDimensions.height, document.documentElement.clientHeight),\n      top: documentDimensions.top,\n      left: documentDimensions.left\n    });\n  } else {\n    parents.push({\n      height: window.innerHeight,\n      width: window.innerWidth,\n      top: 0,\n      left: 0\n    });\n  }\n\n  if (excludeClosestParent && !expandToViewport) {\n    parents.shift();\n  }\n\n  return parents;\n};\n/**\n * If the element is out of view, scrolls the scroll parent until\n * the element is visible.\n *\n * Basically an IE11/Safari polyfill for `elem.scrollIntoView({ block: 'nearest' })`\n */\n\nexport function scrollUntilVisible(element) {\n  var _a;\n\n  var parent = (_a = element.offsetParent) !== null && _a !== void 0 ? _a : document.documentElement; // Anchor to top of scroll parent.\n\n  if (element.offsetTop < parent.scrollTop) {\n    parent.scrollTop = element.offsetTop;\n  } // Anchor to bottom of scroll parent.\n\n\n  if (element.offsetTop + element.clientHeight > parent.scrollTop + parent.clientHeight) {\n    parent.scrollTop = element.offsetTop + element.clientHeight - parent.clientHeight;\n  }\n}\n/**\n * Calls `scrollIntoView` on the provided element with sensible defaults. If\n * the element does not existed or does not support the `scrollIntoView`\n * method, it will do nothing. This wrapper is created to support environments\n * where the native function is not available like JSDom (feature request:\n * https://github.com/jsdom/jsdom/issues/1422).\n *\n * @param element to be scrolled into view\n * @param options native options for `scrollIntoView`\n */\n\nexport function scrollElementIntoView(element, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {\n      block: 'nearest',\n      inline: 'nearest'\n    };\n  }\n\n  (_a = element === null || element === void 0 ? void 0 : element.scrollIntoView) === null || _a === void 0 ? void 0 : _a.call(element, options);\n}","map":{"version":3,"mappings":"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","names":["getOverflowParents","element","parents","node","parentElement","document","body","getComputedStyle","overflow","push","getOverflowParentDimensions","excludeClosestParent","expandToViewport","canExpandOutsideViewport","map","el","getBoundingClientRect","height","width","top","left","scrollHeight","documentDimensions","documentElement","Math","max","clientWidth","clientHeight","window","innerHeight","innerWidth","shift","scrollUntilVisible","parent","offsetParent","_a","offsetTop","scrollTop","scrollElementIntoView","options","block","inline","scrollIntoView"],"sourceRoot":"","sources":["../../../../src/internal/utils/scrollable-containers.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport interface Dimensions {\n  height: number;\n  width: number;\n  top: number;\n  left: number;\n}\n\nexport const getOverflowParents = (element: HTMLElement): HTMLElement[] => {\n  const parents = [];\n  let node: HTMLElement | null = element;\n\n  while ((node = node.parentElement) && node !== document.body) {\n    getComputedStyle(node).overflow !== 'visible' && parents.push(node);\n  }\n  return parents;\n};\n\nexport const getOverflowParentDimensions = (\n  element: HTMLElement,\n  excludeClosestParent = false,\n  expandToViewport = false,\n  canExpandOutsideViewport = false\n): Dimensions[] => {\n  const parents = expandToViewport\n    ? []\n    : getOverflowParents(element).map(el => {\n        const { height, width, top, left } = el.getBoundingClientRect();\n        return {\n          // Treat the whole scrollable area as the available height\n          // if we're allowed to expand past the viewport.\n          height: canExpandOutsideViewport ? el.scrollHeight : height,\n          width,\n          top,\n          left,\n        };\n      });\n\n  if (canExpandOutsideViewport && !expandToViewport) {\n    const documentDimensions = document.documentElement.getBoundingClientRect();\n    parents.push({\n      width: Math.max(documentDimensions.width, document.documentElement.clientWidth),\n      height: Math.max(documentDimensions.height, document.documentElement.clientHeight),\n      top: documentDimensions.top,\n      left: documentDimensions.left,\n    });\n  } else {\n    parents.push({\n      height: window.innerHeight,\n      width: window.innerWidth,\n      top: 0,\n      left: 0,\n    });\n  }\n\n  if (excludeClosestParent && !expandToViewport) {\n    parents.shift();\n  }\n\n  return parents;\n};\n\n/**\n * If the element is out of view, scrolls the scroll parent until\n * the element is visible.\n *\n * Basically an IE11/Safari polyfill for `elem.scrollIntoView({ block: 'nearest' })`\n */\nexport function scrollUntilVisible(element: HTMLElement): void {\n  const parent = element.offsetParent ?? document.documentElement;\n  // Anchor to top of scroll parent.\n  if (element.offsetTop < parent.scrollTop) {\n    parent.scrollTop = element.offsetTop;\n  }\n  // Anchor to bottom of scroll parent.\n  if (element.offsetTop + element.clientHeight > parent.scrollTop + parent.clientHeight) {\n    parent.scrollTop = element.offsetTop + element.clientHeight - parent.clientHeight;\n  }\n}\n\ntype ScrollIntoViewOptions = Parameters<HTMLElement['scrollIntoView']>[0];\n\n/**\n * Calls `scrollIntoView` on the provided element with sensible defaults. If\n * the element does not existed or does not support the `scrollIntoView`\n * method, it will do nothing. This wrapper is created to support environments\n * where the native function is not available like JSDom (feature request:\n * https://github.com/jsdom/jsdom/issues/1422).\n *\n * @param element to be scrolled into view\n * @param options native options for `scrollIntoView`\n */\nexport function scrollElementIntoView(\n  element: HTMLElement | undefined,\n  options: ScrollIntoViewOptions = { block: 'nearest', inline: 'nearest' }\n) {\n  element?.scrollIntoView?.(options);\n}\n"]},"metadata":{},"sourceType":"module"}