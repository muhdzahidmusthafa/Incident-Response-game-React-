{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\n\nexport function useResizeObserver(elementRef, onObserve) {\n  var stableOnObserve = useStableEventHandler(onObserve); // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n\n  useLayoutEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (element) {\n      onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n    }\n  }, // This effect is only needed for the first render to provide a synchronous update.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (element) {\n      var connected_1 = true;\n      var observer_1 = new ResizeObserver(function (entries) {\n        // Prevent observe notifications on already unmounted component.\n        if (connected_1) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer_1.observe(element);\n      return function () {\n        connected_1 = false;\n        observer_1.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\n\nfunction convertResizeObserverEntry(entry) {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize\n  };\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,SAASA,cAAT,EAAyBC,mBAAzB,QAAoD,yBAApD;AACA,SAAgBC,SAAhB,EAA2BC,eAA3B,QAAkD,OAAlD;AACA,SAASC,qBAAT,QAAsC,6BAAtC;AAKA;;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,iBAAV,CAA4BC,UAA5B,EAA0DC,SAA1D,EAAyG;EAC7G,IAAMC,eAAe,GAAGJ,qBAAqB,CAACG,SAAD,CAA7C,CAD6G,CAG7G;EACA;EACA;;EACAJ,eAAe,CACb;IACE,IAAMM,OAAO,GAAG,OAAOH,UAAP,KAAsB,UAAtB,GAAmCA,UAAU,EAA7C,GAAkDA,UAAU,SAAV,cAAU,WAAV,GAAU,MAAV,aAAU,CAAEI,OAA9E;;IACA,IAAID,OAAJ,EAAa;MACXF,SAAS,CAACI,0BAA0B,CAAC,IAAIV,mBAAJ,CAAwBQ,OAAxB,CAAD,CAA3B,CAAT;IACD;EACF,CANY,EAOb;EACA;EACA,EATa,CAAf;EAYAP,SAAS,CAAC;IACR,IAAMO,OAAO,GAAG,OAAOH,UAAP,KAAsB,UAAtB,GAAmCA,UAAU,EAA7C,GAAkDA,UAAU,SAAV,cAAU,WAAV,GAAU,MAAV,aAAU,CAAEI,OAA9E;;IACA,IAAID,OAAJ,EAAa;MACX,IAAIG,WAAS,GAAG,IAAhB;MACA,IAAMC,UAAQ,GAAG,IAAIb,cAAJ,CAAmB,mBAAO;QACzC;QACA,IAAIY,WAAJ,EAAe;UACbJ,eAAe,CAACG,0BAA0B,CAACG,OAAO,CAAC,CAAD,CAAR,CAA3B,CAAf;QACD;MACF,CALgB,CAAjB;MAMAD,UAAQ,CAACE,OAAT,CAAiBN,OAAjB;MACA,OAAO;QACLG,WAAS,GAAG,KAAZ;QACAC,UAAQ,CAACG,UAAT;MACD,CAHD;IAID;EACF,CAhBQ,EAgBN,CAACV,UAAD,EAAaE,eAAb,CAhBM,CAAT;AAiBD;;AAED,SAASG,0BAAT,CAAoCM,KAApC,EAA8D;EAC5D,OAAO;IACLC,MAAM,EAAED,KAAK,CAACC,MADT;IAELC,eAAe,EAAEF,KAAK,CAACG,cAAN,CAAqB,CAArB,EAAwBC,UAFpC;IAGLC,gBAAgB,EAAEL,KAAK,CAACG,cAAN,CAAqB,CAArB,EAAwBG,SAHrC;IAILC,cAAc,EAAEP,KAAK,CAACQ,aAAN,CAAoB,CAApB,EAAuBJ,UAJlC;IAKLK,eAAe,EAAET,KAAK,CAACQ,aAAN,CAAoB,CAApB,EAAuBF,SALnC;IAMLI,KAAK,EAAEV,KAAK,CAACG,cAAN,CAAqB,CAArB,EAAwBC,UAN1B;IAOLO,MAAM,EAAEX,KAAK,CAACG,cAAN,CAAqB,CAArB,EAAwBG;EAP3B,CAAP;AASD","names":["ResizeObserver","ResizeObserverEntry","useEffect","useLayoutEffect","useStableEventHandler","useResizeObserver","elementRef","onObserve","stableOnObserve","element","current","convertResizeObserverEntry","connected_1","observer_1","entries","observe","disconnect","entry","target","contentBoxWidth","contentBoxSize","inlineSize","contentBoxHeight","blockSize","borderBoxWidth","borderBoxSize","borderBoxHeight","width","height"],"sourceRoot":"","sources":["../../../../../src/internal/hooks/container-queries/use-resize-observer.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport React, { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\nimport { ContainerQueryEntry } from './interfaces';\n\ntype ElementReference = (() => Element | null) | React.RefObject<Element>;\n\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\nexport function useResizeObserver(elementRef: ElementReference, onObserve: (entry: ContainerQueryEntry) => void) {\n  const stableOnObserve = useStableEventHandler(onObserve);\n\n  // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n  useLayoutEffect(\n    () => {\n      const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n      if (element) {\n        onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n      }\n    },\n    // This effect is only needed for the first render to provide a synchronous update.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  useEffect(() => {\n    const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n    if (element) {\n      let connected = true;\n      const observer = new ResizeObserver(entries => {\n        // Prevent observe notifications on already unmounted component.\n        if (connected) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer.observe(element);\n      return () => {\n        connected = false;\n        observer.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\n\nfunction convertResizeObserverEntry(entry: ResizeObserverEntry): ContainerQueryEntry {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}